// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ibc/lightclients/tendermint/v1/tendermint.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  ClientState from Tendermint tracks the current validator set, latest height,
///  and a possible frozen height.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.lightclients.tendermint.v1.ClientState)
pub struct ClientState {
    // message fields
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.chain_id)
    pub chain_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.trust_level)
    pub trust_level: ::protobuf::MessageField<Fraction>,
    ///  duration of the period since the LastestTimestamp during which the
    ///  submitted headers are valid for upgrade
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.trusting_period)
    pub trusting_period: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    ///  duration of the staking unbonding period
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.unbonding_period)
    pub unbonding_period: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    ///  defines how much new (untrusted) header's Time can drift into the future.
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.max_clock_drift)
    pub max_clock_drift: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    ///  Block height when the client was frozen due to a misbehaviour
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.frozen_height)
    pub frozen_height: ::protobuf::MessageField<super::client::Height>,
    ///  Latest height the client was updated to
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.latest_height)
    pub latest_height: ::protobuf::MessageField<super::client::Height>,
    ///  Proof specifications used in verifying counterparty state
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.proof_specs)
    pub proof_specs: ::std::vec::Vec<super::proofs::ProofSpec>,
    ///  Path at which next upgraded client will be committed.
    ///  Each element corresponds to the key for a single CommitmentProof in the
    ///  chained proof. NOTE: ClientState must stored under
    ///  `{upgradePath}/{upgradeHeight}/clientState` ConsensusState must be stored
    ///  under `{upgradepath}/{upgradeHeight}/consensusState` For SDK chains using
    ///  the default upgrade module, upgrade_path should be []string{"upgrade",
    ///  "upgradedIBCState"}`
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.upgrade_path)
    pub upgrade_path: ::std::vec::Vec<::std::string::String>,
    ///  This flag, when set to true, will allow governance to recover a client
    ///  which has expired
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.allow_update_after_expiry)
    pub allow_update_after_expiry: bool,
    ///  This flag, when set to true, will allow governance to unfreeze a client
    ///  whose chain has experienced a misbehaviour event
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ClientState.allow_update_after_misbehaviour)
    pub allow_update_after_misbehaviour: bool,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.lightclients.tendermint.v1.ClientState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientState {
    fn default() -> &'a ClientState {
        <ClientState as ::protobuf::Message>::default_instance()
    }
}

impl ClientState {
    pub fn new() -> ClientState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &ClientState| { &m.chain_id },
            |m: &mut ClientState| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Fraction>(
            "trust_level",
            |m: &ClientState| { &m.trust_level },
            |m: &mut ClientState| { &mut m.trust_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "trusting_period",
            |m: &ClientState| { &m.trusting_period },
            |m: &mut ClientState| { &mut m.trusting_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "unbonding_period",
            |m: &ClientState| { &m.unbonding_period },
            |m: &mut ClientState| { &mut m.unbonding_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "max_clock_drift",
            |m: &ClientState| { &m.max_clock_drift },
            |m: &mut ClientState| { &mut m.max_clock_drift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "frozen_height",
            |m: &ClientState| { &m.frozen_height },
            |m: &mut ClientState| { &mut m.frozen_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "latest_height",
            |m: &ClientState| { &m.latest_height },
            |m: &mut ClientState| { &mut m.latest_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "proof_specs",
            |m: &ClientState| { &m.proof_specs },
            |m: &mut ClientState| { &mut m.proof_specs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "upgrade_path",
            |m: &ClientState| { &m.upgrade_path },
            |m: &mut ClientState| { &mut m.upgrade_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_update_after_expiry",
            |m: &ClientState| { &m.allow_update_after_expiry },
            |m: &mut ClientState| { &mut m.allow_update_after_expiry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_update_after_misbehaviour",
            |m: &ClientState| { &m.allow_update_after_misbehaviour },
            |m: &mut ClientState| { &mut m.allow_update_after_misbehaviour },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientState>(
            "ClientState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientState {
    const NAME: &'static str = "ClientState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chain_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trust_level)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trusting_period)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unbonding_period)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_clock_drift)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.frozen_height)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.latest_height)?;
                },
                66 => {
                    self.proof_specs.push(is.read_message()?);
                },
                74 => {
                    self.upgrade_path.push(is.read_string()?);
                },
                80 => {
                    self.allow_update_after_expiry = is.read_bool()?;
                },
                88 => {
                    self.allow_update_after_misbehaviour = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chain_id);
        }
        if let Some(v) = self.trust_level.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trusting_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unbonding_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_clock_drift.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.frozen_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.latest_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.proof_specs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.upgrade_path {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.allow_update_after_expiry != false {
            my_size += 1 + 1;
        }
        if self.allow_update_after_misbehaviour != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.chain_id.is_empty() {
            os.write_string(1, &self.chain_id)?;
        }
        if let Some(v) = self.trust_level.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.trusting_period.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.unbonding_period.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.max_clock_drift.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.frozen_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.latest_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.proof_specs {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.upgrade_path {
            os.write_string(9, &v)?;
        };
        if self.allow_update_after_expiry != false {
            os.write_bool(10, self.allow_update_after_expiry)?;
        }
        if self.allow_update_after_misbehaviour != false {
            os.write_bool(11, self.allow_update_after_misbehaviour)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientState {
        ClientState::new()
    }

    fn clear(&mut self) {
        self.chain_id.clear();
        self.trust_level.clear();
        self.trusting_period.clear();
        self.unbonding_period.clear();
        self.max_clock_drift.clear();
        self.frozen_height.clear();
        self.latest_height.clear();
        self.proof_specs.clear();
        self.upgrade_path.clear();
        self.allow_update_after_expiry = false;
        self.allow_update_after_misbehaviour = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientState {
        static instance: ClientState = ClientState {
            chain_id: ::std::string::String::new(),
            trust_level: ::protobuf::MessageField::none(),
            trusting_period: ::protobuf::MessageField::none(),
            unbonding_period: ::protobuf::MessageField::none(),
            max_clock_drift: ::protobuf::MessageField::none(),
            frozen_height: ::protobuf::MessageField::none(),
            latest_height: ::protobuf::MessageField::none(),
            proof_specs: ::std::vec::Vec::new(),
            upgrade_path: ::std::vec::Vec::new(),
            allow_update_after_expiry: false,
            allow_update_after_misbehaviour: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConsensusState defines the consensus state from Tendermint.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.lightclients.tendermint.v1.ConsensusState)
pub struct ConsensusState {
    // message fields
    ///  timestamp that corresponds to the block height in which the ConsensusState
    ///  was stored.
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ConsensusState.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  commitment root (i.e app hash)
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ConsensusState.root)
    pub root: ::protobuf::MessageField<super::commitment::MerkleRoot>,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.ConsensusState.next_validators_hash)
    pub next_validators_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.lightclients.tendermint.v1.ConsensusState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConsensusState {
    fn default() -> &'a ConsensusState {
        <ConsensusState as ::protobuf::Message>::default_instance()
    }
}

impl ConsensusState {
    pub fn new() -> ConsensusState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &ConsensusState| { &m.timestamp },
            |m: &mut ConsensusState| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::commitment::MerkleRoot>(
            "root",
            |m: &ConsensusState| { &m.root },
            |m: &mut ConsensusState| { &mut m.root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_validators_hash",
            |m: &ConsensusState| { &m.next_validators_hash },
            |m: &mut ConsensusState| { &mut m.next_validators_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConsensusState>(
            "ConsensusState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConsensusState {
    const NAME: &'static str = "ConsensusState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.root)?;
                },
                26 => {
                    self.next_validators_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.root.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.next_validators_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.next_validators_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.root.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.next_validators_hash.is_empty() {
            os.write_bytes(3, &self.next_validators_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConsensusState {
        ConsensusState::new()
    }

    fn clear(&mut self) {
        self.timestamp.clear();
        self.root.clear();
        self.next_validators_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConsensusState {
        static instance: ConsensusState = ConsensusState {
            timestamp: ::protobuf::MessageField::none(),
            root: ::protobuf::MessageField::none(),
            next_validators_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConsensusState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConsensusState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConsensusState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Misbehaviour is a wrapper over two conflicting Headers
///  that implements Misbehaviour interface expected by ICS-02
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.lightclients.tendermint.v1.Misbehaviour)
pub struct Misbehaviour {
    // message fields
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Misbehaviour.client_id)
    pub client_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Misbehaviour.header_1)
    pub header_1: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Misbehaviour.header_2)
    pub header_2: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.lightclients.tendermint.v1.Misbehaviour.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Misbehaviour {
    fn default() -> &'a Misbehaviour {
        <Misbehaviour as ::protobuf::Message>::default_instance()
    }
}

impl Misbehaviour {
    pub fn new() -> Misbehaviour {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &Misbehaviour| { &m.client_id },
            |m: &mut Misbehaviour| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header_1",
            |m: &Misbehaviour| { &m.header_1 },
            |m: &mut Misbehaviour| { &mut m.header_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header_2",
            |m: &Misbehaviour| { &m.header_2 },
            |m: &mut Misbehaviour| { &mut m.header_2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Misbehaviour>(
            "Misbehaviour",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Misbehaviour {
    const NAME: &'static str = "Misbehaviour";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_1)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_2)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        if let Some(v) = self.header_1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.header_2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        if let Some(v) = self.header_1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.header_2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Misbehaviour {
        Misbehaviour::new()
    }

    fn clear(&mut self) {
        self.client_id.clear();
        self.header_1.clear();
        self.header_2.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Misbehaviour {
        static instance: Misbehaviour = Misbehaviour {
            client_id: ::std::string::String::new(),
            header_1: ::protobuf::MessageField::none(),
            header_2: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Misbehaviour {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Misbehaviour").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Misbehaviour {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Misbehaviour {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Header defines the Tendermint client consensus Header.
///  It encapsulates all the information necessary to update from a trusted
///  Tendermint ConsensusState. The inclusion of TrustedHeight and
///  TrustedValidators allows this update to process correctly, so long as the
///  ConsensusState for the TrustedHeight exists, this removes race conditions
///  among relayers The SignedHeader and ValidatorSet are the new untrusted update
///  fields for the client. The TrustedHeight is the height of a stored
///  ConsensusState on the client that will be used to verify the new untrusted
///  header. The Trusted ConsensusState must be within the unbonding period of
///  current time in order to correctly verify, and the TrustedValidators must
///  hash to TrustedConsensusState.NextValidatorsHash since that is the last
///  trusted validator set at the TrustedHeight.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.lightclients.tendermint.v1.Header)
pub struct Header {
    // message fields
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Header.signed_header)
    pub signed_header: ::protobuf::MessageField<super::types::SignedHeader>,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Header.validator_set)
    pub validator_set: ::protobuf::MessageField<super::validator::ValidatorSet>,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Header.trusted_height)
    pub trusted_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Header.trusted_validators)
    pub trusted_validators: ::protobuf::MessageField<super::validator::ValidatorSet>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.lightclients.tendermint.v1.Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::SignedHeader>(
            "signed_header",
            |m: &Header| { &m.signed_header },
            |m: &mut Header| { &mut m.signed_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::validator::ValidatorSet>(
            "validator_set",
            |m: &Header| { &m.validator_set },
            |m: &mut Header| { &mut m.validator_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "trusted_height",
            |m: &Header| { &m.trusted_height },
            |m: &mut Header| { &mut m.trusted_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::validator::ValidatorSet>(
            "trusted_validators",
            |m: &Header| { &m.trusted_validators },
            |m: &mut Header| { &mut m.trusted_validators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
            "Header",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.signed_header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.validator_set)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trusted_height)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trusted_validators)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signed_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.validator_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trusted_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trusted_validators.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signed_header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.validator_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.trusted_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.trusted_validators.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.signed_header.clear();
        self.validator_set.clear();
        self.trusted_height.clear();
        self.trusted_validators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            signed_header: ::protobuf::MessageField::none(),
            validator_set: ::protobuf::MessageField::none(),
            trusted_height: ::protobuf::MessageField::none(),
            trusted_validators: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Header {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Header").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Fraction defines the protobuf message type for tmmath.Fraction that only
///  supports positive values.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.lightclients.tendermint.v1.Fraction)
pub struct Fraction {
    // message fields
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Fraction.numerator)
    pub numerator: u64,
    // @@protoc_insertion_point(field:ibc.lightclients.tendermint.v1.Fraction.denominator)
    pub denominator: u64,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.lightclients.tendermint.v1.Fraction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Fraction {
    fn default() -> &'a Fraction {
        <Fraction as ::protobuf::Message>::default_instance()
    }
}

impl Fraction {
    pub fn new() -> Fraction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "numerator",
            |m: &Fraction| { &m.numerator },
            |m: &mut Fraction| { &mut m.numerator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "denominator",
            |m: &Fraction| { &m.denominator },
            |m: &mut Fraction| { &mut m.denominator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fraction>(
            "Fraction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Fraction {
    const NAME: &'static str = "Fraction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.numerator = is.read_uint64()?;
                },
                16 => {
                    self.denominator = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.numerator != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.numerator);
        }
        if self.denominator != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.denominator);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.numerator != 0 {
            os.write_uint64(1, self.numerator)?;
        }
        if self.denominator != 0 {
            os.write_uint64(2, self.denominator)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Fraction {
        Fraction::new()
    }

    fn clear(&mut self) {
        self.numerator = 0;
        self.denominator = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Fraction {
        static instance: Fraction = Fraction {
            numerator: 0,
            denominator: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Fraction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Fraction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Fraction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Fraction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n/ibc/lightclients/tendermint/v1/tendermint.proto\x12\x1eibc.lightclien\
    ts.tendermint.v1\x1a\x20tendermint/types/validator.proto\x1a\x1ctendermi\
    nt/types/types.proto\x1a\x13confio/proofs.proto\x1a\x1egoogle/protobuf/d\
    uration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1fibc/core/cli\
    ent/v1/client.proto\x1a'ibc/core/commitment/v1/commitment.proto\x1a\x14g\
    ogoproto/gogo.proto\"\xe8\x07\n\x0bClientState\x12\x19\n\x08chain_id\x18\
    \x01\x20\x01(\tR\x07chainId\x12e\n\x0btrust_level\x18\x02\x20\x01(\x0b2(\
    .ibc.lightclients.tendermint.v1.FractionR\ntrustLevelB\x1a\xf2\xde\x1f\
    \x12yaml:\"trust_level\"\xc8\xde\x1f\0\x12f\n\x0ftrusting_period\x18\x03\
    \x20\x01(\x0b2\x19.google.protobuf.DurationR\x0etrustingPeriodB\"\xf2\
    \xde\x1f\x16yaml:\"trusting_period\"\xc8\xde\x1f\0\x98\xdf\x1f\x01\x12i\
    \n\x10unbonding_period\x18\x04\x20\x01(\x0b2\x19.google.protobuf.Duratio\
    nR\x0funbondingPeriodB#\xf2\xde\x1f\x17yaml:\"unbonding_period\"\xc8\xde\
    \x1f\0\x98\xdf\x1f\x01\x12e\n\x0fmax_clock_drift\x18\x05\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\rmaxClockDriftB\"\xf2\xde\x1f\x16yaml:\"m\
    ax_clock_drift\"\xc8\xde\x1f\0\x98\xdf\x1f\x01\x12]\n\rfrozen_height\x18\
    \x06\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0cfrozenHeightB\x1c\
    \xf2\xde\x1f\x14yaml:\"frozen_height\"\xc8\xde\x1f\0\x12]\n\rlatest_heig\
    ht\x18\x07\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0clatestHeightB\
    \x1c\xf2\xde\x1f\x14yaml:\"latest_height\"\xc8\xde\x1f\0\x12I\n\x0bproof\
    _specs\x18\x08\x20\x03(\x0b2\x10.ics23.ProofSpecR\nproofSpecsB\x16\xf2\
    \xde\x1f\x12yaml:\"proof_specs\"\x12:\n\x0cupgrade_path\x18\t\x20\x03(\t\
    R\x0bupgradePathB\x17\xf2\xde\x1f\x13yaml:\"upgrade_path\"\x12_\n\x19all\
    ow_update_after_expiry\x18\n\x20\x01(\x08R\x16allowUpdateAfterExpiryB$\
    \xf2\xde\x1f\x20yaml:\"allow_update_after_expiry\"\x12q\n\x1fallow_updat\
    e_after_misbehaviour\x18\x0b\x20\x01(\x08R\x1callowUpdateAfterMisbehavio\
    urB*\xf2\xde\x1f&yaml:\"allow_update_after_misbehaviour\":\x04\x88\xa0\
    \x1f\0\"\xa4\x02\n\x0eConsensusState\x12B\n\ttimestamp\x18\x01\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\ttimestampB\x08\xc8\xde\x1f\0\x90\
    \xdf\x1f\x01\x12<\n\x04root\x18\x02\x20\x01(\x0b2\".ibc.core.commitment.\
    v1.MerkleRootR\x04rootB\x04\xc8\xde\x1f\0\x12\x89\x01\n\x14next_validato\
    rs_hash\x18\x03\x20\x01(\x0cR\x12nextValidatorsHashBW\xfa\xde\x1f4github\
    .com/tendermint/tendermint/libs/bytes.HexBytes\xf2\xde\x1f\x1byaml:\"nex\
    t_validators_hash\":\x04\x88\xa0\x1f\0\"\x8d\x02\n\x0cMisbehaviour\x121\
    \n\tclient_id\x18\x01\x20\x01(\tR\x08clientIdB\x14\xf2\xde\x1f\x10yaml:\
    \"client_id\"\x12a\n\x08header_1\x18\x02\x20\x01(\x0b2&.ibc.lightclients\
    .tendermint.v1.HeaderR\x07header1B\x1e\xf2\xde\x1f\x0fyaml:\"header_1\"\
    \xe2\xde\x1f\x07Header1\x12a\n\x08header_2\x18\x03\x20\x01(\x0b2&.ibc.li\
    ghtclients.tendermint.v1.HeaderR\x07header2B\x1e\xf2\xde\x1f\x0fyaml:\"h\
    eader_2\"\xe2\xde\x1f\x07Header2:\x04\x88\xa0\x1f\0\"\x9a\x03\n\x06Heade\
    r\x12a\n\rsigned_header\x18\x01\x20\x01(\x0b2\x1e.tendermint.types.Signe\
    dHeaderR\x0csignedHeaderB\x1c\xf2\xde\x1f\x14yaml:\"signed_header\"\xd0\
    \xde\x1f\x01\x12]\n\rvalidator_set\x18\x02\x20\x01(\x0b2\x1e.tendermint.\
    types.ValidatorSetR\x0cvalidatorSetB\x18\xf2\xde\x1f\x14yaml:\"validator\
    _set\"\x12`\n\x0etrusted_height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.clien\
    t.v1.HeightR\rtrustedHeightB\x1d\xf2\xde\x1f\x15yaml:\"trusted_height\"\
    \xc8\xde\x1f\0\x12l\n\x12trusted_validators\x18\x04\x20\x01(\x0b2\x1e.te\
    ndermint.types.ValidatorSetR\x11trustedValidatorsB\x1d\xf2\xde\x1f\x19ya\
    ml:\"trusted_validators\"\"J\n\x08Fraction\x12\x1c\n\tnumerator\x18\x01\
    \x20\x01(\x04R\tnumerator\x12\x20\n\x0bdenominator\x18\x02\x20\x01(\x04R\
    \x0bdenominatorBGZEgithub.com/cosmos/ibc-go/v3/modules/light-clients/07-\
    tendermint/typesJ\xb7&\n\x06\x12\x04\0\0r\x01\n\x08\n\x01\x0c\x12\x03\0\
    \0\x12\n\x08\n\x01\x02\x12\x03\x02\0'\n\x08\n\x01\x08\x12\x03\x04\0\\\n\
    \t\n\x02\x08\x0b\x12\x03\x04\0\\\n\t\n\x02\x03\0\x12\x03\x06\0*\n\t\n\
    \x02\x03\x01\x12\x03\x07\0&\n\t\n\x02\x03\x02\x12\x03\x08\0\x1d\n\t\n\
    \x02\x03\x03\x12\x03\t\0(\n\t\n\x02\x03\x04\x12\x03\n\0)\n\t\n\x02\x03\
    \x05\x12\x03\x0b\0)\n\t\n\x02\x03\x06\x12\x03\x0c\01\n\t\n\x02\x03\x07\
    \x12\x03\r\0\x1e\ny\n\x02\x04\0\x12\x04\x11\0<\x01\x1am\x20ClientState\
    \x20from\x20Tendermint\x20tracks\x20the\x20current\x20validator\x20set,\
    \x20latest\x20height,\n\x20and\x20a\x20possible\x20frozen\x20height.\n\n\
    \n\n\x03\x04\0\x01\x12\x03\x11\x08\x13\n\n\n\x03\x04\0\x07\x12\x03\x12\
    \x02-\n\r\n\x06\x04\0\x07\x81\xf4\x03\x12\x03\x12\x02-\n\x0b\n\x04\x04\0\
    \x02\0\x12\x03\x14\x02\x1b\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x14\x02\
    \x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x14\x0b\x13\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03\x14\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x15\x02\
    i\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x15\x02\n\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x15\x0b\x16\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x15\
    \x19\x1a\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03\x15\x1bh\n\x0f\n\x08\x04\
    \0\x02\x01\x08\xe9\xfb\x03\x12\x03\x15\x1c8\n\x0f\n\x08\x04\0\x02\x01\
    \x08\xee\xfb\x03\x12\x03\x15:g\n{\n\x04\x04\0\x02\x02\x12\x04\x18\x02\
    \x19x\x1am\x20duration\x20of\x20the\x20period\x20since\x20the\x20Lastest\
    Timestamp\x20during\x20which\x20the\n\x20submitted\x20headers\x20are\x20\
    valid\x20for\x20upgrade\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x18\x02\
    \x1a\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x18\x1b*\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03\x18-.\n\x0c\n\x05\x04\0\x02\x02\x08\x12\x03\x19\x06\
    w\n\x0f\n\x08\x04\0\x02\x02\x08\xe9\xfb\x03\x12\x03\x19\x07#\n\x0f\n\x08\
    \x04\0\x02\x02\x08\xf3\xfb\x03\x12\x03\x19%C\n\x0f\n\x08\x04\0\x02\x02\
    \x08\xee\xfb\x03\x12\x03\x19Ev\n8\n\x04\x04\0\x02\x03\x12\x04\x1b\x02\
    \x1f\x04\x1a*\x20duration\x20of\x20the\x20staking\x20unbonding\x20period\
    \n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x1b\x02\x1a\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\x1b\x1b+\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x1b.\
    /\n\r\n\x05\x04\0\x02\x03\x08\x12\x04\x1b0\x1f\x03\n\x0f\n\x08\x04\0\x02\
    \x03\x08\xe9\xfb\x03\x12\x03\x1c\x04#\n\x0f\n\x08\x04\0\x02\x03\x08\xf3\
    \xfb\x03\x12\x03\x1d\x04\"\n\x0f\n\x08\x04\0\x02\x03\x08\xee\xfb\x03\x12\
    \x03\x1e\x049\nY\n\x04\x04\0\x02\x04\x12\x04!\x02\"x\x1aK\x20defines\x20\
    how\x20much\x20new\x20(untrusted)\x20header's\x20Time\x20can\x20drift\
    \x20into\x20the\x20future.\n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03!\x02\
    \x1a\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03!\x1b*\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03!-.\n\x0c\n\x05\x04\0\x02\x04\x08\x12\x03\"\x06w\n\x0f\n\
    \x08\x04\0\x02\x04\x08\xe9\xfb\x03\x12\x03\"\x07#\n\x0f\n\x08\x04\0\x02\
    \x04\x08\xf3\xfb\x03\x12\x03\"%C\n\x0f\n\x08\x04\0\x02\x04\x08\xee\xfb\
    \x03\x12\x03\"Ev\nM\n\x04\x04\0\x02\x05\x12\x04$\x02%V\x1a?\x20Block\x20\
    height\x20when\x20the\x20client\x20was\x20frozen\x20due\x20to\x20a\x20mi\
    sbehaviour\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03$\x02\x1b\n\x0c\n\x05\
    \x04\0\x02\x05\x01\x12\x03$\x1c)\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03$,\
    -\n\x0c\n\x05\x04\0\x02\x05\x08\x12\x03%\x06U\n\x0f\n\x08\x04\0\x02\x05\
    \x08\xe9\xfb\x03\x12\x03%\x07#\n\x0f\n\x08\x04\0\x02\x05\x08\xee\xfb\x03\
    \x12\x03%%T\n7\n\x04\x04\0\x02\x06\x12\x04'\x02(V\x1a)\x20Latest\x20heig\
    ht\x20the\x20client\x20was\x20updated\x20to\n\n\x0c\n\x05\x04\0\x02\x06\
    \x06\x12\x03'\x02\x1b\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03'\x1c)\n\x0c\
    \n\x05\x04\0\x02\x06\x03\x12\x03',-\n\x0c\n\x05\x04\0\x02\x06\x08\x12\
    \x03(\x06U\n\x0f\n\x08\x04\0\x02\x06\x08\xe9\xfb\x03\x12\x03(\x07#\n\x0f\
    \n\x08\x04\0\x02\x06\x08\xee\xfb\x03\x12\x03(%T\nH\n\x04\x04\0\x02\x07\
    \x12\x03+\x02[\x1a;\x20Proof\x20specifications\x20used\x20in\x20verifyin\
    g\x20counterparty\x20state\n\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03+\x02\
    \n\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03+\x0b\x1a\n\x0c\n\x05\x04\0\x02\
    \x07\x01\x12\x03+\x1b&\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03+)*\n\x0c\n\
    \x05\x04\0\x02\x07\x08\x12\x03++Z\n\x0f\n\x08\x04\0\x02\x07\x08\xee\xfb\
    \x03\x12\x03+,Y\n\xb6\x03\n\x04\x04\0\x02\x08\x12\x034\x02T\x1a\xa8\x03\
    \x20Path\x20at\x20which\x20next\x20upgraded\x20client\x20will\x20be\x20c\
    ommitted.\n\x20Each\x20element\x20corresponds\x20to\x20the\x20key\x20for\
    \x20a\x20single\x20CommitmentProof\x20in\x20the\n\x20chained\x20proof.\
    \x20NOTE:\x20ClientState\x20must\x20stored\x20under\n\x20`{upgradePath}/\
    {upgradeHeight}/clientState`\x20ConsensusState\x20must\x20be\x20stored\n\
    \x20under\x20`{upgradepath}/{upgradeHeight}/consensusState`\x20For\x20SD\
    K\x20chains\x20using\n\x20the\x20default\x20upgrade\x20module,\x20upgrad\
    e_path\x20should\x20be\x20[]string{\"upgrade\",\n\x20\"upgradedIBCState\
    \"}`\n\n\x0c\n\x05\x04\0\x02\x08\x04\x12\x034\x02\n\n\x0c\n\x05\x04\0\
    \x02\x08\x05\x12\x034\x0b\x11\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x034\x12\
    \x1e\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x034!\"\n\x0c\n\x05\x04\0\x02\x08\
    \x08\x12\x034#S\n\x0f\n\x08\x04\0\x02\x08\x08\xee\xfb\x03\x12\x034$R\nh\
    \n\x04\x04\0\x02\t\x12\x038\x02d\x1a[\x20This\x20flag,\x20when\x20set\
    \x20to\x20true,\x20will\x20allow\x20governance\x20to\x20recover\x20a\x20\
    client\n\x20which\x20has\x20expired\n\n\x0c\n\x05\x04\0\x02\t\x05\x12\
    \x038\x02\x06\n\x0c\n\x05\x04\0\x02\t\x01\x12\x038\x07\x20\n\x0c\n\x05\
    \x04\0\x02\t\x03\x12\x038#%\n\x0c\n\x05\x04\0\x02\t\x08\x12\x038&c\n\x0f\
    \n\x08\x04\0\x02\t\x08\xee\xfb\x03\x12\x038'b\n\x88\x01\n\x04\x04\0\x02\
    \n\x12\x03;\x02p\x1a{\x20This\x20flag,\x20when\x20set\x20to\x20true,\x20\
    will\x20allow\x20governance\x20to\x20unfreeze\x20a\x20client\n\x20whose\
    \x20chain\x20has\x20experienced\x20a\x20misbehaviour\x20event\n\n\x0c\n\
    \x05\x04\0\x02\n\x05\x12\x03;\x02\x06\n\x0c\n\x05\x04\0\x02\n\x01\x12\
    \x03;\x07&\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03;)+\n\x0c\n\x05\x04\0\x02\
    \n\x08\x12\x03;,o\n\x0f\n\x08\x04\0\x02\n\x08\xee\xfb\x03\x12\x03;-n\nI\
    \n\x02\x04\x01\x12\x04?\0K\x01\x1a=\x20ConsensusState\x20defines\x20the\
    \x20consensus\x20state\x20from\x20Tendermint.\n\n\n\n\x03\x04\x01\x01\
    \x12\x03?\x08\x16\n\n\n\x03\x04\x01\x07\x12\x03@\x02-\n\r\n\x06\x04\x01\
    \x07\x81\xf4\x03\x12\x03@\x02-\nf\n\x04\x04\x01\x02\0\x12\x03D\x02e\x1aY\
    \x20timestamp\x20that\x20corresponds\x20to\x20the\x20block\x20height\x20\
    in\x20which\x20the\x20ConsensusState\n\x20was\x20stored.\n\n\x0c\n\x05\
    \x04\x01\x02\0\x06\x12\x03D\x02\x1b\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03D\x1c%\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03D()\n\x0c\n\x05\x04\x01\
    \x02\0\x08\x12\x03D*d\n\x0f\n\x08\x04\x01\x02\0\x08\xe9\xfb\x03\x12\x03D\
    +G\n\x0f\n\x08\x04\x01\x02\0\x08\xf2\xfb\x03\x12\x03DIc\n-\n\x04\x04\x01\
    \x02\x01\x12\x03F\x02\\\x1a\x20\x20commitment\x20root\x20(i.e\x20app\x20\
    hash)\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03F\x02#\n\x0c\n\x05\x04\
    \x01\x02\x01\x01\x12\x03F$(\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03F;<\n\
    \x0c\n\x05\x04\x01\x02\x01\x08\x12\x03F=[\n\x0f\n\x08\x04\x01\x02\x01\
    \x08\xe9\xfb\x03\x12\x03F>Z\n\x0c\n\x04\x04\x01\x02\x02\x12\x04G\x02J\
    \x04\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03G\x02\x07\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03G$8\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03G;<\n\
    \r\n\x05\x04\x01\x02\x02\x08\x12\x04G=J\x03\n\x0f\n\x08\x04\x01\x02\x02\
    \x08\xef\xfb\x03\x12\x03H\x04Q\n\x0f\n\x08\x04\x01\x02\x02\x08\xee\xfb\
    \x03\x12\x03I\x04:\n\x7f\n\x02\x04\x02\x12\x04O\0U\x01\x1as\x20Misbehavi\
    our\x20is\x20a\x20wrapper\x20over\x20two\x20conflicting\x20Headers\n\x20\
    that\x20implements\x20Misbehaviour\x20interface\x20expected\x20by\x20ICS\
    -02\n\n\n\n\x03\x04\x02\x01\x12\x03O\x08\x14\n\n\n\x03\x04\x02\x07\x12\
    \x03P\x02-\n\r\n\x06\x04\x02\x07\x81\xf4\x03\x12\x03P\x02-\n\x0b\n\x04\
    \x04\x02\x02\0\x12\x03R\x02E\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03R\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03R\t\x12\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03R\x15\x16\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03R\x17D\
    \n\x0f\n\x08\x04\x02\x02\0\x08\xee\xfb\x03\x12\x03R\x18C\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x03S\x02h\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03S\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03S\t\x11\n\x0c\n\x05\x04\x02\
    \x02\x01\x03\x12\x03S\x15\x16\n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x03S\
    \x17g\n\x0f\n\x08\x04\x02\x02\x01\x08\xec\xfb\x03\x12\x03S\x18:\n\x0f\n\
    \x08\x04\x02\x02\x01\x08\xee\xfb\x03\x12\x03S<f\n\x0b\n\x04\x04\x02\x02\
    \x02\x12\x03T\x02h\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03T\x02\x08\n\
    \x0c\n\x05\x04\x02\x02\x02\x01\x12\x03T\t\x11\n\x0c\n\x05\x04\x02\x02\
    \x02\x03\x12\x03T\x15\x16\n\x0c\n\x05\x04\x02\x02\x02\x08\x12\x03T\x17g\
    \n\x0f\n\x08\x04\x02\x02\x02\x08\xec\xfb\x03\x12\x03T\x18:\n\x0f\n\x08\
    \x04\x02\x02\x02\x08\xee\xfb\x03\x12\x03T<f\n\xcd\x06\n\x02\x04\x03\x12\
    \x04c\0k\x01\x1a\xc0\x06\x20Header\x20defines\x20the\x20Tendermint\x20cl\
    ient\x20consensus\x20Header.\n\x20It\x20encapsulates\x20all\x20the\x20in\
    formation\x20necessary\x20to\x20update\x20from\x20a\x20trusted\n\x20Tend\
    ermint\x20ConsensusState.\x20The\x20inclusion\x20of\x20TrustedHeight\x20\
    and\n\x20TrustedValidators\x20allows\x20this\x20update\x20to\x20process\
    \x20correctly,\x20so\x20long\x20as\x20the\n\x20ConsensusState\x20for\x20\
    the\x20TrustedHeight\x20exists,\x20this\x20removes\x20race\x20conditions\
    \n\x20among\x20relayers\x20The\x20SignedHeader\x20and\x20ValidatorSet\
    \x20are\x20the\x20new\x20untrusted\x20update\n\x20fields\x20for\x20the\
    \x20client.\x20The\x20TrustedHeight\x20is\x20the\x20height\x20of\x20a\
    \x20stored\n\x20ConsensusState\x20on\x20the\x20client\x20that\x20will\
    \x20be\x20used\x20to\x20verify\x20the\x20new\x20untrusted\n\x20header.\
    \x20The\x20Trusted\x20ConsensusState\x20must\x20be\x20within\x20the\x20u\
    nbonding\x20period\x20of\n\x20current\x20time\x20in\x20order\x20to\x20co\
    rrectly\x20verify,\x20and\x20the\x20TrustedValidators\x20must\n\x20hash\
    \x20to\x20TrustedConsensusState.NextValidatorsHash\x20since\x20that\x20i\
    s\x20the\x20last\n\x20trusted\x20validator\x20set\x20at\x20the\x20Truste\
    dHeight.\n\n\n\n\x03\x04\x03\x01\x12\x03c\x08\x0e\n\x0c\n\x04\x04\x03\
    \x02\0\x12\x04d\x02eR\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03d\x02\x20\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03d!.\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03d12\n\x0c\n\x05\x04\x03\x02\0\x08\x12\x03e\x06Q\n\x0f\n\x08\x04\
    \x03\x02\0\x08\xea\xfb\x03\x12\x03e\x07\x1f\n\x0f\n\x08\x04\x03\x02\0\
    \x08\xee\xfb\x03\x12\x03e!P\n\x0b\n\x04\x04\x03\x02\x01\x12\x03g\x02f\n\
    \x0c\n\x05\x04\x03\x02\x01\x06\x12\x03g\x02\x20\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03g!.\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03g23\n\x0c\n\
    \x05\x04\x03\x02\x01\x08\x12\x03g4e\n\x0f\n\x08\x04\x03\x02\x01\x08\xee\
    \xfb\x03\x12\x03g5d\n\x0c\n\x04\x04\x03\x02\x02\x12\x04h\x02iW\n\x0c\n\
    \x05\x04\x03\x02\x02\x06\x12\x03h\x02\x1b\n\x0c\n\x05\x04\x03\x02\x02\
    \x01\x12\x03h!/\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03h23\n\x0c\n\x05\
    \x04\x03\x02\x02\x08\x12\x03i\x06V\n\x0f\n\x08\x04\x03\x02\x02\x08\xe9\
    \xfb\x03\x12\x03i\x07#\n\x0f\n\x08\x04\x03\x02\x02\x08\xee\xfb\x03\x12\
    \x03i%U\n\x0b\n\x04\x04\x03\x02\x03\x12\x03j\x02o\n\x0c\n\x05\x04\x03\
    \x02\x03\x06\x12\x03j\x02\x20\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03j!3\
    \n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03j67\n\x0c\n\x05\x04\x03\x02\x03\
    \x08\x12\x03j8n\n\x0f\n\x08\x04\x03\x02\x03\x08\xee\xfb\x03\x12\x03j9m\n\
    q\n\x02\x04\x04\x12\x04o\0r\x01\x1ae\x20Fraction\x20defines\x20the\x20pr\
    otobuf\x20message\x20type\x20for\x20tmmath.Fraction\x20that\x20only\n\
    \x20supports\x20positive\x20values.\n\n\n\n\x03\x04\x04\x01\x12\x03o\x08\
    \x10\n\x0b\n\x04\x04\x04\x02\0\x12\x03p\x02\x19\n\x0c\n\x05\x04\x04\x02\
    \0\x05\x12\x03p\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03p\t\x12\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03p\x17\x18\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x03q\x02\x19\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03q\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03q\t\x14\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03q\x17\x18b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(8);
            deps.push(super::validator::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(super::proofs::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::client::file_descriptor().clone());
            deps.push(super::commitment::file_descriptor().clone());
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(ClientState::generated_message_descriptor_data());
            messages.push(ConsensusState::generated_message_descriptor_data());
            messages.push(Misbehaviour::generated_message_descriptor_data());
            messages.push(Header::generated_message_descriptor_data());
            messages.push(Fraction::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
