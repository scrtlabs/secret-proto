// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ibc/core/channel/v1/tx.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It
///  is called by a relayer on Chain A.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenInit)
pub struct MsgChannelOpenInit {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenInit.port_id)
    pub port_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenInit.channel)
    pub channel: ::protobuf::MessageField<super::channel::Channel>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenInit.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenInit {
    fn default() -> &'a MsgChannelOpenInit {
        <MsgChannelOpenInit as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenInit {
    pub fn new() -> MsgChannelOpenInit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &MsgChannelOpenInit| { &m.port_id },
            |m: &mut MsgChannelOpenInit| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::channel::Channel>(
            "channel",
            |m: &MsgChannelOpenInit| { &m.channel },
            |m: &mut MsgChannelOpenInit| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgChannelOpenInit| { &m.signer },
            |m: &mut MsgChannelOpenInit| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenInit>(
            "MsgChannelOpenInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenInit {
    const NAME: &'static str = "MsgChannelOpenInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.channel)?;
                },
                26 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if let Some(v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if let Some(v) = self.channel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(3, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenInit {
        MsgChannelOpenInit::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenInit {
        static instance: MsgChannelOpenInit = MsgChannelOpenInit {
            port_id: ::std::string::String::new(),
            channel: ::protobuf::MessageField::none(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelOpenInitResponse defines the Msg/ChannelOpenInit response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenInitResponse)
pub struct MsgChannelOpenInitResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenInitResponse.channel_id)
    pub channel_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenInitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenInitResponse {
    fn default() -> &'a MsgChannelOpenInitResponse {
        <MsgChannelOpenInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenInitResponse {
    pub fn new() -> MsgChannelOpenInitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &MsgChannelOpenInitResponse| { &m.channel_id },
            |m: &mut MsgChannelOpenInitResponse| { &mut m.channel_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenInitResponse>(
            "MsgChannelOpenInitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenInitResponse {
    const NAME: &'static str = "MsgChannelOpenInitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channel_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenInitResponse {
        MsgChannelOpenInitResponse::new()
    }

    fn clear(&mut self) {
        self.channel_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenInitResponse {
        static instance: MsgChannelOpenInitResponse = MsgChannelOpenInitResponse {
            channel_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenInitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenInitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenInitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelOpenInit defines a msg sent by a Relayer to try to open a channel
///  on Chain B. The version field within the Channel field has been deprecated. Its
///  value will be ignored by core IBC.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenTry)
pub struct MsgChannelOpenTry {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenTry.port_id)
    pub port_id: ::std::string::String,
    ///  in the case of crossing hello's, when both chains call OpenInit, we need
    ///  the channel identifier of the previous channel in state INIT
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenTry.previous_channel_id)
    pub previous_channel_id: ::std::string::String,
    ///  NOTE: the version field within the channel has been deprecated. Its value will be ignored by core IBC.
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenTry.channel)
    pub channel: ::protobuf::MessageField<super::channel::Channel>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenTry.counterparty_version)
    pub counterparty_version: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenTry.proof_init)
    pub proof_init: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenTry.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenTry.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenTry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenTry {
    fn default() -> &'a MsgChannelOpenTry {
        <MsgChannelOpenTry as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenTry {
    pub fn new() -> MsgChannelOpenTry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &MsgChannelOpenTry| { &m.port_id },
            |m: &mut MsgChannelOpenTry| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "previous_channel_id",
            |m: &MsgChannelOpenTry| { &m.previous_channel_id },
            |m: &mut MsgChannelOpenTry| { &mut m.previous_channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::channel::Channel>(
            "channel",
            |m: &MsgChannelOpenTry| { &m.channel },
            |m: &mut MsgChannelOpenTry| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "counterparty_version",
            |m: &MsgChannelOpenTry| { &m.counterparty_version },
            |m: &mut MsgChannelOpenTry| { &mut m.counterparty_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_init",
            |m: &MsgChannelOpenTry| { &m.proof_init },
            |m: &mut MsgChannelOpenTry| { &mut m.proof_init },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgChannelOpenTry| { &m.proof_height },
            |m: &mut MsgChannelOpenTry| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgChannelOpenTry| { &m.signer },
            |m: &mut MsgChannelOpenTry| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenTry>(
            "MsgChannelOpenTry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenTry {
    const NAME: &'static str = "MsgChannelOpenTry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.previous_channel_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.channel)?;
                },
                34 => {
                    self.counterparty_version = is.read_string()?;
                },
                42 => {
                    self.proof_init = is.read_bytes()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                58 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.previous_channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.previous_channel_id);
        }
        if let Some(v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.counterparty_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.counterparty_version);
        }
        if !self.proof_init.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.proof_init);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.previous_channel_id.is_empty() {
            os.write_string(2, &self.previous_channel_id)?;
        }
        if let Some(v) = self.channel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.counterparty_version.is_empty() {
            os.write_string(4, &self.counterparty_version)?;
        }
        if !self.proof_init.is_empty() {
            os.write_bytes(5, &self.proof_init)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(7, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenTry {
        MsgChannelOpenTry::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.previous_channel_id.clear();
        self.channel.clear();
        self.counterparty_version.clear();
        self.proof_init.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenTry {
        static instance: MsgChannelOpenTry = MsgChannelOpenTry {
            port_id: ::std::string::String::new(),
            previous_channel_id: ::std::string::String::new(),
            channel: ::protobuf::MessageField::none(),
            counterparty_version: ::std::string::String::new(),
            proof_init: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenTry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenTry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenTry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenTry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelOpenTryResponse defines the Msg/ChannelOpenTry response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenTryResponse)
pub struct MsgChannelOpenTryResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenTryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenTryResponse {
    fn default() -> &'a MsgChannelOpenTryResponse {
        <MsgChannelOpenTryResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenTryResponse {
    pub fn new() -> MsgChannelOpenTryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenTryResponse>(
            "MsgChannelOpenTryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenTryResponse {
    const NAME: &'static str = "MsgChannelOpenTryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenTryResponse {
        MsgChannelOpenTryResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenTryResponse {
        static instance: MsgChannelOpenTryResponse = MsgChannelOpenTryResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenTryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenTryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenTryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenTryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge
///  the change of channel state to TRYOPEN on Chain B.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenAck)
pub struct MsgChannelOpenAck {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenAck.port_id)
    pub port_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenAck.channel_id)
    pub channel_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_channel_id)
    pub counterparty_channel_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_version)
    pub counterparty_version: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenAck.proof_try)
    pub proof_try: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenAck.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenAck.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenAck {
    fn default() -> &'a MsgChannelOpenAck {
        <MsgChannelOpenAck as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenAck {
    pub fn new() -> MsgChannelOpenAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &MsgChannelOpenAck| { &m.port_id },
            |m: &mut MsgChannelOpenAck| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &MsgChannelOpenAck| { &m.channel_id },
            |m: &mut MsgChannelOpenAck| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "counterparty_channel_id",
            |m: &MsgChannelOpenAck| { &m.counterparty_channel_id },
            |m: &mut MsgChannelOpenAck| { &mut m.counterparty_channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "counterparty_version",
            |m: &MsgChannelOpenAck| { &m.counterparty_version },
            |m: &mut MsgChannelOpenAck| { &mut m.counterparty_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_try",
            |m: &MsgChannelOpenAck| { &m.proof_try },
            |m: &mut MsgChannelOpenAck| { &mut m.proof_try },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgChannelOpenAck| { &m.proof_height },
            |m: &mut MsgChannelOpenAck| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgChannelOpenAck| { &m.signer },
            |m: &mut MsgChannelOpenAck| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenAck>(
            "MsgChannelOpenAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenAck {
    const NAME: &'static str = "MsgChannelOpenAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    self.counterparty_channel_id = is.read_string()?;
                },
                34 => {
                    self.counterparty_version = is.read_string()?;
                },
                42 => {
                    self.proof_try = is.read_bytes()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                58 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.counterparty_channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.counterparty_channel_id);
        }
        if !self.counterparty_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.counterparty_version);
        }
        if !self.proof_try.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.proof_try);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.counterparty_channel_id.is_empty() {
            os.write_string(3, &self.counterparty_channel_id)?;
        }
        if !self.counterparty_version.is_empty() {
            os.write_string(4, &self.counterparty_version)?;
        }
        if !self.proof_try.is_empty() {
            os.write_bytes(5, &self.proof_try)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(7, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenAck {
        MsgChannelOpenAck::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.counterparty_channel_id.clear();
        self.counterparty_version.clear();
        self.proof_try.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenAck {
        static instance: MsgChannelOpenAck = MsgChannelOpenAck {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            counterparty_channel_id: ::std::string::String::new(),
            counterparty_version: ::std::string::String::new(),
            proof_try: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelOpenAckResponse defines the Msg/ChannelOpenAck response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenAckResponse)
pub struct MsgChannelOpenAckResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenAckResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenAckResponse {
    fn default() -> &'a MsgChannelOpenAckResponse {
        <MsgChannelOpenAckResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenAckResponse {
    pub fn new() -> MsgChannelOpenAckResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenAckResponse>(
            "MsgChannelOpenAckResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenAckResponse {
    const NAME: &'static str = "MsgChannelOpenAckResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenAckResponse {
        MsgChannelOpenAckResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenAckResponse {
        static instance: MsgChannelOpenAckResponse = MsgChannelOpenAckResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenAckResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenAckResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenAckResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenAckResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to
///  acknowledge the change of channel state to OPEN on Chain A.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenConfirm)
pub struct MsgChannelOpenConfirm {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenConfirm.port_id)
    pub port_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenConfirm.channel_id)
    pub channel_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_ack)
    pub proof_ack: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelOpenConfirm.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenConfirm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenConfirm {
    fn default() -> &'a MsgChannelOpenConfirm {
        <MsgChannelOpenConfirm as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenConfirm {
    pub fn new() -> MsgChannelOpenConfirm {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &MsgChannelOpenConfirm| { &m.port_id },
            |m: &mut MsgChannelOpenConfirm| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &MsgChannelOpenConfirm| { &m.channel_id },
            |m: &mut MsgChannelOpenConfirm| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_ack",
            |m: &MsgChannelOpenConfirm| { &m.proof_ack },
            |m: &mut MsgChannelOpenConfirm| { &mut m.proof_ack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgChannelOpenConfirm| { &m.proof_height },
            |m: &mut MsgChannelOpenConfirm| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgChannelOpenConfirm| { &m.signer },
            |m: &mut MsgChannelOpenConfirm| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenConfirm>(
            "MsgChannelOpenConfirm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenConfirm {
    const NAME: &'static str = "MsgChannelOpenConfirm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    self.proof_ack = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                42 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.proof_ack.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_ack);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.proof_ack.is_empty() {
            os.write_bytes(3, &self.proof_ack)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenConfirm {
        MsgChannelOpenConfirm::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.proof_ack.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenConfirm {
        static instance: MsgChannelOpenConfirm = MsgChannelOpenConfirm {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            proof_ack: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenConfirm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenConfirm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenConfirm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelOpenConfirmResponse defines the Msg/ChannelOpenConfirm response
///  type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelOpenConfirmResponse)
pub struct MsgChannelOpenConfirmResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelOpenConfirmResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenConfirmResponse {
    fn default() -> &'a MsgChannelOpenConfirmResponse {
        <MsgChannelOpenConfirmResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenConfirmResponse {
    pub fn new() -> MsgChannelOpenConfirmResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelOpenConfirmResponse>(
            "MsgChannelOpenConfirmResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelOpenConfirmResponse {
    const NAME: &'static str = "MsgChannelOpenConfirmResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelOpenConfirmResponse {
        MsgChannelOpenConfirmResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelOpenConfirmResponse {
        static instance: MsgChannelOpenConfirmResponse = MsgChannelOpenConfirmResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelOpenConfirmResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelOpenConfirmResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelOpenConfirmResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenConfirmResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelCloseInit defines a msg sent by a Relayer to Chain A
///  to close a channel with Chain B.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelCloseInit)
pub struct MsgChannelCloseInit {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseInit.port_id)
    pub port_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseInit.channel_id)
    pub channel_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseInit.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelCloseInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseInit {
    fn default() -> &'a MsgChannelCloseInit {
        <MsgChannelCloseInit as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseInit {
    pub fn new() -> MsgChannelCloseInit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &MsgChannelCloseInit| { &m.port_id },
            |m: &mut MsgChannelCloseInit| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &MsgChannelCloseInit| { &m.channel_id },
            |m: &mut MsgChannelCloseInit| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgChannelCloseInit| { &m.signer },
            |m: &mut MsgChannelCloseInit| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelCloseInit>(
            "MsgChannelCloseInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelCloseInit {
    const NAME: &'static str = "MsgChannelCloseInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.signer.is_empty() {
            os.write_string(3, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelCloseInit {
        MsgChannelCloseInit::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelCloseInit {
        static instance: MsgChannelCloseInit = MsgChannelCloseInit {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelCloseInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelCloseInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelCloseInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelCloseInitResponse defines the Msg/ChannelCloseInit response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelCloseInitResponse)
pub struct MsgChannelCloseInitResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelCloseInitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseInitResponse {
    fn default() -> &'a MsgChannelCloseInitResponse {
        <MsgChannelCloseInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseInitResponse {
    pub fn new() -> MsgChannelCloseInitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelCloseInitResponse>(
            "MsgChannelCloseInitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelCloseInitResponse {
    const NAME: &'static str = "MsgChannelCloseInitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelCloseInitResponse {
        MsgChannelCloseInitResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelCloseInitResponse {
        static instance: MsgChannelCloseInitResponse = MsgChannelCloseInitResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelCloseInitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelCloseInitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelCloseInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseInitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B
///  to acknowledge the change of channel state to CLOSED on Chain A.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelCloseConfirm)
pub struct MsgChannelCloseConfirm {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseConfirm.port_id)
    pub port_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseConfirm.channel_id)
    pub channel_id: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_init)
    pub proof_init: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgChannelCloseConfirm.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelCloseConfirm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseConfirm {
    fn default() -> &'a MsgChannelCloseConfirm {
        <MsgChannelCloseConfirm as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseConfirm {
    pub fn new() -> MsgChannelCloseConfirm {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &MsgChannelCloseConfirm| { &m.port_id },
            |m: &mut MsgChannelCloseConfirm| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &MsgChannelCloseConfirm| { &m.channel_id },
            |m: &mut MsgChannelCloseConfirm| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_init",
            |m: &MsgChannelCloseConfirm| { &m.proof_init },
            |m: &mut MsgChannelCloseConfirm| { &mut m.proof_init },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgChannelCloseConfirm| { &m.proof_height },
            |m: &mut MsgChannelCloseConfirm| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgChannelCloseConfirm| { &m.signer },
            |m: &mut MsgChannelCloseConfirm| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelCloseConfirm>(
            "MsgChannelCloseConfirm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelCloseConfirm {
    const NAME: &'static str = "MsgChannelCloseConfirm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    self.proof_init = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                42 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.proof_init.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_init);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.proof_init.is_empty() {
            os.write_bytes(3, &self.proof_init)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelCloseConfirm {
        MsgChannelCloseConfirm::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.proof_init.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelCloseConfirm {
        static instance: MsgChannelCloseConfirm = MsgChannelCloseConfirm {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            proof_init: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelCloseConfirm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelCloseConfirm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelCloseConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseConfirm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgChannelCloseConfirmResponse defines the Msg/ChannelCloseConfirm response
///  type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgChannelCloseConfirmResponse)
pub struct MsgChannelCloseConfirmResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgChannelCloseConfirmResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseConfirmResponse {
    fn default() -> &'a MsgChannelCloseConfirmResponse {
        <MsgChannelCloseConfirmResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseConfirmResponse {
    pub fn new() -> MsgChannelCloseConfirmResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgChannelCloseConfirmResponse>(
            "MsgChannelCloseConfirmResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgChannelCloseConfirmResponse {
    const NAME: &'static str = "MsgChannelCloseConfirmResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgChannelCloseConfirmResponse {
        MsgChannelCloseConfirmResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgChannelCloseConfirmResponse {
        static instance: MsgChannelCloseConfirmResponse = MsgChannelCloseConfirmResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgChannelCloseConfirmResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgChannelCloseConfirmResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgChannelCloseConfirmResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseConfirmResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgRecvPacket receives incoming IBC packet
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgRecvPacket)
pub struct MsgRecvPacket {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgRecvPacket.packet)
    pub packet: ::protobuf::MessageField<super::channel::Packet>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgRecvPacket.proof_commitment)
    pub proof_commitment: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgRecvPacket.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgRecvPacket.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgRecvPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgRecvPacket {
    fn default() -> &'a MsgRecvPacket {
        <MsgRecvPacket as ::protobuf::Message>::default_instance()
    }
}

impl MsgRecvPacket {
    pub fn new() -> MsgRecvPacket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::channel::Packet>(
            "packet",
            |m: &MsgRecvPacket| { &m.packet },
            |m: &mut MsgRecvPacket| { &mut m.packet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_commitment",
            |m: &MsgRecvPacket| { &m.proof_commitment },
            |m: &mut MsgRecvPacket| { &mut m.proof_commitment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgRecvPacket| { &m.proof_height },
            |m: &mut MsgRecvPacket| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgRecvPacket| { &m.signer },
            |m: &mut MsgRecvPacket| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgRecvPacket>(
            "MsgRecvPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgRecvPacket {
    const NAME: &'static str = "MsgRecvPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.packet)?;
                },
                18 => {
                    self.proof_commitment = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                34 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.proof_commitment.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof_commitment);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packet.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.proof_commitment.is_empty() {
            os.write_bytes(2, &self.proof_commitment)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(4, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgRecvPacket {
        MsgRecvPacket::new()
    }

    fn clear(&mut self) {
        self.packet.clear();
        self.proof_commitment.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgRecvPacket {
        static instance: MsgRecvPacket = MsgRecvPacket {
            packet: ::protobuf::MessageField::none(),
            proof_commitment: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgRecvPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgRecvPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgRecvPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRecvPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgRecvPacketResponse defines the Msg/RecvPacket response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgRecvPacketResponse)
pub struct MsgRecvPacketResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgRecvPacketResponse.result)
    pub result: ::protobuf::EnumOrUnknown<ResponseResultType>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgRecvPacketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgRecvPacketResponse {
    fn default() -> &'a MsgRecvPacketResponse {
        <MsgRecvPacketResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgRecvPacketResponse {
    pub fn new() -> MsgRecvPacketResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &MsgRecvPacketResponse| { &m.result },
            |m: &mut MsgRecvPacketResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgRecvPacketResponse>(
            "MsgRecvPacketResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgRecvPacketResponse {
    const NAME: &'static str = "MsgRecvPacketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgRecvPacketResponse {
        MsgRecvPacketResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgRecvPacketResponse {
        static instance: MsgRecvPacketResponse = MsgRecvPacketResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgRecvPacketResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgRecvPacketResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgRecvPacketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRecvPacketResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgTimeout receives timed-out packet
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgTimeout)
pub struct MsgTimeout {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeout.packet)
    pub packet: ::protobuf::MessageField<super::channel::Packet>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeout.proof_unreceived)
    pub proof_unreceived: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeout.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeout.next_sequence_recv)
    pub next_sequence_recv: u64,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeout.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgTimeout.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgTimeout {
    fn default() -> &'a MsgTimeout {
        <MsgTimeout as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeout {
    pub fn new() -> MsgTimeout {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::channel::Packet>(
            "packet",
            |m: &MsgTimeout| { &m.packet },
            |m: &mut MsgTimeout| { &mut m.packet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_unreceived",
            |m: &MsgTimeout| { &m.proof_unreceived },
            |m: &mut MsgTimeout| { &mut m.proof_unreceived },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgTimeout| { &m.proof_height },
            |m: &mut MsgTimeout| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_sequence_recv",
            |m: &MsgTimeout| { &m.next_sequence_recv },
            |m: &mut MsgTimeout| { &mut m.next_sequence_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgTimeout| { &m.signer },
            |m: &mut MsgTimeout| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgTimeout>(
            "MsgTimeout",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgTimeout {
    const NAME: &'static str = "MsgTimeout";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.packet)?;
                },
                18 => {
                    self.proof_unreceived = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                32 => {
                    self.next_sequence_recv = is.read_uint64()?;
                },
                42 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.proof_unreceived.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof_unreceived);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.next_sequence_recv != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.next_sequence_recv);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packet.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.proof_unreceived.is_empty() {
            os.write_bytes(2, &self.proof_unreceived)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.next_sequence_recv != 0 {
            os.write_uint64(4, self.next_sequence_recv)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgTimeout {
        MsgTimeout::new()
    }

    fn clear(&mut self) {
        self.packet.clear();
        self.proof_unreceived.clear();
        self.proof_height.clear();
        self.next_sequence_recv = 0;
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgTimeout {
        static instance: MsgTimeout = MsgTimeout {
            packet: ::protobuf::MessageField::none(),
            proof_unreceived: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            next_sequence_recv: 0,
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgTimeout {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgTimeout").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgTimeout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeout {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgTimeoutResponse defines the Msg/Timeout response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgTimeoutResponse)
pub struct MsgTimeoutResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutResponse.result)
    pub result: ::protobuf::EnumOrUnknown<ResponseResultType>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgTimeoutResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgTimeoutResponse {
    fn default() -> &'a MsgTimeoutResponse {
        <MsgTimeoutResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeoutResponse {
    pub fn new() -> MsgTimeoutResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &MsgTimeoutResponse| { &m.result },
            |m: &mut MsgTimeoutResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgTimeoutResponse>(
            "MsgTimeoutResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgTimeoutResponse {
    const NAME: &'static str = "MsgTimeoutResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgTimeoutResponse {
        MsgTimeoutResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgTimeoutResponse {
        static instance: MsgTimeoutResponse = MsgTimeoutResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgTimeoutResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgTimeoutResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgTimeoutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeoutResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgTimeoutOnClose timed-out packet upon counterparty channel closure.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgTimeoutOnClose)
pub struct MsgTimeoutOnClose {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutOnClose.packet)
    pub packet: ::protobuf::MessageField<super::channel::Packet>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutOnClose.proof_unreceived)
    pub proof_unreceived: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutOnClose.proof_close)
    pub proof_close: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutOnClose.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutOnClose.next_sequence_recv)
    pub next_sequence_recv: u64,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutOnClose.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgTimeoutOnClose.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgTimeoutOnClose {
    fn default() -> &'a MsgTimeoutOnClose {
        <MsgTimeoutOnClose as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeoutOnClose {
    pub fn new() -> MsgTimeoutOnClose {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::channel::Packet>(
            "packet",
            |m: &MsgTimeoutOnClose| { &m.packet },
            |m: &mut MsgTimeoutOnClose| { &mut m.packet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_unreceived",
            |m: &MsgTimeoutOnClose| { &m.proof_unreceived },
            |m: &mut MsgTimeoutOnClose| { &mut m.proof_unreceived },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_close",
            |m: &MsgTimeoutOnClose| { &m.proof_close },
            |m: &mut MsgTimeoutOnClose| { &mut m.proof_close },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgTimeoutOnClose| { &m.proof_height },
            |m: &mut MsgTimeoutOnClose| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_sequence_recv",
            |m: &MsgTimeoutOnClose| { &m.next_sequence_recv },
            |m: &mut MsgTimeoutOnClose| { &mut m.next_sequence_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgTimeoutOnClose| { &m.signer },
            |m: &mut MsgTimeoutOnClose| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgTimeoutOnClose>(
            "MsgTimeoutOnClose",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgTimeoutOnClose {
    const NAME: &'static str = "MsgTimeoutOnClose";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.packet)?;
                },
                18 => {
                    self.proof_unreceived = is.read_bytes()?;
                },
                26 => {
                    self.proof_close = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                40 => {
                    self.next_sequence_recv = is.read_uint64()?;
                },
                50 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.proof_unreceived.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof_unreceived);
        }
        if !self.proof_close.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_close);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.next_sequence_recv != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.next_sequence_recv);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packet.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.proof_unreceived.is_empty() {
            os.write_bytes(2, &self.proof_unreceived)?;
        }
        if !self.proof_close.is_empty() {
            os.write_bytes(3, &self.proof_close)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.next_sequence_recv != 0 {
            os.write_uint64(5, self.next_sequence_recv)?;
        }
        if !self.signer.is_empty() {
            os.write_string(6, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgTimeoutOnClose {
        MsgTimeoutOnClose::new()
    }

    fn clear(&mut self) {
        self.packet.clear();
        self.proof_unreceived.clear();
        self.proof_close.clear();
        self.proof_height.clear();
        self.next_sequence_recv = 0;
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgTimeoutOnClose {
        static instance: MsgTimeoutOnClose = MsgTimeoutOnClose {
            packet: ::protobuf::MessageField::none(),
            proof_unreceived: ::std::vec::Vec::new(),
            proof_close: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            next_sequence_recv: 0,
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgTimeoutOnClose {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgTimeoutOnClose").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgTimeoutOnClose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeoutOnClose {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgTimeoutOnCloseResponse defines the Msg/TimeoutOnClose response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgTimeoutOnCloseResponse)
pub struct MsgTimeoutOnCloseResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgTimeoutOnCloseResponse.result)
    pub result: ::protobuf::EnumOrUnknown<ResponseResultType>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgTimeoutOnCloseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgTimeoutOnCloseResponse {
    fn default() -> &'a MsgTimeoutOnCloseResponse {
        <MsgTimeoutOnCloseResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeoutOnCloseResponse {
    pub fn new() -> MsgTimeoutOnCloseResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &MsgTimeoutOnCloseResponse| { &m.result },
            |m: &mut MsgTimeoutOnCloseResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgTimeoutOnCloseResponse>(
            "MsgTimeoutOnCloseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgTimeoutOnCloseResponse {
    const NAME: &'static str = "MsgTimeoutOnCloseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgTimeoutOnCloseResponse {
        MsgTimeoutOnCloseResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgTimeoutOnCloseResponse {
        static instance: MsgTimeoutOnCloseResponse = MsgTimeoutOnCloseResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgTimeoutOnCloseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgTimeoutOnCloseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgTimeoutOnCloseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeoutOnCloseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgAcknowledgement receives incoming IBC acknowledgement
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgAcknowledgement)
pub struct MsgAcknowledgement {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgAcknowledgement.packet)
    pub packet: ::protobuf::MessageField<super::channel::Packet>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgAcknowledgement.acknowledgement)
    pub acknowledgement: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgAcknowledgement.proof_acked)
    pub proof_acked: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgAcknowledgement.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgAcknowledgement.signer)
    pub signer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgAcknowledgement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgAcknowledgement {
    fn default() -> &'a MsgAcknowledgement {
        <MsgAcknowledgement as ::protobuf::Message>::default_instance()
    }
}

impl MsgAcknowledgement {
    pub fn new() -> MsgAcknowledgement {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::channel::Packet>(
            "packet",
            |m: &MsgAcknowledgement| { &m.packet },
            |m: &mut MsgAcknowledgement| { &mut m.packet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "acknowledgement",
            |m: &MsgAcknowledgement| { &m.acknowledgement },
            |m: &mut MsgAcknowledgement| { &mut m.acknowledgement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof_acked",
            |m: &MsgAcknowledgement| { &m.proof_acked },
            |m: &mut MsgAcknowledgement| { &mut m.proof_acked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &MsgAcknowledgement| { &m.proof_height },
            |m: &mut MsgAcknowledgement| { &mut m.proof_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &MsgAcknowledgement| { &m.signer },
            |m: &mut MsgAcknowledgement| { &mut m.signer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgAcknowledgement>(
            "MsgAcknowledgement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgAcknowledgement {
    const NAME: &'static str = "MsgAcknowledgement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.packet)?;
                },
                18 => {
                    self.acknowledgement = is.read_bytes()?;
                },
                26 => {
                    self.proof_acked = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                42 => {
                    self.signer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.acknowledgement.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.acknowledgement);
        }
        if !self.proof_acked.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_acked);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packet.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.acknowledgement.is_empty() {
            os.write_bytes(2, &self.acknowledgement)?;
        }
        if !self.proof_acked.is_empty() {
            os.write_bytes(3, &self.proof_acked)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgAcknowledgement {
        MsgAcknowledgement::new()
    }

    fn clear(&mut self) {
        self.packet.clear();
        self.acknowledgement.clear();
        self.proof_acked.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgAcknowledgement {
        static instance: MsgAcknowledgement = MsgAcknowledgement {
            packet: ::protobuf::MessageField::none(),
            acknowledgement: ::std::vec::Vec::new(),
            proof_acked: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            signer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgAcknowledgement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgAcknowledgement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgAcknowledgement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgAcknowledgement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgAcknowledgementResponse defines the Msg/Acknowledgement response type.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.MsgAcknowledgementResponse)
pub struct MsgAcknowledgementResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.MsgAcknowledgementResponse.result)
    pub result: ::protobuf::EnumOrUnknown<ResponseResultType>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.MsgAcknowledgementResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgAcknowledgementResponse {
    fn default() -> &'a MsgAcknowledgementResponse {
        <MsgAcknowledgementResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgAcknowledgementResponse {
    pub fn new() -> MsgAcknowledgementResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &MsgAcknowledgementResponse| { &m.result },
            |m: &mut MsgAcknowledgementResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgAcknowledgementResponse>(
            "MsgAcknowledgementResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgAcknowledgementResponse {
    const NAME: &'static str = "MsgAcknowledgementResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgAcknowledgementResponse {
        MsgAcknowledgementResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgAcknowledgementResponse {
        static instance: MsgAcknowledgementResponse = MsgAcknowledgementResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgAcknowledgementResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgAcknowledgementResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgAcknowledgementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgAcknowledgementResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ResponseResultType defines the possible outcomes of the execution of a message
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ibc.core.channel.v1.ResponseResultType)
pub enum ResponseResultType {
    // @@protoc_insertion_point(enum_value:ibc.core.channel.v1.ResponseResultType.RESPONSE_RESULT_UNSPECIFIED)
    RESPONSE_RESULT_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:ibc.core.channel.v1.ResponseResultType.RESPONSE_RESULT_NOOP)
    RESPONSE_RESULT_NOOP = 1,
    // @@protoc_insertion_point(enum_value:ibc.core.channel.v1.ResponseResultType.RESPONSE_RESULT_SUCCESS)
    RESPONSE_RESULT_SUCCESS = 2,
}

impl ::protobuf::Enum for ResponseResultType {
    const NAME: &'static str = "ResponseResultType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseResultType> {
        match value {
            0 => ::std::option::Option::Some(ResponseResultType::RESPONSE_RESULT_UNSPECIFIED),
            1 => ::std::option::Option::Some(ResponseResultType::RESPONSE_RESULT_NOOP),
            2 => ::std::option::Option::Some(ResponseResultType::RESPONSE_RESULT_SUCCESS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ResponseResultType] = &[
        ResponseResultType::RESPONSE_RESULT_UNSPECIFIED,
        ResponseResultType::RESPONSE_RESULT_NOOP,
        ResponseResultType::RESPONSE_RESULT_SUCCESS,
    ];
}

impl ::protobuf::EnumFull for ResponseResultType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ResponseResultType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ResponseResultType {
    fn default() -> Self {
        ResponseResultType::RESPONSE_RESULT_UNSPECIFIED
    }
}

impl ResponseResultType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ResponseResultType>("ResponseResultType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cibc/core/channel/v1/tx.proto\x12\x13ibc.core.channel.v1\x1a\x14gog\
    oproto/gogo.proto\x1a\x1fibc/core/client/v1/client.proto\x1a!ibc/core/ch\
    annel/v1/channel.proto\"\xa1\x01\n\x12MsgChannelOpenInit\x12+\n\x07port_\
    id\x18\x01\x20\x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\"\
    \x12<\n\x07channel\x18\x02\x20\x01(\x0b2\x1c.ibc.core.channel.v1.Channel\
    R\x07channelB\x04\xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x03\x20\x01(\tR\
    \x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"R\n\x1aMsgChannelOpenInitRe\
    sponse\x124\n\nchannel_id\x18\x01\x20\x01(\tR\tchannelIdB\x15\xf2\xde\
    \x1f\x11yaml:\"channel_id\"\"\xd6\x03\n\x11MsgChannelOpenTry\x12+\n\x07p\
    ort_id\x18\x01\x20\x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\
    \"\x12N\n\x13previous_channel_id\x18\x02\x20\x01(\tR\x11previousChannelI\
    dB\x1e\xf2\xde\x1f\x1ayaml:\"previous_channel_id\"\x12<\n\x07channel\x18\
    \x03\x20\x01(\x0b2\x1c.ibc.core.channel.v1.ChannelR\x07channelB\x04\xc8\
    \xde\x1f\0\x12R\n\x14counterparty_version\x18\x04\x20\x01(\tR\x13counter\
    partyVersionB\x1f\xf2\xde\x1f\x1byaml:\"counterparty_version\"\x124\n\np\
    roof_init\x18\x05\x20\x01(\x0cR\tproofInitB\x15\xf2\xde\x1f\x11yaml:\"pr\
    oof_init\"\x12Z\n\x0cproof_height\x18\x06\x20\x01(\x0b2\x1a.ibc.core.cli\
    ent.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\
    \xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x07\x20\x01(\tR\x06signer:\x08\
    \x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x1b\n\x19MsgChannelOpenTryResponse\"\xd7\
    \x03\n\x11MsgChannelOpenAck\x12+\n\x07port_id\x18\x01\x20\x01(\tR\x06por\
    tIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\"\x124\n\nchannel_id\x18\x02\x20\
    \x01(\tR\tchannelIdB\x15\xf2\xde\x1f\x11yaml:\"channel_id\"\x12Z\n\x17co\
    unterparty_channel_id\x18\x03\x20\x01(\tR\x15counterpartyChannelIdB\"\
    \xf2\xde\x1f\x1eyaml:\"counterparty_channel_id\"\x12R\n\x14counterparty_\
    version\x18\x04\x20\x01(\tR\x13counterpartyVersionB\x1f\xf2\xde\x1f\x1by\
    aml:\"counterparty_version\"\x121\n\tproof_try\x18\x05\x20\x01(\x0cR\x08\
    proofTryB\x14\xf2\xde\x1f\x10yaml:\"proof_try\"\x12Z\n\x0cproof_height\
    \x18\x06\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\
    \x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\x1f\0\x12\x16\n\x06sig\
    ner\x18\x07\x20\x01(\tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x1b\
    \n\x19MsgChannelOpenAckResponse\"\xab\x02\n\x15MsgChannelOpenConfirm\x12\
    +\n\x07port_id\x18\x01\x20\x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"\
    port_id\"\x124\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelIdB\x15\xf2\xde\
    \x1f\x11yaml:\"channel_id\"\x121\n\tproof_ack\x18\x03\x20\x01(\x0cR\x08p\
    roofAckB\x14\xf2\xde\x1f\x10yaml:\"proof_ack\"\x12Z\n\x0cproof_height\
    \x18\x04\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\
    \x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\x1f\0\x12\x16\n\x06sig\
    ner\x18\x05\x20\x01(\tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x1f\
    \n\x1dMsgChannelOpenConfirmResponse\"\x9a\x01\n\x13MsgChannelCloseInit\
    \x12+\n\x07port_id\x18\x01\x20\x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyam\
    l:\"port_id\"\x124\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelIdB\x15\xf2\
    \xde\x1f\x11yaml:\"channel_id\"\x12\x16\n\x06signer\x18\x03\x20\x01(\tR\
    \x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x1d\n\x1bMsgChannelCloseIn\
    itResponse\"\xaf\x02\n\x16MsgChannelCloseConfirm\x12+\n\x07port_id\x18\
    \x01\x20\x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\"\x124\n\n\
    channel_id\x18\x02\x20\x01(\tR\tchannelIdB\x15\xf2\xde\x1f\x11yaml:\"cha\
    nnel_id\"\x124\n\nproof_init\x18\x03\x20\x01(\x0cR\tproofInitB\x15\xf2\
    \xde\x1f\x11yaml:\"proof_init\"\x12Z\n\x0cproof_height\x18\x04\x20\x01(\
    \x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13\
    yaml:\"proof_height\"\xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x05\x20\x01(\
    \tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x20\n\x1eMsgChannelClos\
    eConfirmResponse\"\x90\x02\n\rMsgRecvPacket\x129\n\x06packet\x18\x01\x20\
    \x01(\x0b2\x1b.ibc.core.channel.v1.PacketR\x06packetB\x04\xc8\xde\x1f\0\
    \x12F\n\x10proof_commitment\x18\x02\x20\x01(\x0cR\x0fproofCommitmentB\
    \x1b\xf2\xde\x1f\x17yaml:\"proof_commitment\"\x12Z\n\x0cproof_height\x18\
    \x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\x1b\
    \xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\x1f\0\x12\x16\n\x06signer\
    \x18\x04\x20\x01(\tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"^\n\x15\
    MsgRecvPacketResponse\x12?\n\x06result\x18\x01\x20\x01(\x0e2'.ibc.core.c\
    hannel.v1.ResponseResultTypeR\x06result:\x04\x88\xa0\x1f\0\"\xda\x02\n\n\
    MsgTimeout\x129\n\x06packet\x18\x01\x20\x01(\x0b2\x1b.ibc.core.channel.v\
    1.PacketR\x06packetB\x04\xc8\xde\x1f\0\x12F\n\x10proof_unreceived\x18\
    \x02\x20\x01(\x0cR\x0fproofUnreceivedB\x1b\xf2\xde\x1f\x17yaml:\"proof_u\
    nreceived\"\x12Z\n\x0cproof_height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.cl\
    ient.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\
    \xc8\xde\x1f\0\x12K\n\x12next_sequence_recv\x18\x04\x20\x01(\x04R\x10nex\
    tSequenceRecvB\x1d\xf2\xde\x1f\x19yaml:\"next_sequence_recv\"\x12\x16\n\
    \x06signer\x18\x05\x20\x01(\tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\
    \0\"[\n\x12MsgTimeoutResponse\x12?\n\x06result\x18\x01\x20\x01(\x0e2'.ib\
    c.core.channel.v1.ResponseResultTypeR\x06result:\x04\x88\xa0\x1f\0\"\x9a\
    \x03\n\x11MsgTimeoutOnClose\x129\n\x06packet\x18\x01\x20\x01(\x0b2\x1b.i\
    bc.core.channel.v1.PacketR\x06packetB\x04\xc8\xde\x1f\0\x12F\n\x10proof_\
    unreceived\x18\x02\x20\x01(\x0cR\x0fproofUnreceivedB\x1b\xf2\xde\x1f\x17\
    yaml:\"proof_unreceived\"\x127\n\x0bproof_close\x18\x03\x20\x01(\x0cR\np\
    roofCloseB\x16\xf2\xde\x1f\x12yaml:\"proof_close\"\x12Z\n\x0cproof_heigh\
    t\x18\x04\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\
    \x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\x1f\0\x12K\n\x12next_s\
    equence_recv\x18\x05\x20\x01(\x04R\x10nextSequenceRecvB\x1d\xf2\xde\x1f\
    \x19yaml:\"next_sequence_recv\"\x12\x16\n\x06signer\x18\x06\x20\x01(\tR\
    \x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"b\n\x19MsgTimeoutOnCloseRes\
    ponse\x12?\n\x06result\x18\x01\x20\x01(\x0e2'.ibc.core.channel.v1.Respon\
    seResultTypeR\x06result:\x04\x88\xa0\x1f\0\"\xb0\x02\n\x12MsgAcknowledge\
    ment\x129\n\x06packet\x18\x01\x20\x01(\x0b2\x1b.ibc.core.channel.v1.Pack\
    etR\x06packetB\x04\xc8\xde\x1f\0\x12(\n\x0facknowledgement\x18\x02\x20\
    \x01(\x0cR\x0facknowledgement\x127\n\x0bproof_acked\x18\x03\x20\x01(\x0c\
    R\nproofAckedB\x16\xf2\xde\x1f\x12yaml:\"proof_acked\"\x12Z\n\x0cproof_h\
    eight\x18\x04\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeigh\
    tB\x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\x1f\0\x12\x16\n\x06s\
    igner\x18\x05\x20\x01(\tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"c\
    \n\x1aMsgAcknowledgementResponse\x12?\n\x06result\x18\x01\x20\x01(\x0e2'\
    .ibc.core.channel.v1.ResponseResultTypeR\x06result:\x04\x88\xa0\x1f\0*\
    \x9a\x01\n\x12ResponseResultType\x120\n\x1bRESPONSE_RESULT_UNSPECIFIED\
    \x10\0\x1a\x0f\x8a\x9d\x20\x0bUNSPECIFIED\x12\"\n\x14RESPONSE_RESULT_NOO\
    P\x10\x01\x1a\x08\x8a\x9d\x20\x04NOOP\x12(\n\x17RESPONSE_RESULT_SUCCESS\
    \x10\x02\x1a\x0b\x8a\x9d\x20\x07SUCCESS\x1a\x04\x88\xa3\x1e\02\xaf\x08\n\
    \x03Msg\x12k\n\x0fChannelOpenInit\x12'.ibc.core.channel.v1.MsgChannelOpe\
    nInit\x1a/.ibc.core.channel.v1.MsgChannelOpenInitResponse\x12h\n\x0eChan\
    nelOpenTry\x12&.ibc.core.channel.v1.MsgChannelOpenTry\x1a..ibc.core.chan\
    nel.v1.MsgChannelOpenTryResponse\x12h\n\x0eChannelOpenAck\x12&.ibc.core.\
    channel.v1.MsgChannelOpenAck\x1a..ibc.core.channel.v1.MsgChannelOpenAckR\
    esponse\x12t\n\x12ChannelOpenConfirm\x12*.ibc.core.channel.v1.MsgChannel\
    OpenConfirm\x1a2.ibc.core.channel.v1.MsgChannelOpenConfirmResponse\x12n\
    \n\x10ChannelCloseInit\x12(.ibc.core.channel.v1.MsgChannelCloseInit\x1a0\
    .ibc.core.channel.v1.MsgChannelCloseInitResponse\x12w\n\x13ChannelCloseC\
    onfirm\x12+.ibc.core.channel.v1.MsgChannelCloseConfirm\x1a3.ibc.core.cha\
    nnel.v1.MsgChannelCloseConfirmResponse\x12\\\n\nRecvPacket\x12\".ibc.cor\
    e.channel.v1.MsgRecvPacket\x1a*.ibc.core.channel.v1.MsgRecvPacketRespons\
    e\x12S\n\x07Timeout\x12\x1f.ibc.core.channel.v1.MsgTimeout\x1a'.ibc.core\
    .channel.v1.MsgTimeoutResponse\x12h\n\x0eTimeoutOnClose\x12&.ibc.core.ch\
    annel.v1.MsgTimeoutOnClose\x1a..ibc.core.channel.v1.MsgTimeoutOnCloseRes\
    ponse\x12k\n\x0fAcknowledgement\x12'.ibc.core.channel.v1.MsgAcknowledgem\
    ent\x1a/.ibc.core.channel.v1.MsgAcknowledgementResponseB;Z9github.com/co\
    smos/ibc-go/v3/modules/core/04-channel/typesJ\xa7L\n\x07\x12\x05\0\0\xf2\
    \x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\
    \x1c\n\x08\n\x01\x08\x12\x03\x04\0P\n\t\n\x02\x08\x0b\x12\x03\x04\0P\n\t\
    \n\x02\x03\0\x12\x03\x06\0\x1e\n\t\n\x02\x03\x01\x12\x03\x07\0)\n\t\n\
    \x02\x03\x02\x12\x03\x08\0+\n6\n\x02\x06\0\x12\x04\x0b\0*\x01\x1a*\x20Ms\
    g\x20defines\x20the\x20ibc/channel\x20Msg\x20service.\n\n\n\n\x03\x06\0\
    \x01\x12\x03\x0b\x08\x0b\nS\n\x04\x06\0\x02\0\x12\x03\r\x02O\x1aF\x20Cha\
    nnelOpenInit\x20defines\x20a\x20rpc\x20handler\x20method\x20for\x20MsgCh\
    annelOpenInit.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\r\x06\x15\n\x0c\n\
    \x05\x06\0\x02\0\x02\x12\x03\r\x16(\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\
    \r3M\nQ\n\x04\x06\0\x02\x01\x12\x03\x10\x02L\x1aD\x20ChannelOpenTry\x20d\
    efines\x20a\x20rpc\x20handler\x20method\x20for\x20MsgChannelOpenTry.\n\n\
    \x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x10\x06\x14\n\x0c\n\x05\x06\0\x02\
    \x01\x02\x12\x03\x10\x15&\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x101J\nQ\
    \n\x04\x06\0\x02\x02\x12\x03\x13\x02L\x1aD\x20ChannelOpenAck\x20defines\
    \x20a\x20rpc\x20handler\x20method\x20for\x20MsgChannelOpenAck.\n\n\x0c\n\
    \x05\x06\0\x02\x02\x01\x12\x03\x13\x06\x14\n\x0c\n\x05\x06\0\x02\x02\x02\
    \x12\x03\x13\x15&\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x131J\nY\n\x04\
    \x06\0\x02\x03\x12\x03\x16\x02X\x1aL\x20ChannelOpenConfirm\x20defines\
    \x20a\x20rpc\x20handler\x20method\x20for\x20MsgChannelOpenConfirm.\n\n\
    \x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x16\x06\x18\n\x0c\n\x05\x06\0\x02\
    \x03\x02\x12\x03\x16\x19.\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x169V\nU\
    \n\x04\x06\0\x02\x04\x12\x03\x19\x02R\x1aH\x20ChannelCloseInit\x20define\
    s\x20a\x20rpc\x20handler\x20method\x20for\x20MsgChannelCloseInit.\n\n\
    \x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x19\x06\x16\n\x0c\n\x05\x06\0\x02\
    \x04\x02\x12\x03\x19\x17*\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03\x195P\n\
    \\\n\x04\x06\0\x02\x05\x12\x03\x1d\x02[\x1aO\x20ChannelCloseConfirm\x20d\
    efines\x20a\x20rpc\x20handler\x20method\x20for\n\x20MsgChannelCloseConfi\
    rm.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x1d\x06\x19\n\x0c\n\x05\x06\
    \0\x02\x05\x02\x12\x03\x1d\x1a0\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03\
    \x1d;Y\nI\n\x04\x06\0\x02\x06\x12\x03\x20\x02@\x1a<\x20RecvPacket\x20def\
    ines\x20a\x20rpc\x20handler\x20method\x20for\x20MsgRecvPacket.\n\n\x0c\n\
    \x05\x06\0\x02\x06\x01\x12\x03\x20\x06\x10\n\x0c\n\x05\x06\0\x02\x06\x02\
    \x12\x03\x20\x11\x1e\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x20)>\nC\n\
    \x04\x06\0\x02\x07\x12\x03#\x027\x1a6\x20Timeout\x20defines\x20a\x20rpc\
    \x20handler\x20method\x20for\x20MsgTimeout.\n\n\x0c\n\x05\x06\0\x02\x07\
    \x01\x12\x03#\x06\r\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03#\x0e\x18\n\x0c\
    \n\x05\x06\0\x02\x07\x03\x12\x03##5\nQ\n\x04\x06\0\x02\x08\x12\x03&\x02L\
    \x1aD\x20TimeoutOnClose\x20defines\x20a\x20rpc\x20handler\x20method\x20f\
    or\x20MsgTimeoutOnClose.\n\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03&\x06\
    \x14\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03&\x15&\n\x0c\n\x05\x06\0\x02\
    \x08\x03\x12\x03&1J\nS\n\x04\x06\0\x02\t\x12\x03)\x02O\x1aF\x20Acknowled\
    gement\x20defines\x20a\x20rpc\x20handler\x20method\x20for\x20MsgAcknowle\
    dgement.\n\n\x0c\n\x05\x06\0\x02\t\x01\x12\x03)\x06\x15\n\x0c\n\x05\x06\
    \0\x02\t\x02\x12\x03)\x16(\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03)3M\n\\\n\
    \x02\x05\0\x12\x04-\06\x01\x1aP\x20ResponseResultType\x20defines\x20the\
    \x20possible\x20outcomes\x20of\x20the\x20execution\x20of\x20a\x20message\
    \n\n\n\n\x03\x05\0\x01\x12\x03-\x05\x17\n\n\n\x03\x05\0\x03\x12\x03.\x02\
    1\n\r\n\x06\x05\0\x03\xb1\xe4\x03\x12\x03.\x021\n-\n\x04\x05\0\x02\0\x12\
    \x031\x02U\x1a\x20\x20Default\x20zero\x20value\x20enumeration\n\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x031\x02\x1d\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x031\x20!\n\x0c\n\x05\x05\0\x02\0\x03\x12\x031\"T\n\x0f\n\x08\x05\0\x02\
    \0\x03\xd1\x83\x04\x12\x031#S\n\x81\x01\n\x04\x05\0\x02\x01\x12\x033\x02\
    G\x1at\x20The\x20message\x20did\x20not\x20call\x20the\x20IBC\x20applicat\
    ion\x20callbacks\x20(because,\x20for\x20example,\x20the\x20packet\x20had\
    \x20already\x20been\x20relayed)\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x033\
    \x02\x16\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x033\x19\x1a\n\x0c\n\x05\x05\
    \0\x02\x01\x03\x12\x033\x1bF\n\x0f\n\x08\x05\0\x02\x01\x03\xd1\x83\x04\
    \x12\x033\x1cE\n4\n\x04\x05\0\x02\x02\x12\x035\x02M\x1a'\x20The\x20messa\
    ge\x20was\x20executed\x20successfully\n\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x035\x02\x19\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x035\x1c\x1d\n\x0c\n\
    \x05\x05\0\x02\x02\x03\x12\x035\x1eL\n\x0f\n\x08\x05\0\x02\x02\x03\xd1\
    \x83\x04\x12\x035\x1fK\n}\n\x02\x04\0\x12\x04:\0A\x01\x1aq\x20MsgChannel\
    OpenInit\x20defines\x20an\x20sdk.Msg\x20to\x20initialize\x20a\x20channel\
    \x20handshake.\x20It\n\x20is\x20called\x20by\x20a\x20relayer\x20on\x20Ch\
    ain\x20A.\n\n\n\n\x03\x04\0\x01\x12\x03:\x08\x1a\n\n\n\x03\x04\0\x07\x12\
    \x03;\x02-\n\r\n\x06\x04\0\x07\x8d\xf4\x03\x12\x03;\x02-\n\n\n\x03\x04\0\
    \x07\x12\x03<\x02-\n\r\n\x06\x04\0\x07\x81\xf4\x03\x12\x03<\x02-\n\x0b\n\
    \x04\x04\0\x02\0\x12\x03>\x02B\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03>\x02\
    \x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03>\n\x11\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03>\x14\x15\n\x0c\n\x05\x04\0\x02\0\x08\x12\x03>\x16A\n\x0f\n\
    \x08\x04\0\x02\0\x08\xee\xfb\x03\x12\x03>\x17@\n\x0b\n\x04\x04\0\x02\x01\
    \x12\x03?\x025\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03?\x02\t\n\x0c\n\x05\
    \x04\0\x02\x01\x01\x12\x03?\n\x11\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03?\
    \x14\x15\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03?\x164\n\x0f\n\x08\x04\0\
    \x02\x01\x08\xe9\xfb\x03\x12\x03?\x173\n\x0b\n\x04\x04\0\x02\x02\x12\x03\
    @\x02\x16\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03@\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x02\x01\x12\x03@\n\x10\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03@\x14\
    \x15\nW\n\x02\x04\x01\x12\x04D\0F\x01\x1aK\x20MsgChannelOpenInitResponse\
    \x20defines\x20the\x20Msg/ChannelOpenInit\x20response\x20type.\n\n\n\n\
    \x03\x04\x01\x01\x12\x03D\x08\"\n\x0b\n\x04\x04\x01\x02\0\x12\x03E\x02G\
    \n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03E\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03E\t\x13\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03E\x16\x17\n\
    \x0c\n\x05\x04\x01\x02\0\x08\x12\x03E\x18F\n\x0f\n\x08\x04\x01\x02\0\x08\
    \xee\xfb\x03\x12\x03E\x19E\n\xcf\x01\n\x02\x04\x02\x12\x04K\0Z\x01\x1a\
    \xc2\x01\x20MsgChannelOpenInit\x20defines\x20a\x20msg\x20sent\x20by\x20a\
    \x20Relayer\x20to\x20try\x20to\x20open\x20a\x20channel\n\x20on\x20Chain\
    \x20B.\x20The\x20version\x20field\x20within\x20the\x20Channel\x20field\
    \x20has\x20been\x20deprecated.\x20Its\n\x20value\x20will\x20be\x20ignore\
    d\x20by\x20core\x20IBC.\n\n\n\n\x03\x04\x02\x01\x12\x03K\x08\x19\n\n\n\
    \x03\x04\x02\x07\x12\x03L\x02-\n\r\n\x06\x04\x02\x07\x8d\xf4\x03\x12\x03\
    L\x02-\n\n\n\x03\x04\x02\x07\x12\x03M\x02-\n\r\n\x06\x04\x02\x07\x81\xf4\
    \x03\x12\x03M\x02-\n\x0b\n\x04\x04\x02\x02\0\x12\x03O\x02A\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03O\t\x10\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03O\x13\x14\n\x0c\n\x05\
    \x04\x02\x02\0\x08\x12\x03O\x15@\n\x0f\n\x08\x04\x02\x02\0\x08\xee\xfb\
    \x03\x12\x03O\x16?\n\x96\x01\n\x04\x04\x02\x02\x01\x12\x03R\x02Y\x1a\x88\
    \x01\x20in\x20the\x20case\x20of\x20crossing\x20hello's,\x20when\x20both\
    \x20chains\x20call\x20OpenInit,\x20we\x20need\n\x20the\x20channel\x20ide\
    ntifier\x20of\x20the\x20previous\x20channel\x20in\x20state\x20INIT\n\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03R\x02\x08\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03R\t\x1c\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03R\x1f\x20\
    \n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x03R!X\n\x0f\n\x08\x04\x02\x02\x01\
    \x08\xee\xfb\x03\x12\x03R\"W\nu\n\x04\x04\x02\x02\x02\x12\x03T\x02T\x1ah\
    \x20NOTE:\x20the\x20version\x20field\x20within\x20the\x20channel\x20has\
    \x20been\x20deprecated.\x20Its\x20value\x20will\x20be\x20ignored\x20by\
    \x20core\x20IBC.\n\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03T\x02\t\n\x0c\
    \n\x05\x04\x02\x02\x02\x01\x12\x03T\x1c#\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03T34\n\x0c\n\x05\x04\x02\x02\x02\x08\x12\x03T5S\n\x0f\n\x08\x04\
    \x02\x02\x02\x08\xe9\xfb\x03\x12\x03T6R\n\x0b\n\x04\x04\x02\x02\x03\x12\
    \x03U\x02n\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03U\x02\x08\n\x0c\n\x05\
    \x04\x02\x02\x03\x01\x12\x03U\x1c0\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\
    \x03U34\n\x0c\n\x05\x04\x02\x02\x03\x08\x12\x03U5m\n\x0f\n\x08\x04\x02\
    \x02\x03\x08\xee\xfb\x03\x12\x03U6l\n\x0b\n\x04\x04\x02\x02\x04\x12\x03V\
    \x02d\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03V\x02\x07\n\x0c\n\x05\x04\
    \x02\x02\x04\x01\x12\x03V\x1c&\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03V3\
    4\n\x0c\n\x05\x04\x02\x02\x04\x08\x12\x03V5c\n\x0f\n\x08\x04\x02\x02\x04\
    \x08\xee\xfb\x03\x12\x03V6b\n\x0c\n\x04\x04\x02\x02\x05\x12\x04W\x02XU\n\
    \x0c\n\x05\x04\x02\x02\x05\x06\x12\x03W\x02\x1b\n\x0c\n\x05\x04\x02\x02\
    \x05\x01\x12\x03W\x1c(\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03W34\n\x0c\
    \n\x05\x04\x02\x02\x05\x08\x12\x03X\x06T\n\x0f\n\x08\x04\x02\x02\x05\x08\
    \xee\xfb\x03\x12\x03X\x075\n\x0f\n\x08\x04\x02\x02\x05\x08\xe9\xfb\x03\
    \x12\x03X7S\n\x0b\n\x04\x04\x02\x02\x06\x12\x03Y\x02\x14\n\x0c\n\x05\x04\
    \x02\x02\x06\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\
    \x03Y\t\x0f\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03Y\x12\x13\nT\n\x02\
    \x04\x03\x12\x03]\0$\x1aI\x20MsgChannelOpenTryResponse\x20defines\x20the\
    \x20Msg/ChannelOpenTry\x20response\x20type.\n\n\n\n\x03\x04\x03\x01\x12\
    \x03]\x08!\n\x8e\x01\n\x02\x04\x04\x12\x04a\0m\x01\x1a\x81\x01\x20MsgCha\
    nnelOpenAck\x20defines\x20a\x20msg\x20sent\x20by\x20a\x20Relayer\x20to\
    \x20Chain\x20A\x20to\x20acknowledge\n\x20the\x20change\x20of\x20channel\
    \x20state\x20to\x20TRYOPEN\x20on\x20Chain\x20B.\n\n\n\n\x03\x04\x04\x01\
    \x12\x03a\x08\x19\n\n\n\x03\x04\x04\x07\x12\x03b\x02-\n\r\n\x06\x04\x04\
    \x07\x8d\xf4\x03\x12\x03b\x02-\n\n\n\x03\x04\x04\x07\x12\x03c\x02-\n\r\n\
    \x06\x04\x04\x07\x81\xf4\x03\x12\x03c\x02-\n\x0b\n\x04\x04\x04\x02\0\x12\
    \x03e\x02d\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03e\x02\x08\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03e\x1c#\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03e6\
    7\n\x0c\n\x05\x04\x04\x02\0\x08\x12\x03e8c\n\x0f\n\x08\x04\x04\x02\0\x08\
    \xee\xfb\x03\x12\x03e9b\n\x0b\n\x04\x04\x04\x02\x01\x12\x03f\x02g\n\x0c\
    \n\x05\x04\x04\x02\x01\x05\x12\x03f\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x03f\x1c&\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03f67\n\x0c\n\
    \x05\x04\x04\x02\x01\x08\x12\x03f8f\n\x0f\n\x08\x04\x04\x02\x01\x08\xee\
    \xfb\x03\x12\x03f9e\n\x0b\n\x04\x04\x04\x02\x02\x12\x03g\x02t\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03g\x02\x08\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03g\x1c3\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03g67\n\x0c\n\
    \x05\x04\x04\x02\x02\x08\x12\x03g8s\n\x0f\n\x08\x04\x04\x02\x02\x08\xee\
    \xfb\x03\x12\x03g9r\n\x0b\n\x04\x04\x04\x02\x03\x12\x03h\x02q\n\x0c\n\
    \x05\x04\x04\x02\x03\x05\x12\x03h\x02\x08\n\x0c\n\x05\x04\x04\x02\x03\
    \x01\x12\x03h\x1c0\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03h67\n\x0c\n\
    \x05\x04\x04\x02\x03\x08\x12\x03h8p\n\x0f\n\x08\x04\x04\x02\x03\x08\xee\
    \xfb\x03\x12\x03h9o\n\x0b\n\x04\x04\x04\x02\x04\x12\x03i\x02f\n\x0c\n\
    \x05\x04\x04\x02\x04\x05\x12\x03i\x02\x07\n\x0c\n\x05\x04\x04\x02\x04\
    \x01\x12\x03i\x1c%\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03i67\n\x0c\n\
    \x05\x04\x04\x02\x04\x08\x12\x03i8e\n\x0f\n\x08\x04\x04\x02\x04\x08\xee\
    \xfb\x03\x12\x03i9d\n\x0c\n\x04\x04\x04\x02\x05\x12\x04j\x02kU\n\x0c\n\
    \x05\x04\x04\x02\x05\x06\x12\x03j\x02\x1b\n\x0c\n\x05\x04\x04\x02\x05\
    \x01\x12\x03j\x1c(\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03j67\n\x0c\n\
    \x05\x04\x04\x02\x05\x08\x12\x03k\x06T\n\x0f\n\x08\x04\x04\x02\x05\x08\
    \xee\xfb\x03\x12\x03k\x075\n\x0f\n\x08\x04\x04\x02\x05\x08\xe9\xfb\x03\
    \x12\x03k7S\n\x0b\n\x04\x04\x04\x02\x06\x12\x03l\x02\x14\n\x0c\n\x05\x04\
    \x04\x02\x06\x05\x12\x03l\x02\x08\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\
    \x03l\t\x0f\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03l\x12\x13\nT\n\x02\
    \x04\x05\x12\x03p\0$\x1aI\x20MsgChannelOpenAckResponse\x20defines\x20the\
    \x20Msg/ChannelOpenAck\x20response\x20type.\n\n\n\n\x03\x04\x05\x01\x12\
    \x03p\x08!\n\x8f\x01\n\x02\x04\x06\x12\x04t\0~\x01\x1a\x82\x01\x20MsgCha\
    nnelOpenConfirm\x20defines\x20a\x20msg\x20sent\x20by\x20a\x20Relayer\x20\
    to\x20Chain\x20B\x20to\n\x20acknowledge\x20the\x20change\x20of\x20channe\
    l\x20state\x20to\x20OPEN\x20on\x20Chain\x20A.\n\n\n\n\x03\x04\x06\x01\
    \x12\x03t\x08\x1d\n\n\n\x03\x04\x06\x07\x12\x03u\x02-\n\r\n\x06\x04\x06\
    \x07\x8d\xf4\x03\x12\x03u\x02-\n\n\n\x03\x04\x06\x07\x12\x03v\x02-\n\r\n\
    \x06\x04\x06\x07\x81\xf4\x03\x12\x03v\x02-\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03x\x02Y\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03x\x02\x08\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03x\x1c#\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03x+\
    ,\n\x0c\n\x05\x04\x06\x02\0\x08\x12\x03x-X\n\x0f\n\x08\x04\x06\x02\0\x08\
    \xee\xfb\x03\x12\x03x.W\n\x0b\n\x04\x04\x06\x02\x01\x12\x03y\x02\\\n\x0c\
    \n\x05\x04\x06\x02\x01\x05\x12\x03y\x02\x08\n\x0c\n\x05\x04\x06\x02\x01\
    \x01\x12\x03y\x1c&\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03y+,\n\x0c\n\
    \x05\x04\x06\x02\x01\x08\x12\x03y-[\n\x0f\n\x08\x04\x06\x02\x01\x08\xee\
    \xfb\x03\x12\x03y.Z\n\x0b\n\x04\x04\x06\x02\x02\x12\x03z\x02[\n\x0c\n\
    \x05\x04\x06\x02\x02\x05\x12\x03z\x02\x07\n\x0c\n\x05\x04\x06\x02\x02\
    \x01\x12\x03z\x1c%\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03z+,\n\x0c\n\
    \x05\x04\x06\x02\x02\x08\x12\x03z-Z\n\x0f\n\x08\x04\x06\x02\x02\x08\xee\
    \xfb\x03\x12\x03z.Y\n\x0c\n\x04\x04\x06\x02\x03\x12\x04{\x02|U\n\x0c\n\
    \x05\x04\x06\x02\x03\x06\x12\x03{\x02\x1b\n\x0c\n\x05\x04\x06\x02\x03\
    \x01\x12\x03{\x1c(\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03{+,\n\x0c\n\
    \x05\x04\x06\x02\x03\x08\x12\x03|\x06T\n\x0f\n\x08\x04\x06\x02\x03\x08\
    \xee\xfb\x03\x12\x03|\x075\n\x0f\n\x08\x04\x06\x02\x03\x08\xe9\xfb\x03\
    \x12\x03|7S\n\x0b\n\x04\x04\x06\x02\x04\x12\x03}\x02\x14\n\x0c\n\x05\x04\
    \x06\x02\x04\x05\x12\x03}\x02\x08\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\
    \x03}\t\x0f\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03}\x12\x13\n^\n\x02\
    \x04\x07\x12\x04\x82\x01\0(\x1aR\x20MsgChannelOpenConfirmResponse\x20def\
    ines\x20the\x20Msg/ChannelOpenConfirm\x20response\n\x20type.\n\n\x0b\n\
    \x03\x04\x07\x01\x12\x04\x82\x01\x08%\np\n\x02\x04\x08\x12\x06\x86\x01\0\
    \x8d\x01\x01\x1ab\x20MsgChannelCloseInit\x20defines\x20a\x20msg\x20sent\
    \x20by\x20a\x20Relayer\x20to\x20Chain\x20A\n\x20to\x20close\x20a\x20chan\
    nel\x20with\x20Chain\x20B.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x86\x01\x08\
    \x1b\n\x0b\n\x03\x04\x08\x07\x12\x04\x87\x01\x02-\n\x0e\n\x06\x04\x08\
    \x07\x8d\xf4\x03\x12\x04\x87\x01\x02-\n\x0b\n\x03\x04\x08\x07\x12\x04\
    \x88\x01\x02-\n\x0e\n\x06\x04\x08\x07\x81\xf4\x03\x12\x04\x88\x01\x02-\n\
    \x0c\n\x04\x04\x08\x02\0\x12\x04\x8a\x01\x02D\n\r\n\x05\x04\x08\x02\0\
    \x05\x12\x04\x8a\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x8a\x01\
    \t\x10\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x8a\x01\x16\x17\n\r\n\x05\x04\
    \x08\x02\0\x08\x12\x04\x8a\x01\x18C\n\x10\n\x08\x04\x08\x02\0\x08\xee\
    \xfb\x03\x12\x04\x8a\x01\x19B\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x8b\
    \x01\x02G\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x8b\x01\x02\x08\n\r\n\
    \x05\x04\x08\x02\x01\x01\x12\x04\x8b\x01\t\x13\n\r\n\x05\x04\x08\x02\x01\
    \x03\x12\x04\x8b\x01\x16\x17\n\r\n\x05\x04\x08\x02\x01\x08\x12\x04\x8b\
    \x01\x18F\n\x10\n\x08\x04\x08\x02\x01\x08\xee\xfb\x03\x12\x04\x8b\x01\
    \x19E\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\x8c\x01\x02\x18\n\r\n\x05\x04\
    \x08\x02\x02\x05\x12\x04\x8c\x01\x02\x08\n\r\n\x05\x04\x08\x02\x02\x01\
    \x12\x04\x8c\x01\t\x0f\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x8c\x01\x16\
    \x17\nY\n\x02\x04\t\x12\x04\x90\x01\0&\x1aM\x20MsgChannelCloseInitRespon\
    se\x20defines\x20the\x20Msg/ChannelCloseInit\x20response\x20type.\n\n\
    \x0b\n\x03\x04\t\x01\x12\x04\x90\x01\x08#\n\x94\x01\n\x02\x04\n\x12\x06\
    \x94\x01\0\x9e\x01\x01\x1a\x85\x01\x20MsgChannelCloseConfirm\x20defines\
    \x20a\x20msg\x20sent\x20by\x20a\x20Relayer\x20to\x20Chain\x20B\n\x20to\
    \x20acknowledge\x20the\x20change\x20of\x20channel\x20state\x20to\x20CLOS\
    ED\x20on\x20Chain\x20A.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x94\x01\x08\x1e\
    \n\x0b\n\x03\x04\n\x07\x12\x04\x95\x01\x02-\n\x0e\n\x06\x04\n\x07\x8d\
    \xf4\x03\x12\x04\x95\x01\x02-\n\x0b\n\x03\x04\n\x07\x12\x04\x96\x01\x02-\
    \n\x0e\n\x06\x04\n\x07\x81\xf4\x03\x12\x04\x96\x01\x02-\n\x0c\n\x04\x04\
    \n\x02\0\x12\x04\x98\x01\x02Y\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x98\x01\
    \x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x98\x01\x1c#\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\x98\x01+,\n\r\n\x05\x04\n\x02\0\x08\x12\x04\x98\x01-X\
    \n\x10\n\x08\x04\n\x02\0\x08\xee\xfb\x03\x12\x04\x98\x01.W\n\x0c\n\x04\
    \x04\n\x02\x01\x12\x04\x99\x01\x02\\\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\
    \x99\x01\x02\x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x99\x01\x1c&\n\r\n\
    \x05\x04\n\x02\x01\x03\x12\x04\x99\x01+,\n\r\n\x05\x04\n\x02\x01\x08\x12\
    \x04\x99\x01-[\n\x10\n\x08\x04\n\x02\x01\x08\xee\xfb\x03\x12\x04\x99\x01\
    .Z\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x9a\x01\x02\\\n\r\n\x05\x04\n\x02\
    \x02\x05\x12\x04\x9a\x01\x02\x07\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x9a\
    \x01\x1c&\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x9a\x01+,\n\r\n\x05\x04\n\
    \x02\x02\x08\x12\x04\x9a\x01-[\n\x10\n\x08\x04\n\x02\x02\x08\xee\xfb\x03\
    \x12\x04\x9a\x01.Z\n\x0e\n\x04\x04\n\x02\x03\x12\x06\x9b\x01\x02\x9c\x01\
    U\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\x9b\x01\x02\x1b\n\r\n\x05\x04\n\
    \x02\x03\x01\x12\x04\x9b\x01\x1c(\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\
    \x9b\x01+,\n\r\n\x05\x04\n\x02\x03\x08\x12\x04\x9c\x01\x06T\n\x10\n\x08\
    \x04\n\x02\x03\x08\xee\xfb\x03\x12\x04\x9c\x01\x075\n\x10\n\x08\x04\n\
    \x02\x03\x08\xe9\xfb\x03\x12\x04\x9c\x017S\n\x0c\n\x04\x04\n\x02\x04\x12\
    \x04\x9d\x01\x02\x14\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\x9d\x01\x02\x08\
    \n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x9d\x01\t\x0f\n\r\n\x05\x04\n\x02\
    \x04\x03\x12\x04\x9d\x01\x12\x13\n`\n\x02\x04\x0b\x12\x04\xa2\x01\0)\x1a\
    T\x20MsgChannelCloseConfirmResponse\x20defines\x20the\x20Msg/ChannelClos\
    eConfirm\x20response\n\x20type.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xa2\
    \x01\x08&\n:\n\x02\x04\x0c\x12\x06\xa5\x01\0\xae\x01\x01\x1a,\x20MsgRecv\
    Packet\x20receives\x20incoming\x20IBC\x20packet\n\n\x0b\n\x03\x04\x0c\
    \x01\x12\x04\xa5\x01\x08\x15\n\x0b\n\x03\x04\x0c\x07\x12\x04\xa6\x01\x02\
    -\n\x0e\n\x06\x04\x0c\x07\x8d\xf4\x03\x12\x04\xa6\x01\x02-\n\x0b\n\x03\
    \x04\x0c\x07\x12\x04\xa7\x01\x02-\n\x0e\n\x06\x04\x0c\x07\x81\xf4\x03\
    \x12\x04\xa7\x01\x02-\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xa9\x01\x02P\n\r\
    \n\x05\x04\x0c\x02\0\x06\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xa9\x01\x1c\"\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa9\x01/0\
    \n\r\n\x05\x04\x0c\x02\0\x08\x12\x04\xa9\x011O\n\x10\n\x08\x04\x0c\x02\0\
    \x08\xe9\xfb\x03\x12\x04\xa9\x012N\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\
    \xaa\x01\x02f\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xaa\x01\x02\x07\n\r\
    \n\x05\x04\x0c\x02\x01\x01\x12\x04\xaa\x01\x1c,\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\xaa\x01/0\n\r\n\x05\x04\x0c\x02\x01\x08\x12\x04\xaa\x01\
    1e\n\x10\n\x08\x04\x0c\x02\x01\x08\xee\xfb\x03\x12\x04\xaa\x012d\n\x0e\n\
    \x04\x04\x0c\x02\x02\x12\x06\xab\x01\x02\xac\x01U\n\r\n\x05\x04\x0c\x02\
    \x02\x06\x12\x04\xab\x01\x02\x1b\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\
    \xab\x01\x1c(\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xab\x01/0\n\r\n\x05\
    \x04\x0c\x02\x02\x08\x12\x04\xac\x01\x06T\n\x10\n\x08\x04\x0c\x02\x02\
    \x08\xee\xfb\x03\x12\x04\xac\x01\x075\n\x10\n\x08\x04\x0c\x02\x02\x08\
    \xe9\xfb\x03\x12\x04\xac\x017S\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\xad\
    \x01\x02\x14\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xad\x01\x02\x08\n\r\n\
    \x05\x04\x0c\x02\x03\x01\x12\x04\xad\x01\t\x0f\n\r\n\x05\x04\x0c\x02\x03\
    \x03\x12\x04\xad\x01\x12\x13\nO\n\x02\x04\r\x12\x06\xb1\x01\0\xb5\x01\
    \x01\x1aA\x20MsgRecvPacketResponse\x20defines\x20the\x20Msg/RecvPacket\
    \x20response\x20type.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xb1\x01\x08\x1d\n\
    \x0b\n\x03\x04\r\x07\x12\x04\xb2\x01\x02-\n\x0e\n\x06\x04\r\x07\x81\xf4\
    \x03\x12\x04\xb2\x01\x02-\n\x0c\n\x04\x04\r\x02\0\x12\x04\xb4\x01\x02\
    \x20\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xb4\x01\x02\x14\n\r\n\x05\x04\r\
    \x02\0\x01\x12\x04\xb4\x01\x15\x1b\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb4\
    \x01\x1e\x1f\n4\n\x02\x04\x0e\x12\x06\xb8\x01\0\xc2\x01\x01\x1a&\x20MsgT\
    imeout\x20receives\x20timed-out\x20packet\n\n\x0b\n\x03\x04\x0e\x01\x12\
    \x04\xb8\x01\x08\x12\n\x0b\n\x03\x04\x0e\x07\x12\x04\xb9\x01\x02-\n\x0e\
    \n\x06\x04\x0e\x07\x8d\xf4\x03\x12\x04\xb9\x01\x02-\n\x0b\n\x03\x04\x0e\
    \x07\x12\x04\xba\x01\x02-\n\x0e\n\x06\x04\x0e\x07\x81\xf4\x03\x12\x04\
    \xba\x01\x02-\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xbc\x01\x02P\n\r\n\x05\
    \x04\x0e\x02\0\x06\x12\x04\xbc\x01\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xbc\x01\x1c\"\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xbc\x01/0\n\r\
    \n\x05\x04\x0e\x02\0\x08\x12\x04\xbc\x011O\n\x10\n\x08\x04\x0e\x02\0\x08\
    \xe9\xfb\x03\x12\x04\xbc\x012N\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xbd\
    \x01\x02f\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xbd\x01\x02\x07\n\r\n\
    \x05\x04\x0e\x02\x01\x01\x12\x04\xbd\x01\x1c,\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\xbd\x01/0\n\r\n\x05\x04\x0e\x02\x01\x08\x12\x04\xbd\x011e\n\
    \x10\n\x08\x04\x0e\x02\x01\x08\xee\xfb\x03\x12\x04\xbd\x012d\n\x0e\n\x04\
    \x04\x0e\x02\x02\x12\x06\xbe\x01\x02\xbf\x01U\n\r\n\x05\x04\x0e\x02\x02\
    \x06\x12\x04\xbe\x01\x02\x1b\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xbe\
    \x01\x1c(\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xbe\x01/0\n\r\n\x05\x04\
    \x0e\x02\x02\x08\x12\x04\xbf\x01\x06T\n\x10\n\x08\x04\x0e\x02\x02\x08\
    \xee\xfb\x03\x12\x04\xbf\x01\x075\n\x10\n\x08\x04\x0e\x02\x02\x08\xe9\
    \xfb\x03\x12\x04\xbf\x017S\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xc0\x01\
    \x02W\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xc0\x01\x02\x08\n\r\n\x05\
    \x04\x0e\x02\x03\x01\x12\x04\xc0\x01\t\x1b\n\r\n\x05\x04\x0e\x02\x03\x03\
    \x12\x04\xc0\x01\x1e\x1f\n\r\n\x05\x04\x0e\x02\x03\x08\x12\x04\xc0\x01\
    \x20V\n\x10\n\x08\x04\x0e\x02\x03\x08\xee\xfb\x03\x12\x04\xc0\x01!U\n\
    \x0c\n\x04\x04\x0e\x02\x04\x12\x04\xc1\x01\x02\x20\n\r\n\x05\x04\x0e\x02\
    \x04\x05\x12\x04\xc1\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \xc1\x01\t\x0f\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xc1\x01\x1e\x1f\nI\
    \n\x02\x04\x0f\x12\x06\xc5\x01\0\xc9\x01\x01\x1a;\x20MsgTimeoutResponse\
    \x20defines\x20the\x20Msg/Timeout\x20response\x20type.\n\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xc5\x01\x08\x1a\n\x0b\n\x03\x04\x0f\x07\x12\x04\xc6\x01\
    \x02-\n\x0e\n\x06\x04\x0f\x07\x81\xf4\x03\x12\x04\xc6\x01\x02-\n\x0c\n\
    \x04\x04\x0f\x02\0\x12\x04\xc8\x01\x02\x20\n\r\n\x05\x04\x0f\x02\0\x06\
    \x12\x04\xc8\x01\x02\x14\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xc8\x01\x15\
    \x1b\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xc8\x01\x1e\x1f\nU\n\x02\x04\
    \x10\x12\x06\xcc\x01\0\xd7\x01\x01\x1aG\x20MsgTimeoutOnClose\x20timed-ou\
    t\x20packet\x20upon\x20counterparty\x20channel\x20closure.\n\n\x0b\n\x03\
    \x04\x10\x01\x12\x04\xcc\x01\x08\x19\n\x0b\n\x03\x04\x10\x07\x12\x04\xcd\
    \x01\x02-\n\x0e\n\x06\x04\x10\x07\x8d\xf4\x03\x12\x04\xcd\x01\x02-\n\x0b\
    \n\x03\x04\x10\x07\x12\x04\xce\x01\x02-\n\x0e\n\x06\x04\x10\x07\x81\xf4\
    \x03\x12\x04\xce\x01\x02-\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xd0\x01\x02P\
    \n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xd0\x01\x02\x08\n\r\n\x05\x04\x10\
    \x02\0\x01\x12\x04\xd0\x01\x1c\"\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xd0\
    \x01/0\n\r\n\x05\x04\x10\x02\0\x08\x12\x04\xd0\x011O\n\x10\n\x08\x04\x10\
    \x02\0\x08\xe9\xfb\x03\x12\x04\xd0\x012N\n\x0c\n\x04\x04\x10\x02\x01\x12\
    \x04\xd1\x01\x02f\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xd1\x01\x02\x07\
    \n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xd1\x01\x1c,\n\r\n\x05\x04\x10\
    \x02\x01\x03\x12\x04\xd1\x01/0\n\r\n\x05\x04\x10\x02\x01\x08\x12\x04\xd1\
    \x011e\n\x10\n\x08\x04\x10\x02\x01\x08\xee\xfb\x03\x12\x04\xd1\x012d\n\
    \x0c\n\x04\x04\x10\x02\x02\x12\x04\xd2\x01\x02a\n\r\n\x05\x04\x10\x02\
    \x02\x05\x12\x04\xd2\x01\x02\x07\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\
    \xd2\x01\x1c'\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd2\x01/0\n\r\n\x05\
    \x04\x10\x02\x02\x08\x12\x04\xd2\x011`\n\x10\n\x08\x04\x10\x02\x02\x08\
    \xee\xfb\x03\x12\x04\xd2\x012_\n\x0e\n\x04\x04\x10\x02\x03\x12\x06\xd3\
    \x01\x02\xd4\x01U\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\xd3\x01\x02\x1b\
    \n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xd3\x01\x1c(\n\r\n\x05\x04\x10\
    \x02\x03\x03\x12\x04\xd3\x01/0\n\r\n\x05\x04\x10\x02\x03\x08\x12\x04\xd4\
    \x01\x06T\n\x10\n\x08\x04\x10\x02\x03\x08\xee\xfb\x03\x12\x04\xd4\x01\
    \x075\n\x10\n\x08\x04\x10\x02\x03\x08\xe9\xfb\x03\x12\x04\xd4\x017S\n\
    \x0c\n\x04\x04\x10\x02\x04\x12\x04\xd5\x01\x02W\n\r\n\x05\x04\x10\x02\
    \x04\x05\x12\x04\xd5\x01\x02\x08\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\
    \xd5\x01\t\x1b\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xd5\x01\x1e\x1f\n\r\
    \n\x05\x04\x10\x02\x04\x08\x12\x04\xd5\x01\x20V\n\x10\n\x08\x04\x10\x02\
    \x04\x08\xee\xfb\x03\x12\x04\xd5\x01!U\n\x0c\n\x04\x04\x10\x02\x05\x12\
    \x04\xd6\x01\x02\x20\n\r\n\x05\x04\x10\x02\x05\x05\x12\x04\xd6\x01\x02\
    \x08\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xd6\x01\t\x0f\n\r\n\x05\x04\
    \x10\x02\x05\x03\x12\x04\xd6\x01\x1e\x1f\nW\n\x02\x04\x11\x12\x06\xda\
    \x01\0\xde\x01\x01\x1aI\x20MsgTimeoutOnCloseResponse\x20defines\x20the\
    \x20Msg/TimeoutOnClose\x20response\x20type.\n\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\xda\x01\x08!\n\x0b\n\x03\x04\x11\x07\x12\x04\xdb\x01\x02-\n\x0e\
    \n\x06\x04\x11\x07\x81\xf4\x03\x12\x04\xdb\x01\x02-\n\x0c\n\x04\x04\x11\
    \x02\0\x12\x04\xdd\x01\x02\x20\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xdd\
    \x01\x02\x14\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xdd\x01\x15\x1b\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xdd\x01\x1e\x1f\nH\n\x02\x04\x12\x12\x06\
    \xe1\x01\0\xeb\x01\x01\x1a:\x20MsgAcknowledgement\x20receives\x20incomin\
    g\x20IBC\x20acknowledgement\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xe1\x01\
    \x08\x1a\n\x0b\n\x03\x04\x12\x07\x12\x04\xe2\x01\x02-\n\x0e\n\x06\x04\
    \x12\x07\x8d\xf4\x03\x12\x04\xe2\x01\x02-\n\x0b\n\x03\x04\x12\x07\x12\
    \x04\xe3\x01\x02-\n\x0e\n\x06\x04\x12\x07\x81\xf4\x03\x12\x04\xe3\x01\
    \x02-\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xe5\x01\x02O\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xe5\x01\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xe5\x01\x1c\"\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xe5\x01./\n\r\n\x05\
    \x04\x12\x02\0\x08\x12\x04\xe5\x010N\n\x10\n\x08\x04\x12\x02\0\x08\xe9\
    \xfb\x03\x12\x04\xe5\x011M\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xe6\x01\
    \x020\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xe6\x01\x02\x07\n\r\n\x05\
    \x04\x12\x02\x01\x01\x12\x04\xe6\x01\x1c+\n\r\n\x05\x04\x12\x02\x01\x03\
    \x12\x04\xe6\x01./\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xe7\x01\x02`\n\r\
    \n\x05\x04\x12\x02\x02\x05\x12\x04\xe7\x01\x02\x07\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xe7\x01\x1c'\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xe7\
    \x01./\n\r\n\x05\x04\x12\x02\x02\x08\x12\x04\xe7\x010_\n\x10\n\x08\x04\
    \x12\x02\x02\x08\xee\xfb\x03\x12\x04\xe7\x011^\n\x0e\n\x04\x04\x12\x02\
    \x03\x12\x06\xe8\x01\x02\xe9\x01U\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\
    \xe8\x01\x02\x1b\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xe8\x01\x1c(\n\r\
    \n\x05\x04\x12\x02\x03\x03\x12\x04\xe8\x01./\n\r\n\x05\x04\x12\x02\x03\
    \x08\x12\x04\xe9\x01\x06T\n\x10\n\x08\x04\x12\x02\x03\x08\xee\xfb\x03\
    \x12\x04\xe9\x01\x075\n\x10\n\x08\x04\x12\x02\x03\x08\xe9\xfb\x03\x12\
    \x04\xe9\x017S\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xea\x01\x02\x14\n\r\n\
    \x05\x04\x12\x02\x04\x05\x12\x04\xea\x01\x02\x08\n\r\n\x05\x04\x12\x02\
    \x04\x01\x12\x04\xea\x01\t\x0f\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xea\
    \x01\x12\x13\nY\n\x02\x04\x13\x12\x06\xee\x01\0\xf2\x01\x01\x1aK\x20MsgA\
    cknowledgementResponse\x20defines\x20the\x20Msg/Acknowledgement\x20respo\
    nse\x20type.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xee\x01\x08\"\n\x0b\n\x03\
    \x04\x13\x07\x12\x04\xef\x01\x02-\n\x0e\n\x06\x04\x13\x07\x81\xf4\x03\
    \x12\x04\xef\x01\x02-\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xf1\x01\x02\x20\
    \n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xf1\x01\x02\x14\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xf1\x01\x15\x1b\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xf1\x01\x1e\x1fb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(super::client::file_descriptor().clone());
            deps.push(super::channel::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(20);
            messages.push(MsgChannelOpenInit::generated_message_descriptor_data());
            messages.push(MsgChannelOpenInitResponse::generated_message_descriptor_data());
            messages.push(MsgChannelOpenTry::generated_message_descriptor_data());
            messages.push(MsgChannelOpenTryResponse::generated_message_descriptor_data());
            messages.push(MsgChannelOpenAck::generated_message_descriptor_data());
            messages.push(MsgChannelOpenAckResponse::generated_message_descriptor_data());
            messages.push(MsgChannelOpenConfirm::generated_message_descriptor_data());
            messages.push(MsgChannelOpenConfirmResponse::generated_message_descriptor_data());
            messages.push(MsgChannelCloseInit::generated_message_descriptor_data());
            messages.push(MsgChannelCloseInitResponse::generated_message_descriptor_data());
            messages.push(MsgChannelCloseConfirm::generated_message_descriptor_data());
            messages.push(MsgChannelCloseConfirmResponse::generated_message_descriptor_data());
            messages.push(MsgRecvPacket::generated_message_descriptor_data());
            messages.push(MsgRecvPacketResponse::generated_message_descriptor_data());
            messages.push(MsgTimeout::generated_message_descriptor_data());
            messages.push(MsgTimeoutResponse::generated_message_descriptor_data());
            messages.push(MsgTimeoutOnClose::generated_message_descriptor_data());
            messages.push(MsgTimeoutOnCloseResponse::generated_message_descriptor_data());
            messages.push(MsgAcknowledgement::generated_message_descriptor_data());
            messages.push(MsgAcknowledgementResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ResponseResultType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
