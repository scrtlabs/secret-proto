// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ibc/core/channel/v1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  QueryChannelRequest is the request type for the Query/Channel RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelRequest)
pub struct QueryChannelRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelRequest.channel_id)
    pub channel_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelRequest {
    fn default() -> &'a QueryChannelRequest {
        <QueryChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelRequest {
    pub fn new() -> QueryChannelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryChannelRequest| { &m.port_id },
            |m: &mut QueryChannelRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryChannelRequest| { &m.channel_id },
            |m: &mut QueryChannelRequest| { &mut m.channel_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelRequest>(
            "QueryChannelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelRequest {
    const NAME: &'static str = "QueryChannelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelRequest {
        QueryChannelRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelRequest {
        static instance: QueryChannelRequest = QueryChannelRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryChannelResponse is the response type for the Query/Channel RPC method.
///  Besides the Channel end, it includes a proof and the height from which the
///  proof was retrieved.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelResponse)
pub struct QueryChannelResponse {
    // message fields
    ///  channel associated with the request identifiers
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelResponse.channel)
    pub channel: ::protobuf::MessageField<super::channel::Channel>,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelResponse {
    fn default() -> &'a QueryChannelResponse {
        <QueryChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelResponse {
    pub fn new() -> QueryChannelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::channel::Channel>(
            "channel",
            |m: &QueryChannelResponse| { &m.channel },
            |m: &mut QueryChannelResponse| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryChannelResponse| { &m.proof },
            |m: &mut QueryChannelResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryChannelResponse| { &m.proof_height },
            |m: &mut QueryChannelResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelResponse>(
            "QueryChannelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelResponse {
    const NAME: &'static str = "QueryChannelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.channel)?;
                },
                18 => {
                    self.proof = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelResponse {
        QueryChannelResponse::new()
    }

    fn clear(&mut self) {
        self.channel.clear();
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelResponse {
        static instance: QueryChannelResponse = QueryChannelResponse {
            channel: ::protobuf::MessageField::none(),
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryChannelsRequest is the request type for the Query/Channels RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelsRequest)
pub struct QueryChannelsRequest {
    // message fields
    ///  pagination request
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelsRequest {
    fn default() -> &'a QueryChannelsRequest {
        <QueryChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelsRequest {
    pub fn new() -> QueryChannelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryChannelsRequest| { &m.pagination },
            |m: &mut QueryChannelsRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelsRequest>(
            "QueryChannelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelsRequest {
    const NAME: &'static str = "QueryChannelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelsRequest {
        QueryChannelsRequest::new()
    }

    fn clear(&mut self) {
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelsRequest {
        static instance: QueryChannelsRequest = QueryChannelsRequest {
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryChannelsResponse is the response type for the Query/Channels RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelsResponse)
pub struct QueryChannelsResponse {
    // message fields
    ///  list of stored channels of the chain.
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelsResponse.channels)
    pub channels: ::std::vec::Vec<super::channel::IdentifiedChannel>,
    ///  pagination response
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    ///  query block height
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelsResponse.height)
    pub height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelsResponse {
    fn default() -> &'a QueryChannelsResponse {
        <QueryChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelsResponse {
    pub fn new() -> QueryChannelsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &QueryChannelsResponse| { &m.channels },
            |m: &mut QueryChannelsResponse| { &mut m.channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryChannelsResponse| { &m.pagination },
            |m: &mut QueryChannelsResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "height",
            |m: &QueryChannelsResponse| { &m.height },
            |m: &mut QueryChannelsResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelsResponse>(
            "QueryChannelsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelsResponse {
    const NAME: &'static str = "QueryChannelsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channels.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelsResponse {
        QueryChannelsResponse::new()
    }

    fn clear(&mut self) {
        self.channels.clear();
        self.pagination.clear();
        self.height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelsResponse {
        static instance: QueryChannelsResponse = QueryChannelsResponse {
            channels: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryConnectionChannelsRequest is the request type for the
///  Query/QueryConnectionChannels RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryConnectionChannelsRequest)
pub struct QueryConnectionChannelsRequest {
    // message fields
    ///  connection unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryConnectionChannelsRequest.connection)
    pub connection: ::std::string::String,
    ///  pagination request
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryConnectionChannelsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryConnectionChannelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryConnectionChannelsRequest {
    fn default() -> &'a QueryConnectionChannelsRequest {
        <QueryConnectionChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryConnectionChannelsRequest {
    pub fn new() -> QueryConnectionChannelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connection",
            |m: &QueryConnectionChannelsRequest| { &m.connection },
            |m: &mut QueryConnectionChannelsRequest| { &mut m.connection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryConnectionChannelsRequest| { &m.pagination },
            |m: &mut QueryConnectionChannelsRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryConnectionChannelsRequest>(
            "QueryConnectionChannelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryConnectionChannelsRequest {
    const NAME: &'static str = "QueryConnectionChannelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.connection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connection);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.connection.is_empty() {
            os.write_string(1, &self.connection)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryConnectionChannelsRequest {
        QueryConnectionChannelsRequest::new()
    }

    fn clear(&mut self) {
        self.connection.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryConnectionChannelsRequest {
        static instance: QueryConnectionChannelsRequest = QueryConnectionChannelsRequest {
            connection: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryConnectionChannelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryConnectionChannelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryConnectionChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConnectionChannelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryConnectionChannelsResponse is the Response type for the
///  Query/QueryConnectionChannels RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryConnectionChannelsResponse)
pub struct QueryConnectionChannelsResponse {
    // message fields
    ///  list of channels associated with a connection.
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryConnectionChannelsResponse.channels)
    pub channels: ::std::vec::Vec<super::channel::IdentifiedChannel>,
    ///  pagination response
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryConnectionChannelsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    ///  query block height
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryConnectionChannelsResponse.height)
    pub height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryConnectionChannelsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryConnectionChannelsResponse {
    fn default() -> &'a QueryConnectionChannelsResponse {
        <QueryConnectionChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryConnectionChannelsResponse {
    pub fn new() -> QueryConnectionChannelsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &QueryConnectionChannelsResponse| { &m.channels },
            |m: &mut QueryConnectionChannelsResponse| { &mut m.channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryConnectionChannelsResponse| { &m.pagination },
            |m: &mut QueryConnectionChannelsResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "height",
            |m: &QueryConnectionChannelsResponse| { &m.height },
            |m: &mut QueryConnectionChannelsResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryConnectionChannelsResponse>(
            "QueryConnectionChannelsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryConnectionChannelsResponse {
    const NAME: &'static str = "QueryConnectionChannelsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channels.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryConnectionChannelsResponse {
        QueryConnectionChannelsResponse::new()
    }

    fn clear(&mut self) {
        self.channels.clear();
        self.pagination.clear();
        self.height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryConnectionChannelsResponse {
        static instance: QueryConnectionChannelsResponse = QueryConnectionChannelsResponse {
            channels: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryConnectionChannelsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryConnectionChannelsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryConnectionChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConnectionChannelsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryChannelClientStateRequest is the request type for the Query/ClientState
///  RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelClientStateRequest)
pub struct QueryChannelClientStateRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelClientStateRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelClientStateRequest.channel_id)
    pub channel_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelClientStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelClientStateRequest {
    fn default() -> &'a QueryChannelClientStateRequest {
        <QueryChannelClientStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelClientStateRequest {
    pub fn new() -> QueryChannelClientStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryChannelClientStateRequest| { &m.port_id },
            |m: &mut QueryChannelClientStateRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryChannelClientStateRequest| { &m.channel_id },
            |m: &mut QueryChannelClientStateRequest| { &mut m.channel_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelClientStateRequest>(
            "QueryChannelClientStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelClientStateRequest {
    const NAME: &'static str = "QueryChannelClientStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelClientStateRequest {
        QueryChannelClientStateRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelClientStateRequest {
        static instance: QueryChannelClientStateRequest = QueryChannelClientStateRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelClientStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelClientStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelClientStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelClientStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryChannelClientStateResponse is the Response type for the
///  Query/QueryChannelClientState RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelClientStateResponse)
pub struct QueryChannelClientStateResponse {
    // message fields
    ///  client state associated with the channel
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelClientStateResponse.identified_client_state)
    pub identified_client_state: ::protobuf::MessageField<super::client::IdentifiedClientState>,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelClientStateResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelClientStateResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelClientStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelClientStateResponse {
    fn default() -> &'a QueryChannelClientStateResponse {
        <QueryChannelClientStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelClientStateResponse {
    pub fn new() -> QueryChannelClientStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::IdentifiedClientState>(
            "identified_client_state",
            |m: &QueryChannelClientStateResponse| { &m.identified_client_state },
            |m: &mut QueryChannelClientStateResponse| { &mut m.identified_client_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryChannelClientStateResponse| { &m.proof },
            |m: &mut QueryChannelClientStateResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryChannelClientStateResponse| { &m.proof_height },
            |m: &mut QueryChannelClientStateResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelClientStateResponse>(
            "QueryChannelClientStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelClientStateResponse {
    const NAME: &'static str = "QueryChannelClientStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.identified_client_state)?;
                },
                18 => {
                    self.proof = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identified_client_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identified_client_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelClientStateResponse {
        QueryChannelClientStateResponse::new()
    }

    fn clear(&mut self) {
        self.identified_client_state.clear();
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelClientStateResponse {
        static instance: QueryChannelClientStateResponse = QueryChannelClientStateResponse {
            identified_client_state: ::protobuf::MessageField::none(),
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelClientStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelClientStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelClientStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelClientStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryChannelConsensusStateRequest is the request type for the
///  Query/ConsensusState RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelConsensusStateRequest)
pub struct QueryChannelConsensusStateRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  revision number of the consensus state
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateRequest.revision_number)
    pub revision_number: u64,
    ///  revision height of the consensus state
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateRequest.revision_height)
    pub revision_height: u64,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelConsensusStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelConsensusStateRequest {
    fn default() -> &'a QueryChannelConsensusStateRequest {
        <QueryChannelConsensusStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelConsensusStateRequest {
    pub fn new() -> QueryChannelConsensusStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryChannelConsensusStateRequest| { &m.port_id },
            |m: &mut QueryChannelConsensusStateRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryChannelConsensusStateRequest| { &m.channel_id },
            |m: &mut QueryChannelConsensusStateRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "revision_number",
            |m: &QueryChannelConsensusStateRequest| { &m.revision_number },
            |m: &mut QueryChannelConsensusStateRequest| { &mut m.revision_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "revision_height",
            |m: &QueryChannelConsensusStateRequest| { &m.revision_height },
            |m: &mut QueryChannelConsensusStateRequest| { &mut m.revision_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelConsensusStateRequest>(
            "QueryChannelConsensusStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelConsensusStateRequest {
    const NAME: &'static str = "QueryChannelConsensusStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                24 => {
                    self.revision_number = is.read_uint64()?;
                },
                32 => {
                    self.revision_height = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if self.revision_number != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.revision_number);
        }
        if self.revision_height != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.revision_height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if self.revision_number != 0 {
            os.write_uint64(3, self.revision_number)?;
        }
        if self.revision_height != 0 {
            os.write_uint64(4, self.revision_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelConsensusStateRequest {
        QueryChannelConsensusStateRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.revision_number = 0;
        self.revision_height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelConsensusStateRequest {
        static instance: QueryChannelConsensusStateRequest = QueryChannelConsensusStateRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            revision_number: 0,
            revision_height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelConsensusStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelConsensusStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelConsensusStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelConsensusStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryChannelClientStateResponse is the Response type for the
///  Query/QueryChannelClientState RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryChannelConsensusStateResponse)
pub struct QueryChannelConsensusStateResponse {
    // message fields
    ///  consensus state associated with the channel
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateResponse.consensus_state)
    pub consensus_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  client ID associated with the consensus state
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateResponse.client_id)
    pub client_id: ::std::string::String,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryChannelConsensusStateResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryChannelConsensusStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryChannelConsensusStateResponse {
    fn default() -> &'a QueryChannelConsensusStateResponse {
        <QueryChannelConsensusStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelConsensusStateResponse {
    pub fn new() -> QueryChannelConsensusStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "consensus_state",
            |m: &QueryChannelConsensusStateResponse| { &m.consensus_state },
            |m: &mut QueryChannelConsensusStateResponse| { &mut m.consensus_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &QueryChannelConsensusStateResponse| { &m.client_id },
            |m: &mut QueryChannelConsensusStateResponse| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryChannelConsensusStateResponse| { &m.proof },
            |m: &mut QueryChannelConsensusStateResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryChannelConsensusStateResponse| { &m.proof_height },
            |m: &mut QueryChannelConsensusStateResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryChannelConsensusStateResponse>(
            "QueryChannelConsensusStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryChannelConsensusStateResponse {
    const NAME: &'static str = "QueryChannelConsensusStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_state)?;
                },
                18 => {
                    self.client_id = is.read_string()?;
                },
                26 => {
                    self.proof = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.consensus_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_id);
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.consensus_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(2, &self.client_id)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(3, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryChannelConsensusStateResponse {
        QueryChannelConsensusStateResponse::new()
    }

    fn clear(&mut self) {
        self.consensus_state.clear();
        self.client_id.clear();
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryChannelConsensusStateResponse {
        static instance: QueryChannelConsensusStateResponse = QueryChannelConsensusStateResponse {
            consensus_state: ::protobuf::MessageField::none(),
            client_id: ::std::string::String::new(),
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryChannelConsensusStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryChannelConsensusStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryChannelConsensusStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelConsensusStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketCommitmentRequest is the request type for the
///  Query/PacketCommitment RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketCommitmentRequest)
pub struct QueryPacketCommitmentRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  packet sequence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentRequest.sequence)
    pub sequence: u64,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketCommitmentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketCommitmentRequest {
    fn default() -> &'a QueryPacketCommitmentRequest {
        <QueryPacketCommitmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketCommitmentRequest {
    pub fn new() -> QueryPacketCommitmentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryPacketCommitmentRequest| { &m.port_id },
            |m: &mut QueryPacketCommitmentRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryPacketCommitmentRequest| { &m.channel_id },
            |m: &mut QueryPacketCommitmentRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &QueryPacketCommitmentRequest| { &m.sequence },
            |m: &mut QueryPacketCommitmentRequest| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketCommitmentRequest>(
            "QueryPacketCommitmentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketCommitmentRequest {
    const NAME: &'static str = "QueryPacketCommitmentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                24 => {
                    self.sequence = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketCommitmentRequest {
        QueryPacketCommitmentRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketCommitmentRequest {
        static instance: QueryPacketCommitmentRequest = QueryPacketCommitmentRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketCommitmentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketCommitmentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketCommitmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketCommitmentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketCommitmentResponse defines the client query response for a packet
///  which also includes a proof and the height from which the proof was
///  retrieved
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketCommitmentResponse)
pub struct QueryPacketCommitmentResponse {
    // message fields
    ///  packet associated with the request fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentResponse.commitment)
    pub commitment: ::std::vec::Vec<u8>,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketCommitmentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketCommitmentResponse {
    fn default() -> &'a QueryPacketCommitmentResponse {
        <QueryPacketCommitmentResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketCommitmentResponse {
    pub fn new() -> QueryPacketCommitmentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "commitment",
            |m: &QueryPacketCommitmentResponse| { &m.commitment },
            |m: &mut QueryPacketCommitmentResponse| { &mut m.commitment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryPacketCommitmentResponse| { &m.proof },
            |m: &mut QueryPacketCommitmentResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryPacketCommitmentResponse| { &m.proof_height },
            |m: &mut QueryPacketCommitmentResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketCommitmentResponse>(
            "QueryPacketCommitmentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketCommitmentResponse {
    const NAME: &'static str = "QueryPacketCommitmentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commitment = is.read_bytes()?;
                },
                18 => {
                    self.proof = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.commitment.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.commitment);
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.commitment.is_empty() {
            os.write_bytes(1, &self.commitment)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketCommitmentResponse {
        QueryPacketCommitmentResponse::new()
    }

    fn clear(&mut self) {
        self.commitment.clear();
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketCommitmentResponse {
        static instance: QueryPacketCommitmentResponse = QueryPacketCommitmentResponse {
            commitment: ::std::vec::Vec::new(),
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketCommitmentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketCommitmentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketCommitmentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketCommitmentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketCommitmentsRequest is the request type for the
///  Query/QueryPacketCommitments RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketCommitmentsRequest)
pub struct QueryPacketCommitmentsRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentsRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentsRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  pagination request
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketCommitmentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketCommitmentsRequest {
    fn default() -> &'a QueryPacketCommitmentsRequest {
        <QueryPacketCommitmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketCommitmentsRequest {
    pub fn new() -> QueryPacketCommitmentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryPacketCommitmentsRequest| { &m.port_id },
            |m: &mut QueryPacketCommitmentsRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryPacketCommitmentsRequest| { &m.channel_id },
            |m: &mut QueryPacketCommitmentsRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryPacketCommitmentsRequest| { &m.pagination },
            |m: &mut QueryPacketCommitmentsRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketCommitmentsRequest>(
            "QueryPacketCommitmentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketCommitmentsRequest {
    const NAME: &'static str = "QueryPacketCommitmentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketCommitmentsRequest {
        QueryPacketCommitmentsRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketCommitmentsRequest {
        static instance: QueryPacketCommitmentsRequest = QueryPacketCommitmentsRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketCommitmentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketCommitmentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketCommitmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketCommitmentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketCommitmentsResponse is the request type for the
///  Query/QueryPacketCommitments RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketCommitmentsResponse)
pub struct QueryPacketCommitmentsResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentsResponse.commitments)
    pub commitments: ::std::vec::Vec<super::channel::PacketState>,
    ///  pagination response
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    ///  query block height
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketCommitmentsResponse.height)
    pub height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketCommitmentsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketCommitmentsResponse {
    fn default() -> &'a QueryPacketCommitmentsResponse {
        <QueryPacketCommitmentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketCommitmentsResponse {
    pub fn new() -> QueryPacketCommitmentsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "commitments",
            |m: &QueryPacketCommitmentsResponse| { &m.commitments },
            |m: &mut QueryPacketCommitmentsResponse| { &mut m.commitments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryPacketCommitmentsResponse| { &m.pagination },
            |m: &mut QueryPacketCommitmentsResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "height",
            |m: &QueryPacketCommitmentsResponse| { &m.height },
            |m: &mut QueryPacketCommitmentsResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketCommitmentsResponse>(
            "QueryPacketCommitmentsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketCommitmentsResponse {
    const NAME: &'static str = "QueryPacketCommitmentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commitments.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.commitments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.commitments {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketCommitmentsResponse {
        QueryPacketCommitmentsResponse::new()
    }

    fn clear(&mut self) {
        self.commitments.clear();
        self.pagination.clear();
        self.height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketCommitmentsResponse {
        static instance: QueryPacketCommitmentsResponse = QueryPacketCommitmentsResponse {
            commitments: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketCommitmentsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketCommitmentsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketCommitmentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketCommitmentsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketReceiptRequest is the request type for the
///  Query/PacketReceipt RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketReceiptRequest)
pub struct QueryPacketReceiptRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketReceiptRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketReceiptRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  packet sequence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketReceiptRequest.sequence)
    pub sequence: u64,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketReceiptRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketReceiptRequest {
    fn default() -> &'a QueryPacketReceiptRequest {
        <QueryPacketReceiptRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketReceiptRequest {
    pub fn new() -> QueryPacketReceiptRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryPacketReceiptRequest| { &m.port_id },
            |m: &mut QueryPacketReceiptRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryPacketReceiptRequest| { &m.channel_id },
            |m: &mut QueryPacketReceiptRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &QueryPacketReceiptRequest| { &m.sequence },
            |m: &mut QueryPacketReceiptRequest| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketReceiptRequest>(
            "QueryPacketReceiptRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketReceiptRequest {
    const NAME: &'static str = "QueryPacketReceiptRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                24 => {
                    self.sequence = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketReceiptRequest {
        QueryPacketReceiptRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketReceiptRequest {
        static instance: QueryPacketReceiptRequest = QueryPacketReceiptRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketReceiptRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketReceiptRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketReceiptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketReceiptRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketReceiptResponse defines the client query response for a packet
///  receipt which also includes a proof, and the height from which the proof was
///  retrieved
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketReceiptResponse)
pub struct QueryPacketReceiptResponse {
    // message fields
    ///  success flag for if receipt exists
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketReceiptResponse.received)
    pub received: bool,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketReceiptResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketReceiptResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketReceiptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketReceiptResponse {
    fn default() -> &'a QueryPacketReceiptResponse {
        <QueryPacketReceiptResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketReceiptResponse {
    pub fn new() -> QueryPacketReceiptResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "received",
            |m: &QueryPacketReceiptResponse| { &m.received },
            |m: &mut QueryPacketReceiptResponse| { &mut m.received },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryPacketReceiptResponse| { &m.proof },
            |m: &mut QueryPacketReceiptResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryPacketReceiptResponse| { &m.proof_height },
            |m: &mut QueryPacketReceiptResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketReceiptResponse>(
            "QueryPacketReceiptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketReceiptResponse {
    const NAME: &'static str = "QueryPacketReceiptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.received = is.read_bool()?;
                },
                26 => {
                    self.proof = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.received != false {
            my_size += 1 + 1;
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.received != false {
            os.write_bool(2, self.received)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(3, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketReceiptResponse {
        QueryPacketReceiptResponse::new()
    }

    fn clear(&mut self) {
        self.received = false;
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketReceiptResponse {
        static instance: QueryPacketReceiptResponse = QueryPacketReceiptResponse {
            received: false,
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketReceiptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketReceiptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketReceiptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketReceiptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketAcknowledgementRequest is the request type for the
///  Query/PacketAcknowledgement RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketAcknowledgementRequest)
pub struct QueryPacketAcknowledgementRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  packet sequence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementRequest.sequence)
    pub sequence: u64,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketAcknowledgementRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketAcknowledgementRequest {
    fn default() -> &'a QueryPacketAcknowledgementRequest {
        <QueryPacketAcknowledgementRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketAcknowledgementRequest {
    pub fn new() -> QueryPacketAcknowledgementRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryPacketAcknowledgementRequest| { &m.port_id },
            |m: &mut QueryPacketAcknowledgementRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryPacketAcknowledgementRequest| { &m.channel_id },
            |m: &mut QueryPacketAcknowledgementRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &QueryPacketAcknowledgementRequest| { &m.sequence },
            |m: &mut QueryPacketAcknowledgementRequest| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketAcknowledgementRequest>(
            "QueryPacketAcknowledgementRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketAcknowledgementRequest {
    const NAME: &'static str = "QueryPacketAcknowledgementRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                24 => {
                    self.sequence = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketAcknowledgementRequest {
        QueryPacketAcknowledgementRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketAcknowledgementRequest {
        static instance: QueryPacketAcknowledgementRequest = QueryPacketAcknowledgementRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketAcknowledgementRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketAcknowledgementRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketAcknowledgementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketAcknowledgementRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketAcknowledgementResponse defines the client query response for a
///  packet which also includes a proof and the height from which the
///  proof was retrieved
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketAcknowledgementResponse)
pub struct QueryPacketAcknowledgementResponse {
    // message fields
    ///  packet associated with the request fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementResponse.acknowledgement)
    pub acknowledgement: ::std::vec::Vec<u8>,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketAcknowledgementResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketAcknowledgementResponse {
    fn default() -> &'a QueryPacketAcknowledgementResponse {
        <QueryPacketAcknowledgementResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketAcknowledgementResponse {
    pub fn new() -> QueryPacketAcknowledgementResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "acknowledgement",
            |m: &QueryPacketAcknowledgementResponse| { &m.acknowledgement },
            |m: &mut QueryPacketAcknowledgementResponse| { &mut m.acknowledgement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryPacketAcknowledgementResponse| { &m.proof },
            |m: &mut QueryPacketAcknowledgementResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryPacketAcknowledgementResponse| { &m.proof_height },
            |m: &mut QueryPacketAcknowledgementResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketAcknowledgementResponse>(
            "QueryPacketAcknowledgementResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketAcknowledgementResponse {
    const NAME: &'static str = "QueryPacketAcknowledgementResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.acknowledgement = is.read_bytes()?;
                },
                18 => {
                    self.proof = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.acknowledgement.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.acknowledgement);
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.acknowledgement.is_empty() {
            os.write_bytes(1, &self.acknowledgement)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketAcknowledgementResponse {
        QueryPacketAcknowledgementResponse::new()
    }

    fn clear(&mut self) {
        self.acknowledgement.clear();
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketAcknowledgementResponse {
        static instance: QueryPacketAcknowledgementResponse = QueryPacketAcknowledgementResponse {
            acknowledgement: ::std::vec::Vec::new(),
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketAcknowledgementResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketAcknowledgementResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketAcknowledgementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketAcknowledgementResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketAcknowledgementsRequest is the request type for the
///  Query/QueryPacketCommitments RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketAcknowledgementsRequest)
pub struct QueryPacketAcknowledgementsRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementsRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementsRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  pagination request
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    ///  list of packet sequences
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementsRequest.packet_commitment_sequences)
    pub packet_commitment_sequences: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketAcknowledgementsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketAcknowledgementsRequest {
    fn default() -> &'a QueryPacketAcknowledgementsRequest {
        <QueryPacketAcknowledgementsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketAcknowledgementsRequest {
    pub fn new() -> QueryPacketAcknowledgementsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryPacketAcknowledgementsRequest| { &m.port_id },
            |m: &mut QueryPacketAcknowledgementsRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryPacketAcknowledgementsRequest| { &m.channel_id },
            |m: &mut QueryPacketAcknowledgementsRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryPacketAcknowledgementsRequest| { &m.pagination },
            |m: &mut QueryPacketAcknowledgementsRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packet_commitment_sequences",
            |m: &QueryPacketAcknowledgementsRequest| { &m.packet_commitment_sequences },
            |m: &mut QueryPacketAcknowledgementsRequest| { &mut m.packet_commitment_sequences },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketAcknowledgementsRequest>(
            "QueryPacketAcknowledgementsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketAcknowledgementsRequest {
    const NAME: &'static str = "QueryPacketAcknowledgementsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.packet_commitment_sequences)?;
                },
                32 => {
                    self.packet_commitment_sequences.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.packet_commitment_sequences {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.packet_commitment_sequences {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketAcknowledgementsRequest {
        QueryPacketAcknowledgementsRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.pagination.clear();
        self.packet_commitment_sequences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketAcknowledgementsRequest {
        static instance: QueryPacketAcknowledgementsRequest = QueryPacketAcknowledgementsRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            packet_commitment_sequences: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketAcknowledgementsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketAcknowledgementsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketAcknowledgementsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketAcknowledgementsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPacketAcknowledgemetsResponse is the request type for the
///  Query/QueryPacketAcknowledgements RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryPacketAcknowledgementsResponse)
pub struct QueryPacketAcknowledgementsResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementsResponse.acknowledgements)
    pub acknowledgements: ::std::vec::Vec<super::channel::PacketState>,
    ///  pagination response
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    ///  query block height
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryPacketAcknowledgementsResponse.height)
    pub height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryPacketAcknowledgementsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPacketAcknowledgementsResponse {
    fn default() -> &'a QueryPacketAcknowledgementsResponse {
        <QueryPacketAcknowledgementsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPacketAcknowledgementsResponse {
    pub fn new() -> QueryPacketAcknowledgementsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "acknowledgements",
            |m: &QueryPacketAcknowledgementsResponse| { &m.acknowledgements },
            |m: &mut QueryPacketAcknowledgementsResponse| { &mut m.acknowledgements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryPacketAcknowledgementsResponse| { &m.pagination },
            |m: &mut QueryPacketAcknowledgementsResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "height",
            |m: &QueryPacketAcknowledgementsResponse| { &m.height },
            |m: &mut QueryPacketAcknowledgementsResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPacketAcknowledgementsResponse>(
            "QueryPacketAcknowledgementsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPacketAcknowledgementsResponse {
    const NAME: &'static str = "QueryPacketAcknowledgementsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.acknowledgements.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.acknowledgements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.acknowledgements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPacketAcknowledgementsResponse {
        QueryPacketAcknowledgementsResponse::new()
    }

    fn clear(&mut self) {
        self.acknowledgements.clear();
        self.pagination.clear();
        self.height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPacketAcknowledgementsResponse {
        static instance: QueryPacketAcknowledgementsResponse = QueryPacketAcknowledgementsResponse {
            acknowledgements: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPacketAcknowledgementsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPacketAcknowledgementsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPacketAcknowledgementsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPacketAcknowledgementsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUnreceivedPacketsRequest is the request type for the
///  Query/UnreceivedPackets RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryUnreceivedPacketsRequest)
pub struct QueryUnreceivedPacketsRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedPacketsRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedPacketsRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  list of packet sequences
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedPacketsRequest.packet_commitment_sequences)
    pub packet_commitment_sequences: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryUnreceivedPacketsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUnreceivedPacketsRequest {
    fn default() -> &'a QueryUnreceivedPacketsRequest {
        <QueryUnreceivedPacketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryUnreceivedPacketsRequest {
    pub fn new() -> QueryUnreceivedPacketsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryUnreceivedPacketsRequest| { &m.port_id },
            |m: &mut QueryUnreceivedPacketsRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryUnreceivedPacketsRequest| { &m.channel_id },
            |m: &mut QueryUnreceivedPacketsRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packet_commitment_sequences",
            |m: &QueryUnreceivedPacketsRequest| { &m.packet_commitment_sequences },
            |m: &mut QueryUnreceivedPacketsRequest| { &mut m.packet_commitment_sequences },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUnreceivedPacketsRequest>(
            "QueryUnreceivedPacketsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUnreceivedPacketsRequest {
    const NAME: &'static str = "QueryUnreceivedPacketsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.packet_commitment_sequences)?;
                },
                24 => {
                    self.packet_commitment_sequences.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        for value in &self.packet_commitment_sequences {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        for v in &self.packet_commitment_sequences {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUnreceivedPacketsRequest {
        QueryUnreceivedPacketsRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.packet_commitment_sequences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUnreceivedPacketsRequest {
        static instance: QueryUnreceivedPacketsRequest = QueryUnreceivedPacketsRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            packet_commitment_sequences: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUnreceivedPacketsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUnreceivedPacketsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUnreceivedPacketsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUnreceivedPacketsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUnreceivedPacketsResponse is the response type for the
///  Query/UnreceivedPacketCommitments RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryUnreceivedPacketsResponse)
pub struct QueryUnreceivedPacketsResponse {
    // message fields
    ///  list of unreceived packet sequences
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedPacketsResponse.sequences)
    pub sequences: ::std::vec::Vec<u64>,
    ///  query block height
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedPacketsResponse.height)
    pub height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryUnreceivedPacketsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUnreceivedPacketsResponse {
    fn default() -> &'a QueryUnreceivedPacketsResponse {
        <QueryUnreceivedPacketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryUnreceivedPacketsResponse {
    pub fn new() -> QueryUnreceivedPacketsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sequences",
            |m: &QueryUnreceivedPacketsResponse| { &m.sequences },
            |m: &mut QueryUnreceivedPacketsResponse| { &mut m.sequences },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "height",
            |m: &QueryUnreceivedPacketsResponse| { &m.height },
            |m: &mut QueryUnreceivedPacketsResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUnreceivedPacketsResponse>(
            "QueryUnreceivedPacketsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUnreceivedPacketsResponse {
    const NAME: &'static str = "QueryUnreceivedPacketsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.sequences)?;
                },
                8 => {
                    self.sequences.push(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sequences {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sequences {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUnreceivedPacketsResponse {
        QueryUnreceivedPacketsResponse::new()
    }

    fn clear(&mut self) {
        self.sequences.clear();
        self.height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUnreceivedPacketsResponse {
        static instance: QueryUnreceivedPacketsResponse = QueryUnreceivedPacketsResponse {
            sequences: ::std::vec::Vec::new(),
            height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUnreceivedPacketsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUnreceivedPacketsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUnreceivedPacketsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUnreceivedPacketsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUnreceivedAcks is the request type for the
///  Query/UnreceivedAcks RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryUnreceivedAcksRequest)
pub struct QueryUnreceivedAcksRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedAcksRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedAcksRequest.channel_id)
    pub channel_id: ::std::string::String,
    ///  list of acknowledgement sequences
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedAcksRequest.packet_ack_sequences)
    pub packet_ack_sequences: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryUnreceivedAcksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUnreceivedAcksRequest {
    fn default() -> &'a QueryUnreceivedAcksRequest {
        <QueryUnreceivedAcksRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryUnreceivedAcksRequest {
    pub fn new() -> QueryUnreceivedAcksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryUnreceivedAcksRequest| { &m.port_id },
            |m: &mut QueryUnreceivedAcksRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryUnreceivedAcksRequest| { &m.channel_id },
            |m: &mut QueryUnreceivedAcksRequest| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packet_ack_sequences",
            |m: &QueryUnreceivedAcksRequest| { &m.packet_ack_sequences },
            |m: &mut QueryUnreceivedAcksRequest| { &mut m.packet_ack_sequences },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUnreceivedAcksRequest>(
            "QueryUnreceivedAcksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUnreceivedAcksRequest {
    const NAME: &'static str = "QueryUnreceivedAcksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.packet_ack_sequences)?;
                },
                24 => {
                    self.packet_ack_sequences.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        for value in &self.packet_ack_sequences {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        for v in &self.packet_ack_sequences {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUnreceivedAcksRequest {
        QueryUnreceivedAcksRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.packet_ack_sequences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUnreceivedAcksRequest {
        static instance: QueryUnreceivedAcksRequest = QueryUnreceivedAcksRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            packet_ack_sequences: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUnreceivedAcksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUnreceivedAcksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUnreceivedAcksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUnreceivedAcksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUnreceivedAcksResponse is the response type for the
///  Query/UnreceivedAcks RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryUnreceivedAcksResponse)
pub struct QueryUnreceivedAcksResponse {
    // message fields
    ///  list of unreceived acknowledgement sequences
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedAcksResponse.sequences)
    pub sequences: ::std::vec::Vec<u64>,
    ///  query block height
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryUnreceivedAcksResponse.height)
    pub height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryUnreceivedAcksResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUnreceivedAcksResponse {
    fn default() -> &'a QueryUnreceivedAcksResponse {
        <QueryUnreceivedAcksResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryUnreceivedAcksResponse {
    pub fn new() -> QueryUnreceivedAcksResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sequences",
            |m: &QueryUnreceivedAcksResponse| { &m.sequences },
            |m: &mut QueryUnreceivedAcksResponse| { &mut m.sequences },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "height",
            |m: &QueryUnreceivedAcksResponse| { &m.height },
            |m: &mut QueryUnreceivedAcksResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUnreceivedAcksResponse>(
            "QueryUnreceivedAcksResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUnreceivedAcksResponse {
    const NAME: &'static str = "QueryUnreceivedAcksResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.sequences)?;
                },
                8 => {
                    self.sequences.push(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sequences {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sequences {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUnreceivedAcksResponse {
        QueryUnreceivedAcksResponse::new()
    }

    fn clear(&mut self) {
        self.sequences.clear();
        self.height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUnreceivedAcksResponse {
        static instance: QueryUnreceivedAcksResponse = QueryUnreceivedAcksResponse {
            sequences: ::std::vec::Vec::new(),
            height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUnreceivedAcksResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUnreceivedAcksResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUnreceivedAcksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUnreceivedAcksResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryNextSequenceReceiveRequest is the request type for the
///  Query/QueryNextSequenceReceiveRequest RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryNextSequenceReceiveRequest)
pub struct QueryNextSequenceReceiveRequest {
    // message fields
    ///  port unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryNextSequenceReceiveRequest.port_id)
    pub port_id: ::std::string::String,
    ///  channel unique identifier
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryNextSequenceReceiveRequest.channel_id)
    pub channel_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryNextSequenceReceiveRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryNextSequenceReceiveRequest {
    fn default() -> &'a QueryNextSequenceReceiveRequest {
        <QueryNextSequenceReceiveRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryNextSequenceReceiveRequest {
    pub fn new() -> QueryNextSequenceReceiveRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port_id",
            |m: &QueryNextSequenceReceiveRequest| { &m.port_id },
            |m: &mut QueryNextSequenceReceiveRequest| { &mut m.port_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_id",
            |m: &QueryNextSequenceReceiveRequest| { &m.channel_id },
            |m: &mut QueryNextSequenceReceiveRequest| { &mut m.channel_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryNextSequenceReceiveRequest>(
            "QueryNextSequenceReceiveRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryNextSequenceReceiveRequest {
    const NAME: &'static str = "QueryNextSequenceReceiveRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.port_id = is.read_string()?;
                },
                18 => {
                    self.channel_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryNextSequenceReceiveRequest {
        QueryNextSequenceReceiveRequest::new()
    }

    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryNextSequenceReceiveRequest {
        static instance: QueryNextSequenceReceiveRequest = QueryNextSequenceReceiveRequest {
            port_id: ::std::string::String::new(),
            channel_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryNextSequenceReceiveRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryNextSequenceReceiveRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryNextSequenceReceiveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryNextSequenceReceiveRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QuerySequenceResponse is the request type for the
///  Query/QueryNextSequenceReceiveResponse RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.channel.v1.QueryNextSequenceReceiveResponse)
pub struct QueryNextSequenceReceiveResponse {
    // message fields
    ///  next sequence receive number
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryNextSequenceReceiveResponse.next_sequence_receive)
    pub next_sequence_receive: u64,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryNextSequenceReceiveResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.channel.v1.QueryNextSequenceReceiveResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.channel.v1.QueryNextSequenceReceiveResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryNextSequenceReceiveResponse {
    fn default() -> &'a QueryNextSequenceReceiveResponse {
        <QueryNextSequenceReceiveResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryNextSequenceReceiveResponse {
    pub fn new() -> QueryNextSequenceReceiveResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_sequence_receive",
            |m: &QueryNextSequenceReceiveResponse| { &m.next_sequence_receive },
            |m: &mut QueryNextSequenceReceiveResponse| { &mut m.next_sequence_receive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryNextSequenceReceiveResponse| { &m.proof },
            |m: &mut QueryNextSequenceReceiveResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryNextSequenceReceiveResponse| { &m.proof_height },
            |m: &mut QueryNextSequenceReceiveResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryNextSequenceReceiveResponse>(
            "QueryNextSequenceReceiveResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryNextSequenceReceiveResponse {
    const NAME: &'static str = "QueryNextSequenceReceiveResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.next_sequence_receive = is.read_uint64()?;
                },
                18 => {
                    self.proof = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.next_sequence_receive != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.next_sequence_receive);
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.next_sequence_receive != 0 {
            os.write_uint64(1, self.next_sequence_receive)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryNextSequenceReceiveResponse {
        QueryNextSequenceReceiveResponse::new()
    }

    fn clear(&mut self) {
        self.next_sequence_receive = 0;
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryNextSequenceReceiveResponse {
        static instance: QueryNextSequenceReceiveResponse = QueryNextSequenceReceiveResponse {
            next_sequence_receive: 0,
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryNextSequenceReceiveResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryNextSequenceReceiveResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryNextSequenceReceiveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryNextSequenceReceiveResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fibc/core/channel/v1/query.proto\x12\x13ibc.core.channel.v1\x1a\x1f\
    ibc/core/client/v1/client.proto\x1a*cosmos/base/query/v1beta1/pagination\
    .proto\x1a!ibc/core/channel/v1/channel.proto\x1a\x1cgoogle/api/annotatio\
    ns.proto\x1a\x19google/protobuf/any.proto\x1a\x14gogoproto/gogo.proto\"M\
    \n\x13QueryChannelRequest\x12\x17\n\x07port_id\x18\x01\x20\x01(\tR\x06po\
    rtId\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelId\"\xa9\x01\n\
    \x14QueryChannelResponse\x126\n\x07channel\x18\x01\x20\x01(\x0b2\x1c.ibc\
    .core.channel.v1.ChannelR\x07channel\x12\x14\n\x05proof\x18\x02\x20\x01(\
    \x0cR\x05proof\x12C\n\x0cproof_height\x18\x03\x20\x01(\x0b2\x1a.ibc.core\
    .client.v1.HeightR\x0bproofHeightB\x04\xc8\xde\x1f\0\"^\n\x14QueryChanne\
    lsRequest\x12F\n\npagination\x18\x01\x20\x01(\x0b2&.cosmos.base.query.v1\
    beta1.PageRequestR\npagination\"\xde\x01\n\x15QueryChannelsResponse\x12B\
    \n\x08channels\x18\x01\x20\x03(\x0b2&.ibc.core.channel.v1.IdentifiedChan\
    nelR\x08channels\x12G\n\npagination\x18\x02\x20\x01(\x0b2'.cosmos.base.q\
    uery.v1beta1.PageResponseR\npagination\x128\n\x06height\x18\x03\x20\x01(\
    \x0b2\x1a.ibc.core.client.v1.HeightR\x06heightB\x04\xc8\xde\x1f\0\"\x88\
    \x01\n\x1eQueryConnectionChannelsRequest\x12\x1e\n\nconnection\x18\x01\
    \x20\x01(\tR\nconnection\x12F\n\npagination\x18\x02\x20\x01(\x0b2&.cosmo\
    s.base.query.v1beta1.PageRequestR\npagination\"\xe8\x01\n\x1fQueryConnec\
    tionChannelsResponse\x12B\n\x08channels\x18\x01\x20\x03(\x0b2&.ibc.core.\
    channel.v1.IdentifiedChannelR\x08channels\x12G\n\npagination\x18\x02\x20\
    \x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagination\x128\n\
    \x06height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x06heigh\
    tB\x04\xc8\xde\x1f\0\"X\n\x1eQueryChannelClientStateRequest\x12\x17\n\
    \x07port_id\x18\x01\x20\x01(\tR\x06portId\x12\x1d\n\nchannel_id\x18\x02\
    \x20\x01(\tR\tchannelId\"\xdf\x01\n\x1fQueryChannelClientStateResponse\
    \x12a\n\x17identified_client_state\x18\x01\x20\x01(\x0b2).ibc.core.clien\
    t.v1.IdentifiedClientStateR\x15identifiedClientState\x12\x14\n\x05proof\
    \x18\x02\x20\x01(\x0cR\x05proof\x12C\n\x0cproof_height\x18\x03\x20\x01(\
    \x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\x04\xc8\xde\x1f\0\"\
    \xad\x01\n!QueryChannelConsensusStateRequest\x12\x17\n\x07port_id\x18\
    \x01\x20\x01(\tR\x06portId\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\tR\tch\
    annelId\x12'\n\x0frevision_number\x18\x03\x20\x01(\x04R\x0erevisionNumbe\
    r\x12'\n\x0frevision_height\x18\x04\x20\x01(\x04R\x0erevisionHeight\"\
    \xdb\x01\n\"QueryChannelConsensusStateResponse\x12=\n\x0fconsensus_state\
    \x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x0econsensusState\x12\
    \x1b\n\tclient_id\x18\x02\x20\x01(\tR\x08clientId\x12\x14\n\x05proof\x18\
    \x03\x20\x01(\x0cR\x05proof\x12C\n\x0cproof_height\x18\x04\x20\x01(\x0b2\
    \x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\x04\xc8\xde\x1f\0\"r\n\
    \x1cQueryPacketCommitmentRequest\x12\x17\n\x07port_id\x18\x01\x20\x01(\t\
    R\x06portId\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelId\x12\x1a\
    \n\x08sequence\x18\x03\x20\x01(\x04R\x08sequence\"\x9a\x01\n\x1dQueryPac\
    ketCommitmentResponse\x12\x1e\n\ncommitment\x18\x01\x20\x01(\x0cR\ncommi\
    tment\x12\x14\n\x05proof\x18\x02\x20\x01(\x0cR\x05proof\x12C\n\x0cproof_\
    height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeig\
    htB\x04\xc8\xde\x1f\0\"\x9f\x01\n\x1dQueryPacketCommitmentsRequest\x12\
    \x17\n\x07port_id\x18\x01\x20\x01(\tR\x06portId\x12\x1d\n\nchannel_id\
    \x18\x02\x20\x01(\tR\tchannelId\x12F\n\npagination\x18\x03\x20\x01(\x0b2\
    &.cosmos.base.query.v1beta1.PageRequestR\npagination\"\xe7\x01\n\x1eQuer\
    yPacketCommitmentsResponse\x12B\n\x0bcommitments\x18\x01\x20\x03(\x0b2\
    \x20.ibc.core.channel.v1.PacketStateR\x0bcommitments\x12G\n\npagination\
    \x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npaginat\
    ion\x128\n\x06height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.Height\
    R\x06heightB\x04\xc8\xde\x1f\0\"o\n\x19QueryPacketReceiptRequest\x12\x17\
    \n\x07port_id\x18\x01\x20\x01(\tR\x06portId\x12\x1d\n\nchannel_id\x18\
    \x02\x20\x01(\tR\tchannelId\x12\x1a\n\x08sequence\x18\x03\x20\x01(\x04R\
    \x08sequence\"\x93\x01\n\x1aQueryPacketReceiptResponse\x12\x1a\n\x08rece\
    ived\x18\x02\x20\x01(\x08R\x08received\x12\x14\n\x05proof\x18\x03\x20\
    \x01(\x0cR\x05proof\x12C\n\x0cproof_height\x18\x04\x20\x01(\x0b2\x1a.ibc\
    .core.client.v1.HeightR\x0bproofHeightB\x04\xc8\xde\x1f\0\"w\n!QueryPack\
    etAcknowledgementRequest\x12\x17\n\x07port_id\x18\x01\x20\x01(\tR\x06por\
    tId\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelId\x12\x1a\n\x08se\
    quence\x18\x03\x20\x01(\x04R\x08sequence\"\xa9\x01\n\"QueryPacketAcknowl\
    edgementResponse\x12(\n\x0facknowledgement\x18\x01\x20\x01(\x0cR\x0fackn\
    owledgement\x12\x14\n\x05proof\x18\x02\x20\x01(\x0cR\x05proof\x12C\n\x0c\
    proof_height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bpro\
    ofHeightB\x04\xc8\xde\x1f\0\"\xe4\x01\n\"QueryPacketAcknowledgementsRequ\
    est\x12\x17\n\x07port_id\x18\x01\x20\x01(\tR\x06portId\x12\x1d\n\nchanne\
    l_id\x18\x02\x20\x01(\tR\tchannelId\x12F\n\npagination\x18\x03\x20\x01(\
    \x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagination\x12>\n\x1bpack\
    et_commitment_sequences\x18\x04\x20\x03(\x04R\x19packetCommitmentSequenc\
    es\"\xf6\x01\n#QueryPacketAcknowledgementsResponse\x12L\n\x10acknowledge\
    ments\x18\x01\x20\x03(\x0b2\x20.ibc.core.channel.v1.PacketStateR\x10ackn\
    owledgements\x12G\n\npagination\x18\x02\x20\x01(\x0b2'.cosmos.base.query\
    .v1beta1.PageResponseR\npagination\x128\n\x06height\x18\x03\x20\x01(\x0b\
    2\x1a.ibc.core.client.v1.HeightR\x06heightB\x04\xc8\xde\x1f\0\"\x97\x01\
    \n\x1dQueryUnreceivedPacketsRequest\x12\x17\n\x07port_id\x18\x01\x20\x01\
    (\tR\x06portId\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelId\x12>\
    \n\x1bpacket_commitment_sequences\x18\x03\x20\x03(\x04R\x19packetCommitm\
    entSequences\"x\n\x1eQueryUnreceivedPacketsResponse\x12\x1c\n\tsequences\
    \x18\x01\x20\x03(\x04R\tsequences\x128\n\x06height\x18\x02\x20\x01(\x0b2\
    \x1a.ibc.core.client.v1.HeightR\x06heightB\x04\xc8\xde\x1f\0\"\x86\x01\n\
    \x1aQueryUnreceivedAcksRequest\x12\x17\n\x07port_id\x18\x01\x20\x01(\tR\
    \x06portId\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelId\x120\n\
    \x14packet_ack_sequences\x18\x03\x20\x03(\x04R\x12packetAckSequences\"u\
    \n\x1bQueryUnreceivedAcksResponse\x12\x1c\n\tsequences\x18\x01\x20\x03(\
    \x04R\tsequences\x128\n\x06height\x18\x02\x20\x01(\x0b2\x1a.ibc.core.cli\
    ent.v1.HeightR\x06heightB\x04\xc8\xde\x1f\0\"Y\n\x1fQueryNextSequenceRec\
    eiveRequest\x12\x17\n\x07port_id\x18\x01\x20\x01(\tR\x06portId\x12\x1d\n\
    \nchannel_id\x18\x02\x20\x01(\tR\tchannelId\"\xb1\x01\n\x20QueryNextSequ\
    enceReceiveResponse\x122\n\x15next_sequence_receive\x18\x01\x20\x01(\x04\
    R\x13nextSequenceReceive\x12\x14\n\x05proof\x18\x02\x20\x01(\x0cR\x05pro\
    of\x12C\n\x0cproof_height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.H\
    eightR\x0bproofHeightB\x04\xc8\xde\x1f\02\x8b\x16\n\x05Query\x12\xa2\x01\
    \n\x07Channel\x12(.ibc.core.channel.v1.QueryChannelRequest\x1a).ibc.core\
    .channel.v1.QueryChannelResponse\"B\x82\xd3\xe4\x93\x02<\x12:/ibc/core/c\
    hannel/v1/channels/{channel_id}/ports/{port_id}\x12\x88\x01\n\x08Channel\
    s\x12).ibc.core.channel.v1.QueryChannelsRequest\x1a*.ibc.core.channel.v1\
    .QueryChannelsResponse\"%\x82\xd3\xe4\x93\x02\x1f\x12\x1d/ibc/core/chann\
    el/v1/channels\x12\xbf\x01\n\x12ConnectionChannels\x123.ibc.core.channel\
    .v1.QueryConnectionChannelsRequest\x1a4.ibc.core.channel.v1.QueryConnect\
    ionChannelsResponse\">\x82\xd3\xe4\x93\x028\x126/ibc/core/channel/v1/con\
    nections/{connection}/channels\x12\xd0\x01\n\x12ChannelClientState\x123.\
    ibc.core.channel.v1.QueryChannelClientStateRequest\x1a4.ibc.core.channel\
    .v1.QueryChannelClientStateResponse\"O\x82\xd3\xe4\x93\x02I\x12G/ibc/cor\
    e/channel/v1/channels/{channel_id}/ports/{port_id}/client_state\x12\x92\
    \x02\n\x15ChannelConsensusState\x126.ibc.core.channel.v1.QueryChannelCon\
    sensusStateRequest\x1a7.ibc.core.channel.v1.QueryChannelConsensusStateRe\
    sponse\"\x87\x01\x82\xd3\xe4\x93\x02\x80\x01\x12~/ibc/core/channel/v1/ch\
    annels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_n\
    umber}/height/{revision_height}\x12\xdb\x01\n\x10PacketCommitment\x121.i\
    bc.core.channel.v1.QueryPacketCommitmentRequest\x1a2.ibc.core.channel.v1\
    .QueryPacketCommitmentResponse\"`\x82\xd3\xe4\x93\x02Z\x12X/ibc/core/cha\
    nnel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequen\
    ce}\x12\xd3\x01\n\x11PacketCommitments\x122.ibc.core.channel.v1.QueryPac\
    ketCommitmentsRequest\x1a3.ibc.core.channel.v1.QueryPacketCommitmentsRes\
    ponse\"U\x82\xd3\xe4\x93\x02O\x12M/ibc/core/channel/v1/channels/{channel\
    _id}/ports/{port_id}/packet_commitments\x12\xcf\x01\n\rPacketReceipt\x12\
    ..ibc.core.channel.v1.QueryPacketReceiptRequest\x1a/.ibc.core.channel.v1\
    .QueryPacketReceiptResponse\"]\x82\xd3\xe4\x93\x02W\x12U/ibc/core/channe\
    l/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}\
    \x12\xe3\x01\n\x15PacketAcknowledgement\x126.ibc.core.channel.v1.QueryPa\
    cketAcknowledgementRequest\x1a7.ibc.core.channel.v1.QueryPacketAcknowled\
    gementResponse\"Y\x82\xd3\xe4\x93\x02S\x12Q/ibc/core/channel/v1/channels\
    /{channel_id}/ports/{port_id}/packet_acks/{sequence}\x12\xe7\x01\n\x16Pa\
    cketAcknowledgements\x127.ibc.core.channel.v1.QueryPacketAcknowledgement\
    sRequest\x1a8.ibc.core.channel.v1.QueryPacketAcknowledgementsResponse\"Z\
    \x82\xd3\xe4\x93\x02T\x12R/ibc/core/channel/v1/channels/{channel_id}/por\
    ts/{port_id}/packet_acknowledgements\x12\x86\x02\n\x11UnreceivedPackets\
    \x122.ibc.core.channel.v1.QueryUnreceivedPacketsRequest\x1a3.ibc.core.ch\
    annel.v1.QueryUnreceivedPacketsResponse\"\x87\x01\x82\xd3\xe4\x93\x02\
    \x80\x01\x12~/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/\
    packet_commitments/{packet_commitment_sequences}/unreceived_packets\x12\
    \xf1\x01\n\x0eUnreceivedAcks\x12/.ibc.core.channel.v1.QueryUnreceivedAck\
    sRequest\x1a0.ibc.core.channel.v1.QueryUnreceivedAcksResponse\"|\x82\xd3\
    \xe4\x93\x02v\x12t/ibc/core/channel/v1/channels/{channel_id}/ports/{port\
    _id}/packet_commitments/{packet_ack_sequences}/unreceived_acks\x12\xd4\
    \x01\n\x13NextSequenceReceive\x124.ibc.core.channel.v1.QueryNextSequence\
    ReceiveRequest\x1a5.ibc.core.channel.v1.QueryNextSequenceReceiveResponse\
    \"P\x82\xd3\xe4\x93\x02J\x12H/ibc/core/channel/v1/channels/{channel_id}/\
    ports/{port_id}/next_sequenceB;Z9github.com/cosmos/ibc-go/v3/modules/cor\
    e/04-channel/typesJ\x8df\n\x07\x12\x05\0\0\xf7\x02\x01\n\x08\n\x01\x0c\
    \x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x1c\n\x08\n\x01\x08\x12\
    \x03\x04\0P\n\t\n\x02\x08\x0b\x12\x03\x04\0P\n\t\n\x02\x03\0\x12\x03\x06\
    \0)\n\t\n\x02\x03\x01\x12\x03\x07\04\n\t\n\x02\x03\x02\x12\x03\x08\0+\n\
    \t\n\x02\x03\x03\x12\x03\t\0&\n\t\n\x02\x03\x04\x12\x03\n\0#\n\t\n\x02\
    \x03\x05\x12\x03\x0b\0\x1e\n=\n\x02\x06\0\x12\x04\x0e\0d\x01\x1a1\x20Que\
    ry\x20provides\x20defines\x20the\x20gRPC\x20querier\x20service\n\n\n\n\
    \x03\x06\0\x01\x12\x03\x0e\x08\r\n/\n\x04\x06\0\x02\0\x12\x04\x10\x02\
    \x12\x03\x1a!\x20Channel\x20queries\x20an\x20IBC\x20Channel.\n\n\x0c\n\
    \x05\x06\0\x02\0\x01\x12\x03\x10\x06\r\n\x0c\n\x05\x06\0\x02\0\x02\x12\
    \x03\x10\x0e!\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x10,@\n\x0c\n\x05\x06\
    \0\x02\0\x04\x12\x03\x11\x04`\n\x11\n\n\x06\0\x02\0\x04\xb0\xca\xbc\"\
    \x02\x12\x03\x11\x04`\nA\n\x04\x06\0\x02\x01\x12\x04\x15\x02\x17\x03\x1a\
    3\x20Channels\x20queries\x20all\x20the\x20IBC\x20channels\x20of\x20a\x20\
    chain.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x15\x06\x0e\n\x0c\n\x05\
    \x06\0\x02\x01\x02\x12\x03\x15\x0f#\n\x0c\n\x05\x06\0\x02\x01\x03\x12\
    \x03\x15.C\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03\x16\x04C\n\x11\n\n\x06\
    \0\x02\x01\x04\xb0\xca\xbc\"\x02\x12\x03\x16\x04C\n^\n\x04\x06\0\x02\x02\
    \x12\x04\x1b\x02\x1d\x03\x1aP\x20ConnectionChannels\x20queries\x20all\
    \x20the\x20channels\x20associated\x20with\x20a\x20connection\n\x20end.\n\
    \n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x1b\x06\x18\n\x0c\n\x05\x06\0\x02\
    \x02\x02\x12\x03\x1b\x197\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1bBa\n\
    \x0c\n\x05\x06\0\x02\x02\x04\x12\x03\x1c\x04\\\n\x11\n\n\x06\0\x02\x02\
    \x04\xb0\xca\xbc\"\x02\x12\x03\x1c\x04\\\n\x82\x01\n\x04\x06\0\x02\x03\
    \x12\x04!\x02$\x03\x1at\x20ChannelClientState\x20queries\x20for\x20the\
    \x20client\x20state\x20for\x20the\x20channel\x20associated\n\x20with\x20\
    the\x20provided\x20channel\x20identifiers.\n\n\x0c\n\x05\x06\0\x02\x03\
    \x01\x12\x03!\x06\x18\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03!\x197\n\x0c\
    \n\x05\x06\0\x02\x03\x03\x12\x03!Ba\n\r\n\x05\x06\0\x02\x03\x04\x12\x04\
    \"\x04#B\n\x12\n\n\x06\0\x02\x03\x04\xb0\xca\xbc\"\x02\x12\x04\"\x04#B\n\
    \x88\x01\n\x04\x06\0\x02\x04\x12\x04(\x02,\x03\x1az\x20ChannelConsensusS\
    tate\x20queries\x20for\x20the\x20consensus\x20state\x20for\x20the\x20cha\
    nnel\n\x20associated\x20with\x20the\x20provided\x20channel\x20identifier\
    s.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03(\x06\x1b\n\x0c\n\x05\x06\0\
    \x02\x04\x02\x12\x03(\x1c=\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03(Hj\n\r\
    \n\x05\x06\0\x02\x04\x04\x12\x04)\x04+P\n\x12\n\n\x06\0\x02\x04\x04\xb0\
    \xca\xbc\"\x02\x12\x04)\x04+P\nI\n\x04\x06\0\x02\x05\x12\x04/\x022\x03\
    \x1a;\x20PacketCommitment\x20queries\x20a\x20stored\x20packet\x20commitm\
    ent\x20hash.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03/\x06\x16\n\x0c\n\
    \x05\x06\0\x02\x05\x02\x12\x03/\x173\n\x0c\n\x05\x06\0\x02\x05\x03\x12\
    \x03/>[\n\r\n\x05\x06\0\x02\x05\x04\x12\x040\x041C\n\x12\n\n\x06\0\x02\
    \x05\x04\xb0\xca\xbc\"\x02\x12\x040\x041C\ng\n\x04\x06\0\x02\x06\x12\x04\
    6\x029\x03\x1aY\x20PacketCommitments\x20returns\x20all\x20the\x20packet\
    \x20commitments\x20hashes\x20associated\n\x20with\x20a\x20channel.\n\n\
    \x0c\n\x05\x06\0\x02\x06\x01\x12\x036\x06\x17\n\x0c\n\x05\x06\0\x02\x06\
    \x02\x12\x036\x185\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x036@^\n\r\n\x05\
    \x06\0\x02\x06\x04\x12\x047\x048H\n\x12\n\n\x06\0\x02\x06\x04\xb0\xca\
    \xbc\"\x02\x12\x047\x048H\nh\n\x04\x06\0\x02\x07\x12\x04=\x02@\x03\x1aZ\
    \x20PacketReceipt\x20queries\x20if\x20a\x20given\x20packet\x20sequence\
    \x20has\x20been\x20received\x20on\x20the\n\x20queried\x20chain\n\n\x0c\n\
    \x05\x06\0\x02\x07\x01\x12\x03=\x06\x13\n\x0c\n\x05\x06\0\x02\x07\x02\
    \x12\x03=\x14-\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03=8R\n\r\n\x05\x06\0\
    \x02\x07\x04\x12\x04>\x04?P\n\x12\n\n\x06\0\x02\x07\x04\xb0\xca\xbc\"\
    \x02\x12\x04>\x04?P\nS\n\x04\x06\0\x02\x08\x12\x04C\x02F\x03\x1aE\x20Pac\
    ketAcknowledgement\x20queries\x20a\x20stored\x20packet\x20acknowledgemen\
    t\x20hash.\n\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03C\x06\x1b\n\x0c\n\x05\
    \x06\0\x02\x08\x02\x12\x03C\x1c=\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03CH\
    j\n\r\n\x05\x06\0\x02\x08\x04\x12\x04D\x04EL\n\x12\n\n\x06\0\x02\x08\x04\
    \xb0\xca\xbc\"\x02\x12\x04D\x04EL\nj\n\x04\x06\0\x02\t\x12\x04J\x02M\x03\
    \x1a\\\x20PacketAcknowledgements\x20returns\x20all\x20the\x20packet\x20a\
    cknowledgements\x20associated\n\x20with\x20a\x20channel.\n\n\x0c\n\x05\
    \x06\0\x02\t\x01\x12\x03J\x06\x1c\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03J\
    \x1d?\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03JJm\n\r\n\x05\x06\0\x02\t\x04\
    \x12\x04K\x04LM\n\x12\n\n\x06\0\x02\t\x04\xb0\xca\xbc\"\x02\x12\x04K\x04\
    LM\nr\n\x04\x06\0\x02\n\x12\x04Q\x02U\x03\x1ad\x20UnreceivedPackets\x20r\
    eturns\x20all\x20the\x20unreceived\x20IBC\x20packets\x20associated\x20wi\
    th\x20a\n\x20channel\x20and\x20sequences.\n\n\x0c\n\x05\x06\0\x02\n\x01\
    \x12\x03Q\x06\x17\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03Q\x185\n\x0c\n\x05\
    \x06\0\x02\n\x03\x12\x03Q@^\n\r\n\x05\x06\0\x02\n\x04\x12\x04R\x04TV\n\
    \x12\n\n\x06\0\x02\n\x04\xb0\xca\xbc\"\x02\x12\x04R\x04TV\nx\n\x04\x06\0\
    \x02\x0b\x12\x04Y\x02]\x03\x1aj\x20UnreceivedAcks\x20returns\x20all\x20t\
    he\x20unreceived\x20IBC\x20acknowledgements\x20associated\n\x20with\x20a\
    \x20channel\x20and\x20sequences.\n\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03\
    Y\x06\x14\n\x0c\n\x05\x06\0\x02\x0b\x02\x12\x03Y\x15/\n\x0c\n\x05\x06\0\
    \x02\x0b\x03\x12\x03Y:U\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04Z\x04\\L\n\
    \x12\n\n\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x02\x12\x04Z\x04\\L\nZ\n\x04\
    \x06\0\x02\x0c\x12\x04`\x02c\x03\x1aL\x20NextSequenceReceive\x20returns\
    \x20the\x20next\x20receive\x20sequence\x20for\x20a\x20given\x20channel.\
    \n\n\x0c\n\x05\x06\0\x02\x0c\x01\x12\x03`\x06\x19\n\x0c\n\x05\x06\0\x02\
    \x0c\x02\x12\x03`\x1a9\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\x03`Dd\n\r\n\
    \x05\x06\0\x02\x0c\x04\x12\x04a\x04bC\n\x12\n\n\x06\0\x02\x0c\x04\xb0\
    \xca\xbc\"\x02\x12\x04a\x04bC\nV\n\x02\x04\0\x12\x04g\0l\x01\x1aJ\x20Que\
    ryChannelRequest\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/\
    Channel\x20RPC\x20method\n\n\n\n\x03\x04\0\x01\x12\x03g\x08\x1b\n%\n\x04\
    \x04\0\x02\0\x12\x03i\x02\x15\x1a\x18\x20port\x20unique\x20identifier\n\
    \n\x0c\n\x05\x04\0\x02\0\x05\x12\x03i\x02\x08\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03i\t\x10\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03i\x13\x14\n(\n\
    \x04\x04\0\x02\x01\x12\x03k\x02\x18\x1a\x1b\x20channel\x20unique\x20iden\
    tifier\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03k\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x01\x01\x12\x03k\t\x13\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03k\x16\
    \x17\n\xbc\x01\n\x02\x04\x01\x12\x04q\0x\x01\x1a\xaf\x01\x20QueryChannel\
    Response\x20is\x20the\x20response\x20type\x20for\x20the\x20Query/Channel\
    \x20RPC\x20method.\n\x20Besides\x20the\x20Channel\x20end,\x20it\x20inclu\
    des\x20a\x20proof\x20and\x20the\x20height\x20from\x20which\x20the\n\x20p\
    roof\x20was\x20retrieved.\n\n\n\n\x03\x04\x01\x01\x12\x03q\x08\x1c\n>\n\
    \x04\x04\x01\x02\0\x12\x03s\x02*\x1a1\x20channel\x20associated\x20with\
    \x20the\x20request\x20identifiers\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\
    \x03s\x02\x1d\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03s\x1e%\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03s()\n(\n\x04\x04\x01\x02\x01\x12\x03u\x02\x12\
    \x1a\x1b\x20merkle\x20proof\x20of\x20existence\n\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03u\x02\x07\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03u\x08\r\
    \n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03u\x10\x11\n6\n\x04\x04\x01\x02\
    \x02\x12\x03w\x02L\x1a)\x20height\x20at\x20which\x20the\x20proof\x20was\
    \x20retrieved\n\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03w\x02\x1b\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03w\x1c(\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03w+,\n\x0c\n\x05\x04\x01\x02\x02\x08\x12\x03w-K\n\x0f\n\x08\x04\
    \x01\x02\x02\x08\xe9\xfb\x03\x12\x03w.J\nX\n\x02\x04\x02\x12\x04{\0~\x01\
    \x1aL\x20QueryChannelsRequest\x20is\x20the\x20request\x20type\x20for\x20\
    the\x20Query/Channels\x20RPC\x20method\n\n\n\n\x03\x04\x02\x01\x12\x03{\
    \x08\x1c\n!\n\x04\x04\x02\x02\0\x12\x03}\x027\x1a\x14\x20pagination\x20r\
    equest\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03}\x02'\n\x0c\n\x05\x04\x02\
    \x02\0\x01\x12\x03}(2\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03}56\n]\n\x02\
    \x04\x03\x12\x06\x81\x01\0\x88\x01\x01\x1aO\x20QueryChannelsResponse\x20\
    is\x20the\x20response\x20type\x20for\x20the\x20Query/Channels\x20RPC\x20\
    method.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x81\x01\x08\x1d\n5\n\x04\x04\
    \x03\x02\0\x12\x04\x83\x01\x02>\x1a'\x20list\x20of\x20stored\x20channels\
    \x20of\x20the\x20chain.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x83\x01\
    \x02\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\x83\x01\x0b0\n\r\n\x05\x04\
    \x03\x02\0\x01\x12\x04\x83\x0119\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x83\
    \x01<=\n#\n\x04\x04\x03\x02\x01\x12\x04\x85\x01\x028\x1a\x15\x20paginati\
    on\x20response\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x85\x01\x02(\n\r\
    \n\x05\x04\x03\x02\x01\x01\x12\x04\x85\x01)3\n\r\n\x05\x04\x03\x02\x01\
    \x03\x12\x04\x85\x0167\n\"\n\x04\x04\x03\x02\x02\x12\x04\x87\x01\x02F\
    \x1a\x14\x20query\x20block\x20height\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\
    \x04\x87\x01\x02\x1b\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\x87\x01\x1c\"\
    \n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\x87\x01%&\n\r\n\x05\x04\x03\x02\
    \x02\x08\x12\x04\x87\x01'E\n\x10\n\x08\x04\x03\x02\x02\x08\xe9\xfb\x03\
    \x12\x04\x87\x01(D\nt\n\x02\x04\x04\x12\x06\x8c\x01\0\x91\x01\x01\x1af\
    \x20QueryConnectionChannelsRequest\x20is\x20the\x20request\x20type\x20fo\
    r\x20the\n\x20Query/QueryConnectionChannels\x20RPC\x20method\n\n\x0b\n\
    \x03\x04\x04\x01\x12\x04\x8c\x01\x08&\n,\n\x04\x04\x04\x02\0\x12\x04\x8e\
    \x01\x02\x18\x1a\x1e\x20connection\x20unique\x20identifier\n\n\r\n\x05\
    \x04\x04\x02\0\x05\x12\x04\x8e\x01\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\
    \x12\x04\x8e\x01\t\x13\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x8e\x01\x16\
    \x17\n\"\n\x04\x04\x04\x02\x01\x12\x04\x90\x01\x027\x1a\x14\x20paginatio\
    n\x20request\n\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\x90\x01\x02'\n\r\n\
    \x05\x04\x04\x02\x01\x01\x12\x04\x90\x01(2\n\r\n\x05\x04\x04\x02\x01\x03\
    \x12\x04\x90\x0156\nv\n\x02\x04\x05\x12\x06\x95\x01\0\x9c\x01\x01\x1ah\
    \x20QueryConnectionChannelsResponse\x20is\x20the\x20Response\x20type\x20\
    for\x20the\n\x20Query/QueryConnectionChannels\x20RPC\x20method\n\n\x0b\n\
    \x03\x04\x05\x01\x12\x04\x95\x01\x08'\n>\n\x04\x04\x05\x02\0\x12\x04\x97\
    \x01\x02>\x1a0\x20list\x20of\x20channels\x20associated\x20with\x20a\x20c\
    onnection.\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\x97\x01\x02\n\n\r\n\x05\
    \x04\x05\x02\0\x06\x12\x04\x97\x01\x0b0\n\r\n\x05\x04\x05\x02\0\x01\x12\
    \x04\x97\x0119\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x97\x01<=\n#\n\x04\
    \x04\x05\x02\x01\x12\x04\x99\x01\x028\x1a\x15\x20pagination\x20response\
    \n\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\x99\x01\x02(\n\r\n\x05\x04\x05\
    \x02\x01\x01\x12\x04\x99\x01)3\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x99\
    \x0167\n\"\n\x04\x04\x05\x02\x02\x12\x04\x9b\x01\x02F\x1a\x14\x20query\
    \x20block\x20height\n\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\x9b\x01\x02\
    \x1b\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\x9b\x01\x1c\"\n\r\n\x05\x04\
    \x05\x02\x02\x03\x12\x04\x9b\x01%&\n\r\n\x05\x04\x05\x02\x02\x08\x12\x04\
    \x9b\x01'E\n\x10\n\x08\x04\x05\x02\x02\x08\xe9\xfb\x03\x12\x04\x9b\x01(D\
    \nh\n\x02\x04\x06\x12\x06\xa0\x01\0\xa5\x01\x01\x1aZ\x20QueryChannelClie\
    ntStateRequest\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/Cl\
    ientState\n\x20RPC\x20method\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xa0\x01\
    \x08&\n&\n\x04\x04\x06\x02\0\x12\x04\xa2\x01\x02\x15\x1a\x18\x20port\x20\
    unique\x20identifier\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xa2\x01\x02\
    \x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xa2\x01\t\x10\n\r\n\x05\x04\x06\
    \x02\0\x03\x12\x04\xa2\x01\x13\x14\n)\n\x04\x04\x06\x02\x01\x12\x04\xa4\
    \x01\x02\x18\x1a\x1b\x20channel\x20unique\x20identifier\n\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xa4\x01\t\x13\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xa4\x01\x16\
    \x17\nv\n\x02\x04\x07\x12\x06\xa9\x01\0\xb0\x01\x01\x1ah\x20QueryChannel\
    ClientStateResponse\x20is\x20the\x20Response\x20type\x20for\x20the\n\x20\
    Query/QueryChannelClientState\x20RPC\x20method\n\n\x0b\n\x03\x04\x07\x01\
    \x12\x04\xa9\x01\x08'\n8\n\x04\x04\x07\x02\0\x12\x04\xab\x01\x02G\x1a*\
    \x20client\x20state\x20associated\x20with\x20the\x20channel\n\n\r\n\x05\
    \x04\x07\x02\0\x06\x12\x04\xab\x01\x02*\n\r\n\x05\x04\x07\x02\0\x01\x12\
    \x04\xab\x01+B\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xab\x01EF\n)\n\x04\
    \x04\x07\x02\x01\x12\x04\xad\x01\x02\x12\x1a\x1b\x20merkle\x20proof\x20o\
    f\x20existence\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xad\x01\x02\x07\n\
    \r\n\x05\x04\x07\x02\x01\x01\x12\x04\xad\x01\x08\r\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xad\x01\x10\x11\n7\n\x04\x04\x07\x02\x02\x12\x04\xaf\
    \x01\x02L\x1a)\x20height\x20at\x20which\x20the\x20proof\x20was\x20retrie\
    ved\n\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\xaf\x01\x02\x1b\n\r\n\x05\
    \x04\x07\x02\x02\x01\x12\x04\xaf\x01\x1c(\n\r\n\x05\x04\x07\x02\x02\x03\
    \x12\x04\xaf\x01+,\n\r\n\x05\x04\x07\x02\x02\x08\x12\x04\xaf\x01-K\n\x10\
    \n\x08\x04\x07\x02\x02\x08\xe9\xfb\x03\x12\x04\xaf\x01.J\nn\n\x02\x04\
    \x08\x12\x06\xb4\x01\0\xbd\x01\x01\x1a`\x20QueryChannelConsensusStateReq\
    uest\x20is\x20the\x20request\x20type\x20for\x20the\n\x20Query/ConsensusS\
    tate\x20RPC\x20method\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xb4\x01\x08)\n&\
    \n\x04\x04\x08\x02\0\x12\x04\xb6\x01\x02\x15\x1a\x18\x20port\x20unique\
    \x20identifier\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xb6\x01\x02\x08\n\r\
    \n\x05\x04\x08\x02\0\x01\x12\x04\xb6\x01\t\x10\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xb6\x01\x13\x14\n)\n\x04\x04\x08\x02\x01\x12\x04\xb8\x01\
    \x02\x18\x1a\x1b\x20channel\x20unique\x20identifier\n\n\r\n\x05\x04\x08\
    \x02\x01\x05\x12\x04\xb8\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\
    \x04\xb8\x01\t\x13\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xb8\x01\x16\x17\
    \n6\n\x04\x04\x08\x02\x02\x12\x04\xba\x01\x02\x1d\x1a(\x20revision\x20nu\
    mber\x20of\x20the\x20consensus\x20state\n\n\r\n\x05\x04\x08\x02\x02\x05\
    \x12\x04\xba\x01\x02\x08\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xba\x01\t\
    \x18\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xba\x01\x1b\x1c\n6\n\x04\x04\
    \x08\x02\x03\x12\x04\xbc\x01\x02\x1d\x1a(\x20revision\x20height\x20of\
    \x20the\x20consensus\x20state\n\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\
    \xbc\x01\x02\x08\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xbc\x01\t\x18\n\r\
    \n\x05\x04\x08\x02\x03\x03\x12\x04\xbc\x01\x1b\x1c\nv\n\x02\x04\t\x12\
    \x06\xc1\x01\0\xca\x01\x01\x1ah\x20QueryChannelClientStateResponse\x20is\
    \x20the\x20Response\x20type\x20for\x20the\n\x20Query/QueryChannelClientS\
    tate\x20RPC\x20method\n\n\x0b\n\x03\x04\t\x01\x12\x04\xc1\x01\x08*\n;\n\
    \x04\x04\t\x02\0\x12\x04\xc3\x01\x02*\x1a-\x20consensus\x20state\x20asso\
    ciated\x20with\x20the\x20channel\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xc3\
    \x01\x02\x15\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xc3\x01\x16%\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\xc3\x01()\n=\n\x04\x04\t\x02\x01\x12\x04\xc5\
    \x01\x02\x17\x1a/\x20client\x20ID\x20associated\x20with\x20the\x20consen\
    sus\x20state\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xc5\x01\x02\x08\n\r\n\
    \x05\x04\t\x02\x01\x01\x12\x04\xc5\x01\t\x12\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\xc5\x01\x15\x16\n)\n\x04\x04\t\x02\x02\x12\x04\xc7\x01\x02\x12\
    \x1a\x1b\x20merkle\x20proof\x20of\x20existence\n\n\r\n\x05\x04\t\x02\x02\
    \x05\x12\x04\xc7\x01\x02\x07\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xc7\x01\
    \x08\r\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xc7\x01\x10\x11\n7\n\x04\x04\
    \t\x02\x03\x12\x04\xc9\x01\x02L\x1a)\x20height\x20at\x20which\x20the\x20\
    proof\x20was\x20retrieved\n\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xc9\x01\
    \x02\x1b\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xc9\x01\x1c(\n\r\n\x05\x04\
    \t\x02\x03\x03\x12\x04\xc9\x01+,\n\r\n\x05\x04\t\x02\x03\x08\x12\x04\xc9\
    \x01-K\n\x10\n\x08\x04\t\x02\x03\x08\xe9\xfb\x03\x12\x04\xc9\x01.J\nk\n\
    \x02\x04\n\x12\x06\xce\x01\0\xd5\x01\x01\x1a]\x20QueryPacketCommitmentRe\
    quest\x20is\x20the\x20request\x20type\x20for\x20the\n\x20Query/PacketCom\
    mitment\x20RPC\x20method\n\n\x0b\n\x03\x04\n\x01\x12\x04\xce\x01\x08$\n&\
    \n\x04\x04\n\x02\0\x12\x04\xd0\x01\x02\x15\x1a\x18\x20port\x20unique\x20\
    identifier\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xd0\x01\x02\x08\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\xd0\x01\t\x10\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \xd0\x01\x13\x14\n)\n\x04\x04\n\x02\x01\x12\x04\xd2\x01\x02\x18\x1a\x1b\
    \x20channel\x20unique\x20identifier\n\n\r\n\x05\x04\n\x02\x01\x05\x12\
    \x04\xd2\x01\x02\x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xd2\x01\t\x13\n\
    \r\n\x05\x04\n\x02\x01\x03\x12\x04\xd2\x01\x16\x17\n\x1f\n\x04\x04\n\x02\
    \x02\x12\x04\xd4\x01\x02\x16\x1a\x11\x20packet\x20sequence\n\n\r\n\x05\
    \x04\n\x02\x02\x05\x12\x04\xd4\x01\x02\x08\n\r\n\x05\x04\n\x02\x02\x01\
    \x12\x04\xd4\x01\t\x11\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xd4\x01\x14\
    \x15\n\xad\x01\n\x02\x04\x0b\x12\x06\xda\x01\0\xe1\x01\x01\x1a\x9e\x01\
    \x20QueryPacketCommitmentResponse\x20defines\x20the\x20client\x20query\
    \x20response\x20for\x20a\x20packet\n\x20which\x20also\x20includes\x20a\
    \x20proof\x20and\x20the\x20height\x20from\x20which\x20the\x20proof\x20wa\
    s\n\x20retrieved\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xda\x01\x08%\n9\n\x04\
    \x04\x0b\x02\0\x12\x04\xdc\x01\x02\x17\x1a+\x20packet\x20associated\x20w\
    ith\x20the\x20request\x20fields\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\
    \xdc\x01\x02\x07\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xdc\x01\x08\x12\n\r\
    \n\x05\x04\x0b\x02\0\x03\x12\x04\xdc\x01\x15\x16\n)\n\x04\x04\x0b\x02\
    \x01\x12\x04\xde\x01\x02\x12\x1a\x1b\x20merkle\x20proof\x20of\x20existen\
    ce\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xde\x01\x02\x07\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\xde\x01\x08\r\n\r\n\x05\x04\x0b\x02\x01\x03\x12\
    \x04\xde\x01\x10\x11\n7\n\x04\x04\x0b\x02\x02\x12\x04\xe0\x01\x02L\x1a)\
    \x20height\x20at\x20which\x20the\x20proof\x20was\x20retrieved\n\n\r\n\
    \x05\x04\x0b\x02\x02\x06\x12\x04\xe0\x01\x02\x1b\n\r\n\x05\x04\x0b\x02\
    \x02\x01\x12\x04\xe0\x01\x1c(\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xe0\
    \x01+,\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\xe0\x01-K\n\x10\n\x08\x04\
    \x0b\x02\x02\x08\xe9\xfb\x03\x12\x04\xe0\x01.J\nr\n\x02\x04\x0c\x12\x06\
    \xe5\x01\0\xec\x01\x01\x1ad\x20QueryPacketCommitmentsRequest\x20is\x20th\
    e\x20request\x20type\x20for\x20the\n\x20Query/QueryPacketCommitments\x20\
    RPC\x20method\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xe5\x01\x08%\n&\n\x04\
    \x04\x0c\x02\0\x12\x04\xe7\x01\x02\x15\x1a\x18\x20port\x20unique\x20iden\
    tifier\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xe7\x01\x02\x08\n\r\n\x05\
    \x04\x0c\x02\0\x01\x12\x04\xe7\x01\t\x10\n\r\n\x05\x04\x0c\x02\0\x03\x12\
    \x04\xe7\x01\x13\x14\n)\n\x04\x04\x0c\x02\x01\x12\x04\xe9\x01\x02\x18\
    \x1a\x1b\x20channel\x20unique\x20identifier\n\n\r\n\x05\x04\x0c\x02\x01\
    \x05\x12\x04\xe9\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xe9\
    \x01\t\x13\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xe9\x01\x16\x17\n\"\n\
    \x04\x04\x0c\x02\x02\x12\x04\xeb\x01\x027\x1a\x14\x20pagination\x20reque\
    st\n\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\xeb\x01\x02'\n\r\n\x05\x04\
    \x0c\x02\x02\x01\x12\x04\xeb\x01(2\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\
    \xeb\x0156\ns\n\x02\x04\r\x12\x06\xf0\x01\0\xf6\x01\x01\x1ae\x20QueryPac\
    ketCommitmentsResponse\x20is\x20the\x20request\x20type\x20for\x20the\n\
    \x20Query/QueryPacketCommitments\x20RPC\x20method\n\n\x0b\n\x03\x04\r\
    \x01\x12\x04\xf0\x01\x08&\n\x0c\n\x04\x04\r\x02\0\x12\x04\xf1\x01\x02;\n\
    \r\n\x05\x04\r\x02\0\x04\x12\x04\xf1\x01\x02\n\n\r\n\x05\x04\r\x02\0\x06\
    \x12\x04\xf1\x01\x0b*\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xf1\x01+6\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xf1\x019:\n#\n\x04\x04\r\x02\x01\x12\x04\
    \xf3\x01\x028\x1a\x15\x20pagination\x20response\n\n\r\n\x05\x04\r\x02\
    \x01\x06\x12\x04\xf3\x01\x02(\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xf3\
    \x01)3\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xf3\x0167\n\"\n\x04\x04\r\x02\
    \x02\x12\x04\xf5\x01\x02F\x1a\x14\x20query\x20block\x20height\n\n\r\n\
    \x05\x04\r\x02\x02\x06\x12\x04\xf5\x01\x02\x1b\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\xf5\x01\x1c\"\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xf5\x01%&\
    \n\r\n\x05\x04\r\x02\x02\x08\x12\x04\xf5\x01'E\n\x10\n\x08\x04\r\x02\x02\
    \x08\xe9\xfb\x03\x12\x04\xf5\x01(D\ne\n\x02\x04\x0e\x12\x06\xfa\x01\0\
    \x81\x02\x01\x1aW\x20QueryPacketReceiptRequest\x20is\x20the\x20request\
    \x20type\x20for\x20the\n\x20Query/PacketReceipt\x20RPC\x20method\n\n\x0b\
    \n\x03\x04\x0e\x01\x12\x04\xfa\x01\x08!\n&\n\x04\x04\x0e\x02\0\x12\x04\
    \xfc\x01\x02\x15\x1a\x18\x20port\x20unique\x20identifier\n\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\xfc\x01\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\xfc\x01\t\x10\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xfc\x01\x13\x14\n\
    )\n\x04\x04\x0e\x02\x01\x12\x04\xfe\x01\x02\x18\x1a\x1b\x20channel\x20un\
    ique\x20identifier\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xfe\x01\x02\
    \x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xfe\x01\t\x13\n\r\n\x05\x04\
    \x0e\x02\x01\x03\x12\x04\xfe\x01\x16\x17\n\x1f\n\x04\x04\x0e\x02\x02\x12\
    \x04\x80\x02\x02\x16\x1a\x11\x20packet\x20sequence\n\n\r\n\x05\x04\x0e\
    \x02\x02\x05\x12\x04\x80\x02\x02\x08\n\r\n\x05\x04\x0e\x02\x02\x01\x12\
    \x04\x80\x02\t\x11\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x80\x02\x14\x15\
    \n\xb3\x01\n\x02\x04\x0f\x12\x06\x86\x02\0\x8d\x02\x01\x1a\xa4\x01\x20Qu\
    eryPacketReceiptResponse\x20defines\x20the\x20client\x20query\x20respons\
    e\x20for\x20a\x20packet\n\x20receipt\x20which\x20also\x20includes\x20a\
    \x20proof,\x20and\x20the\x20height\x20from\x20which\x20the\x20proof\x20w\
    as\n\x20retrieved\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x86\x02\x08\"\n2\n\
    \x04\x04\x0f\x02\0\x12\x04\x88\x02\x02\x14\x1a$\x20success\x20flag\x20fo\
    r\x20if\x20receipt\x20exists\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x88\
    \x02\x02\x06\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x88\x02\x07\x0f\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\x88\x02\x12\x13\n)\n\x04\x04\x0f\x02\x01\
    \x12\x04\x8a\x02\x02\x12\x1a\x1b\x20merkle\x20proof\x20of\x20existence\n\
    \n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x8a\x02\x02\x07\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\x8a\x02\x08\r\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\
    \x8a\x02\x10\x11\n7\n\x04\x04\x0f\x02\x02\x12\x04\x8c\x02\x02L\x1a)\x20h\
    eight\x20at\x20which\x20the\x20proof\x20was\x20retrieved\n\n\r\n\x05\x04\
    \x0f\x02\x02\x06\x12\x04\x8c\x02\x02\x1b\n\r\n\x05\x04\x0f\x02\x02\x01\
    \x12\x04\x8c\x02\x1c(\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x8c\x02+,\n\
    \r\n\x05\x04\x0f\x02\x02\x08\x12\x04\x8c\x02-K\n\x10\n\x08\x04\x0f\x02\
    \x02\x08\xe9\xfb\x03\x12\x04\x8c\x02.J\nu\n\x02\x04\x10\x12\x06\x91\x02\
    \0\x98\x02\x01\x1ag\x20QueryPacketAcknowledgementRequest\x20is\x20the\
    \x20request\x20type\x20for\x20the\n\x20Query/PacketAcknowledgement\x20RP\
    C\x20method\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x91\x02\x08)\n&\n\x04\x04\
    \x10\x02\0\x12\x04\x93\x02\x02\x15\x1a\x18\x20port\x20unique\x20identifi\
    er\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x93\x02\x02\x08\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\x93\x02\t\x10\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \x93\x02\x13\x14\n)\n\x04\x04\x10\x02\x01\x12\x04\x95\x02\x02\x18\x1a\
    \x1b\x20channel\x20unique\x20identifier\n\n\r\n\x05\x04\x10\x02\x01\x05\
    \x12\x04\x95\x02\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x95\x02\t\
    \x13\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x95\x02\x16\x17\n\x1f\n\x04\
    \x04\x10\x02\x02\x12\x04\x97\x02\x02\x16\x1a\x11\x20packet\x20sequence\n\
    \n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\x97\x02\x02\x08\n\r\n\x05\x04\x10\
    \x02\x02\x01\x12\x04\x97\x02\t\x11\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\
    \x97\x02\x14\x15\n\xb2\x01\n\x02\x04\x11\x12\x06\x9d\x02\0\xa4\x02\x01\
    \x1a\xa3\x01\x20QueryPacketAcknowledgementResponse\x20defines\x20the\x20\
    client\x20query\x20response\x20for\x20a\n\x20packet\x20which\x20also\x20\
    includes\x20a\x20proof\x20and\x20the\x20height\x20from\x20which\x20the\n\
    \x20proof\x20was\x20retrieved\n\n\x0b\n\x03\x04\x11\x01\x12\x04\x9d\x02\
    \x08*\n9\n\x04\x04\x11\x02\0\x12\x04\x9f\x02\x02\x1c\x1a+\x20packet\x20a\
    ssociated\x20with\x20the\x20request\x20fields\n\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\x9f\x02\x02\x07\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x9f\x02\
    \x08\x17\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x9f\x02\x1a\x1b\n)\n\x04\
    \x04\x11\x02\x01\x12\x04\xa1\x02\x02\x12\x1a\x1b\x20merkle\x20proof\x20o\
    f\x20existence\n\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xa1\x02\x02\x07\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\xa1\x02\x08\r\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xa1\x02\x10\x11\n7\n\x04\x04\x11\x02\x02\x12\x04\xa3\
    \x02\x02L\x1a)\x20height\x20at\x20which\x20the\x20proof\x20was\x20retrie\
    ved\n\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xa3\x02\x02\x1b\n\r\n\x05\
    \x04\x11\x02\x02\x01\x12\x04\xa3\x02\x1c(\n\r\n\x05\x04\x11\x02\x02\x03\
    \x12\x04\xa3\x02+,\n\r\n\x05\x04\x11\x02\x02\x08\x12\x04\xa3\x02-K\n\x10\
    \n\x08\x04\x11\x02\x02\x08\xe9\xfb\x03\x12\x04\xa3\x02.J\nw\n\x02\x04\
    \x12\x12\x06\xa8\x02\0\xb1\x02\x01\x1ai\x20QueryPacketAcknowledgementsRe\
    quest\x20is\x20the\x20request\x20type\x20for\x20the\n\x20Query/QueryPack\
    etCommitments\x20RPC\x20method\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xa8\x02\
    \x08*\n&\n\x04\x04\x12\x02\0\x12\x04\xaa\x02\x02\x15\x1a\x18\x20port\x20\
    unique\x20identifier\n\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xaa\x02\x02\
    \x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xaa\x02\t\x10\n\r\n\x05\x04\x12\
    \x02\0\x03\x12\x04\xaa\x02\x13\x14\n)\n\x04\x04\x12\x02\x01\x12\x04\xac\
    \x02\x02\x18\x1a\x1b\x20channel\x20unique\x20identifier\n\n\r\n\x05\x04\
    \x12\x02\x01\x05\x12\x04\xac\x02\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\
    \x12\x04\xac\x02\t\x13\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xac\x02\x16\
    \x17\n\"\n\x04\x04\x12\x02\x02\x12\x04\xae\x02\x027\x1a\x14\x20paginatio\
    n\x20request\n\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xae\x02\x02'\n\r\n\
    \x05\x04\x12\x02\x02\x01\x12\x04\xae\x02(2\n\r\n\x05\x04\x12\x02\x02\x03\
    \x12\x04\xae\x0256\n(\n\x04\x04\x12\x02\x03\x12\x04\xb0\x02\x022\x1a\x1a\
    \x20list\x20of\x20packet\x20sequences\n\n\r\n\x05\x04\x12\x02\x03\x04\
    \x12\x04\xb0\x02\x02\n\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xb0\x02\x0b\
    \x11\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xb0\x02\x12-\n\r\n\x05\x04\
    \x12\x02\x03\x03\x12\x04\xb0\x0201\n|\n\x02\x04\x13\x12\x06\xb5\x02\0\
    \xbb\x02\x01\x1an\x20QueryPacketAcknowledgemetsResponse\x20is\x20the\x20\
    request\x20type\x20for\x20the\n\x20Query/QueryPacketAcknowledgements\x20\
    RPC\x20method\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xb5\x02\x08+\n\x0c\n\x04\
    \x04\x13\x02\0\x12\x04\xb6\x02\x02@\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\
    \xb6\x02\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xb6\x02\x0b*\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xb6\x02+;\n\r\n\x05\x04\x13\x02\0\x03\x12\
    \x04\xb6\x02>?\n#\n\x04\x04\x13\x02\x01\x12\x04\xb8\x02\x028\x1a\x15\x20\
    pagination\x20response\n\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\xb8\x02\
    \x02(\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xb8\x02)3\n\r\n\x05\x04\x13\
    \x02\x01\x03\x12\x04\xb8\x0267\n\"\n\x04\x04\x13\x02\x02\x12\x04\xba\x02\
    \x02F\x1a\x14\x20query\x20block\x20height\n\n\r\n\x05\x04\x13\x02\x02\
    \x06\x12\x04\xba\x02\x02\x1b\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xba\
    \x02\x1c\"\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xba\x02%&\n\r\n\x05\x04\
    \x13\x02\x02\x08\x12\x04\xba\x02'E\n\x10\n\x08\x04\x13\x02\x02\x08\xe9\
    \xfb\x03\x12\x04\xba\x02(D\nm\n\x02\x04\x14\x12\x06\xbf\x02\0\xc6\x02\
    \x01\x1a_\x20QueryUnreceivedPacketsRequest\x20is\x20the\x20request\x20ty\
    pe\x20for\x20the\n\x20Query/UnreceivedPackets\x20RPC\x20method\n\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xbf\x02\x08%\n&\n\x04\x04\x14\x02\0\x12\x04\xc1\
    \x02\x02\x15\x1a\x18\x20port\x20unique\x20identifier\n\n\r\n\x05\x04\x14\
    \x02\0\x05\x12\x04\xc1\x02\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\
    \xc1\x02\t\x10\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xc1\x02\x13\x14\n)\n\
    \x04\x04\x14\x02\x01\x12\x04\xc3\x02\x02\x18\x1a\x1b\x20channel\x20uniqu\
    e\x20identifier\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xc3\x02\x02\x08\
    \n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xc3\x02\t\x13\n\r\n\x05\x04\x14\
    \x02\x01\x03\x12\x04\xc3\x02\x16\x17\n(\n\x04\x04\x14\x02\x02\x12\x04\
    \xc5\x02\x022\x1a\x1a\x20list\x20of\x20packet\x20sequences\n\n\r\n\x05\
    \x04\x14\x02\x02\x04\x12\x04\xc5\x02\x02\n\n\r\n\x05\x04\x14\x02\x02\x05\
    \x12\x04\xc5\x02\x0b\x11\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xc5\x02\
    \x12-\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xc5\x0201\ny\n\x02\x04\x15\
    \x12\x06\xca\x02\0\xcf\x02\x01\x1ak\x20QueryUnreceivedPacketsResponse\
    \x20is\x20the\x20response\x20type\x20for\x20the\n\x20Query/UnreceivedPac\
    ketCommitments\x20RPC\x20method\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xca\
    \x02\x08&\n3\n\x04\x04\x15\x02\0\x12\x04\xcc\x02\x02\x20\x1a%\x20list\
    \x20of\x20unreceived\x20packet\x20sequences\n\n\r\n\x05\x04\x15\x02\0\
    \x04\x12\x04\xcc\x02\x02\n\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xcc\x02\
    \x0b\x11\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xcc\x02\x12\x1b\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\xcc\x02\x1e\x1f\n\"\n\x04\x04\x15\x02\x01\x12\
    \x04\xce\x02\x02F\x1a\x14\x20query\x20block\x20height\n\n\r\n\x05\x04\
    \x15\x02\x01\x06\x12\x04\xce\x02\x02\x1b\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\xce\x02\x1c\"\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xce\x02%&\n\
    \r\n\x05\x04\x15\x02\x01\x08\x12\x04\xce\x02'E\n\x10\n\x08\x04\x15\x02\
    \x01\x08\xe9\xfb\x03\x12\x04\xce\x02(D\n`\n\x02\x04\x16\x12\x06\xd3\x02\
    \0\xda\x02\x01\x1aR\x20QueryUnreceivedAcks\x20is\x20the\x20request\x20ty\
    pe\x20for\x20the\n\x20Query/UnreceivedAcks\x20RPC\x20method\n\n\x0b\n\
    \x03\x04\x16\x01\x12\x04\xd3\x02\x08\"\n&\n\x04\x04\x16\x02\0\x12\x04\
    \xd5\x02\x02\x15\x1a\x18\x20port\x20unique\x20identifier\n\n\r\n\x05\x04\
    \x16\x02\0\x05\x12\x04\xd5\x02\x02\x08\n\r\n\x05\x04\x16\x02\0\x01\x12\
    \x04\xd5\x02\t\x10\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xd5\x02\x13\x14\n\
    )\n\x04\x04\x16\x02\x01\x12\x04\xd7\x02\x02\x18\x1a\x1b\x20channel\x20un\
    ique\x20identifier\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xd7\x02\x02\
    \x08\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xd7\x02\t\x13\n\r\n\x05\x04\
    \x16\x02\x01\x03\x12\x04\xd7\x02\x16\x17\n1\n\x04\x04\x16\x02\x02\x12\
    \x04\xd9\x02\x02+\x1a#\x20list\x20of\x20acknowledgement\x20sequences\n\n\
    \r\n\x05\x04\x16\x02\x02\x04\x12\x04\xd9\x02\x02\n\n\r\n\x05\x04\x16\x02\
    \x02\x05\x12\x04\xd9\x02\x0b\x11\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\
    \xd9\x02\x12&\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xd9\x02)*\ni\n\x02\
    \x04\x17\x12\x06\xde\x02\0\xe3\x02\x01\x1a[\x20QueryUnreceivedAcksRespon\
    se\x20is\x20the\x20response\x20type\x20for\x20the\n\x20Query/UnreceivedA\
    cks\x20RPC\x20method\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xde\x02\x08#\n<\n\
    \x04\x04\x17\x02\0\x12\x04\xe0\x02\x02\x20\x1a.\x20list\x20of\x20unrecei\
    ved\x20acknowledgement\x20sequences\n\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xe0\x02\x02\n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xe0\x02\x0b\x11\n\
    \r\n\x05\x04\x17\x02\0\x01\x12\x04\xe0\x02\x12\x1b\n\r\n\x05\x04\x17\x02\
    \0\x03\x12\x04\xe0\x02\x1e\x1f\n\"\n\x04\x04\x17\x02\x01\x12\x04\xe2\x02\
    \x02F\x1a\x14\x20query\x20block\x20height\n\n\r\n\x05\x04\x17\x02\x01\
    \x06\x12\x04\xe2\x02\x02\x1b\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xe2\
    \x02\x1c\"\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xe2\x02%&\n\r\n\x05\x04\
    \x17\x02\x01\x08\x12\x04\xe2\x02'E\n\x10\n\x08\x04\x17\x02\x01\x08\xe9\
    \xfb\x03\x12\x04\xe2\x02(D\n}\n\x02\x04\x18\x12\x06\xe7\x02\0\xec\x02\
    \x01\x1ao\x20QueryNextSequenceReceiveRequest\x20is\x20the\x20request\x20\
    type\x20for\x20the\n\x20Query/QueryNextSequenceReceiveRequest\x20RPC\x20\
    method\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xe7\x02\x08'\n&\n\x04\x04\x18\
    \x02\0\x12\x04\xe9\x02\x02\x15\x1a\x18\x20port\x20unique\x20identifier\n\
    \n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xe9\x02\x02\x08\n\r\n\x05\x04\x18\
    \x02\0\x01\x12\x04\xe9\x02\t\x10\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xe9\
    \x02\x13\x14\n)\n\x04\x04\x18\x02\x01\x12\x04\xeb\x02\x02\x18\x1a\x1b\
    \x20channel\x20unique\x20identifier\n\n\r\n\x05\x04\x18\x02\x01\x05\x12\
    \x04\xeb\x02\x02\x08\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xeb\x02\t\x13\
    \n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xeb\x02\x16\x17\nt\n\x02\x04\x19\
    \x12\x06\xf0\x02\0\xf7\x02\x01\x1af\x20QuerySequenceResponse\x20is\x20th\
    e\x20request\x20type\x20for\x20the\n\x20Query/QueryNextSequenceReceiveRe\
    sponse\x20RPC\x20method\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xf0\x02\x08(\n\
    ,\n\x04\x04\x19\x02\0\x12\x04\xf2\x02\x02#\x1a\x1e\x20next\x20sequence\
    \x20receive\x20number\n\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xf2\x02\x02\
    \x08\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xf2\x02\t\x1e\n\r\n\x05\x04\x19\
    \x02\0\x03\x12\x04\xf2\x02!\"\n)\n\x04\x04\x19\x02\x01\x12\x04\xf4\x02\
    \x02\x12\x1a\x1b\x20merkle\x20proof\x20of\x20existence\n\n\r\n\x05\x04\
    \x19\x02\x01\x05\x12\x04\xf4\x02\x02\x07\n\r\n\x05\x04\x19\x02\x01\x01\
    \x12\x04\xf4\x02\x08\r\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xf4\x02\x10\
    \x11\n7\n\x04\x04\x19\x02\x02\x12\x04\xf6\x02\x02L\x1a)\x20height\x20at\
    \x20which\x20the\x20proof\x20was\x20retrieved\n\n\r\n\x05\x04\x19\x02\
    \x02\x06\x12\x04\xf6\x02\x02\x1b\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\
    \xf6\x02\x1c(\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xf6\x02+,\n\r\n\x05\
    \x04\x19\x02\x02\x08\x12\x04\xf6\x02-K\n\x10\n\x08\x04\x19\x02\x02\x08\
    \xe9\xfb\x03\x12\x04\xf6\x02.Jb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::client::file_descriptor().clone());
            deps.push(super::pagination::file_descriptor().clone());
            deps.push(super::channel::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(26);
            messages.push(QueryChannelRequest::generated_message_descriptor_data());
            messages.push(QueryChannelResponse::generated_message_descriptor_data());
            messages.push(QueryChannelsRequest::generated_message_descriptor_data());
            messages.push(QueryChannelsResponse::generated_message_descriptor_data());
            messages.push(QueryConnectionChannelsRequest::generated_message_descriptor_data());
            messages.push(QueryConnectionChannelsResponse::generated_message_descriptor_data());
            messages.push(QueryChannelClientStateRequest::generated_message_descriptor_data());
            messages.push(QueryChannelClientStateResponse::generated_message_descriptor_data());
            messages.push(QueryChannelConsensusStateRequest::generated_message_descriptor_data());
            messages.push(QueryChannelConsensusStateResponse::generated_message_descriptor_data());
            messages.push(QueryPacketCommitmentRequest::generated_message_descriptor_data());
            messages.push(QueryPacketCommitmentResponse::generated_message_descriptor_data());
            messages.push(QueryPacketCommitmentsRequest::generated_message_descriptor_data());
            messages.push(QueryPacketCommitmentsResponse::generated_message_descriptor_data());
            messages.push(QueryPacketReceiptRequest::generated_message_descriptor_data());
            messages.push(QueryPacketReceiptResponse::generated_message_descriptor_data());
            messages.push(QueryPacketAcknowledgementRequest::generated_message_descriptor_data());
            messages.push(QueryPacketAcknowledgementResponse::generated_message_descriptor_data());
            messages.push(QueryPacketAcknowledgementsRequest::generated_message_descriptor_data());
            messages.push(QueryPacketAcknowledgementsResponse::generated_message_descriptor_data());
            messages.push(QueryUnreceivedPacketsRequest::generated_message_descriptor_data());
            messages.push(QueryUnreceivedPacketsResponse::generated_message_descriptor_data());
            messages.push(QueryUnreceivedAcksRequest::generated_message_descriptor_data());
            messages.push(QueryUnreceivedAcksResponse::generated_message_descriptor_data());
            messages.push(QueryNextSequenceReceiveRequest::generated_message_descriptor_data());
            messages.push(QueryNextSequenceReceiveResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
