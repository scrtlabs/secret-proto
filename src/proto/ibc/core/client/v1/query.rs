// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ibc/core/client/v1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  QueryClientStateRequest is the request type for the Query/ClientState RPC
///  method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientStateRequest)
pub struct QueryClientStateRequest {
    // message fields
    ///  client state unique identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStateRequest.client_id)
    pub client_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientStateRequest {
    fn default() -> &'a QueryClientStateRequest {
        <QueryClientStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientStateRequest {
    pub fn new() -> QueryClientStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &QueryClientStateRequest| { &m.client_id },
            |m: &mut QueryClientStateRequest| { &mut m.client_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientStateRequest>(
            "QueryClientStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientStateRequest {
    const NAME: &'static str = "QueryClientStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientStateRequest {
        QueryClientStateRequest::new()
    }

    fn clear(&mut self) {
        self.client_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientStateRequest {
        static instance: QueryClientStateRequest = QueryClientStateRequest {
            client_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryClientStateResponse is the response type for the Query/ClientState RPC
///  method. Besides the client state, it includes a proof and the height from
///  which the proof was retrieved.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientStateResponse)
pub struct QueryClientStateResponse {
    // message fields
    ///  client state associated with the request identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStateResponse.client_state)
    pub client_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStateResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStateResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientStateResponse {
    fn default() -> &'a QueryClientStateResponse {
        <QueryClientStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientStateResponse {
    pub fn new() -> QueryClientStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "client_state",
            |m: &QueryClientStateResponse| { &m.client_state },
            |m: &mut QueryClientStateResponse| { &mut m.client_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryClientStateResponse| { &m.proof },
            |m: &mut QueryClientStateResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryClientStateResponse| { &m.proof_height },
            |m: &mut QueryClientStateResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientStateResponse>(
            "QueryClientStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientStateResponse {
    const NAME: &'static str = "QueryClientStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.client_state)?;
                },
                18 => {
                    self.proof = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientStateResponse {
        QueryClientStateResponse::new()
    }

    fn clear(&mut self) {
        self.client_state.clear();
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientStateResponse {
        static instance: QueryClientStateResponse = QueryClientStateResponse {
            client_state: ::protobuf::MessageField::none(),
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryClientStatesRequest is the request type for the Query/ClientStates RPC
///  method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientStatesRequest)
pub struct QueryClientStatesRequest {
    // message fields
    ///  pagination request
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStatesRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientStatesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientStatesRequest {
    fn default() -> &'a QueryClientStatesRequest {
        <QueryClientStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientStatesRequest {
    pub fn new() -> QueryClientStatesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryClientStatesRequest| { &m.pagination },
            |m: &mut QueryClientStatesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientStatesRequest>(
            "QueryClientStatesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientStatesRequest {
    const NAME: &'static str = "QueryClientStatesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientStatesRequest {
        QueryClientStatesRequest::new()
    }

    fn clear(&mut self) {
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientStatesRequest {
        static instance: QueryClientStatesRequest = QueryClientStatesRequest {
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientStatesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientStatesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientStatesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryClientStatesResponse is the response type for the Query/ClientStates RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientStatesResponse)
pub struct QueryClientStatesResponse {
    // message fields
    ///  list of stored ClientStates of the chain.
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStatesResponse.client_states)
    pub client_states: ::std::vec::Vec<super::client::IdentifiedClientState>,
    ///  pagination response
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStatesResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientStatesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientStatesResponse {
    fn default() -> &'a QueryClientStatesResponse {
        <QueryClientStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientStatesResponse {
    pub fn new() -> QueryClientStatesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_states",
            |m: &QueryClientStatesResponse| { &m.client_states },
            |m: &mut QueryClientStatesResponse| { &mut m.client_states },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryClientStatesResponse| { &m.pagination },
            |m: &mut QueryClientStatesResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientStatesResponse>(
            "QueryClientStatesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientStatesResponse {
    const NAME: &'static str = "QueryClientStatesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_states.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.client_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.client_states {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientStatesResponse {
        QueryClientStatesResponse::new()
    }

    fn clear(&mut self) {
        self.client_states.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientStatesResponse {
        static instance: QueryClientStatesResponse = QueryClientStatesResponse {
            client_states: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientStatesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientStatesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientStatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientStatesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryConsensusStateRequest is the request type for the Query/ConsensusState
///  RPC method. Besides the consensus state, it includes a proof and the height
///  from which the proof was retrieved.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryConsensusStateRequest)
pub struct QueryConsensusStateRequest {
    // message fields
    ///  client identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStateRequest.client_id)
    pub client_id: ::std::string::String,
    ///  consensus state revision number
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStateRequest.revision_number)
    pub revision_number: u64,
    ///  consensus state revision height
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStateRequest.revision_height)
    pub revision_height: u64,
    ///  latest_height overrrides the height field and queries the latest stored
    ///  ConsensusState
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStateRequest.latest_height)
    pub latest_height: bool,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryConsensusStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryConsensusStateRequest {
    fn default() -> &'a QueryConsensusStateRequest {
        <QueryConsensusStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryConsensusStateRequest {
    pub fn new() -> QueryConsensusStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &QueryConsensusStateRequest| { &m.client_id },
            |m: &mut QueryConsensusStateRequest| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "revision_number",
            |m: &QueryConsensusStateRequest| { &m.revision_number },
            |m: &mut QueryConsensusStateRequest| { &mut m.revision_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "revision_height",
            |m: &QueryConsensusStateRequest| { &m.revision_height },
            |m: &mut QueryConsensusStateRequest| { &mut m.revision_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latest_height",
            |m: &QueryConsensusStateRequest| { &m.latest_height },
            |m: &mut QueryConsensusStateRequest| { &mut m.latest_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryConsensusStateRequest>(
            "QueryConsensusStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryConsensusStateRequest {
    const NAME: &'static str = "QueryConsensusStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_id = is.read_string()?;
                },
                16 => {
                    self.revision_number = is.read_uint64()?;
                },
                24 => {
                    self.revision_height = is.read_uint64()?;
                },
                32 => {
                    self.latest_height = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        if self.revision_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.revision_number);
        }
        if self.revision_height != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.revision_height);
        }
        if self.latest_height != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        if self.revision_number != 0 {
            os.write_uint64(2, self.revision_number)?;
        }
        if self.revision_height != 0 {
            os.write_uint64(3, self.revision_height)?;
        }
        if self.latest_height != false {
            os.write_bool(4, self.latest_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryConsensusStateRequest {
        QueryConsensusStateRequest::new()
    }

    fn clear(&mut self) {
        self.client_id.clear();
        self.revision_number = 0;
        self.revision_height = 0;
        self.latest_height = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryConsensusStateRequest {
        static instance: QueryConsensusStateRequest = QueryConsensusStateRequest {
            client_id: ::std::string::String::new(),
            revision_number: 0,
            revision_height: 0,
            latest_height: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryConsensusStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryConsensusStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryConsensusStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConsensusStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryConsensusStateResponse is the response type for the Query/ConsensusState
///  RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryConsensusStateResponse)
pub struct QueryConsensusStateResponse {
    // message fields
    ///  consensus state associated with the client identifier at the given height
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStateResponse.consensus_state)
    pub consensus_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  merkle proof of existence
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStateResponse.proof)
    pub proof: ::std::vec::Vec<u8>,
    ///  height at which the proof was retrieved
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStateResponse.proof_height)
    pub proof_height: ::protobuf::MessageField<super::client::Height>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryConsensusStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryConsensusStateResponse {
    fn default() -> &'a QueryConsensusStateResponse {
        <QueryConsensusStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryConsensusStateResponse {
    pub fn new() -> QueryConsensusStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "consensus_state",
            |m: &QueryConsensusStateResponse| { &m.consensus_state },
            |m: &mut QueryConsensusStateResponse| { &mut m.consensus_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proof",
            |m: &QueryConsensusStateResponse| { &m.proof },
            |m: &mut QueryConsensusStateResponse| { &mut m.proof },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Height>(
            "proof_height",
            |m: &QueryConsensusStateResponse| { &m.proof_height },
            |m: &mut QueryConsensusStateResponse| { &mut m.proof_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryConsensusStateResponse>(
            "QueryConsensusStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryConsensusStateResponse {
    const NAME: &'static str = "QueryConsensusStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_state)?;
                },
                18 => {
                    self.proof = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_height)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.consensus_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.proof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof);
        }
        if let Some(v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.consensus_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.proof.is_empty() {
            os.write_bytes(2, &self.proof)?;
        }
        if let Some(v) = self.proof_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryConsensusStateResponse {
        QueryConsensusStateResponse::new()
    }

    fn clear(&mut self) {
        self.consensus_state.clear();
        self.proof.clear();
        self.proof_height.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryConsensusStateResponse {
        static instance: QueryConsensusStateResponse = QueryConsensusStateResponse {
            consensus_state: ::protobuf::MessageField::none(),
            proof: ::std::vec::Vec::new(),
            proof_height: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryConsensusStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryConsensusStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryConsensusStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConsensusStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryConsensusStatesRequest is the request type for the Query/ConsensusStates
///  RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryConsensusStatesRequest)
pub struct QueryConsensusStatesRequest {
    // message fields
    ///  client identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStatesRequest.client_id)
    pub client_id: ::std::string::String,
    ///  pagination request
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStatesRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryConsensusStatesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryConsensusStatesRequest {
    fn default() -> &'a QueryConsensusStatesRequest {
        <QueryConsensusStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryConsensusStatesRequest {
    pub fn new() -> QueryConsensusStatesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &QueryConsensusStatesRequest| { &m.client_id },
            |m: &mut QueryConsensusStatesRequest| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryConsensusStatesRequest| { &m.pagination },
            |m: &mut QueryConsensusStatesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryConsensusStatesRequest>(
            "QueryConsensusStatesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryConsensusStatesRequest {
    const NAME: &'static str = "QueryConsensusStatesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryConsensusStatesRequest {
        QueryConsensusStatesRequest::new()
    }

    fn clear(&mut self) {
        self.client_id.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryConsensusStatesRequest {
        static instance: QueryConsensusStatesRequest = QueryConsensusStatesRequest {
            client_id: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryConsensusStatesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryConsensusStatesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryConsensusStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConsensusStatesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryConsensusStatesResponse is the response type for the
///  Query/ConsensusStates RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryConsensusStatesResponse)
pub struct QueryConsensusStatesResponse {
    // message fields
    ///  consensus states associated with the identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStatesResponse.consensus_states)
    pub consensus_states: ::std::vec::Vec<super::client::ConsensusStateWithHeight>,
    ///  pagination response
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryConsensusStatesResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryConsensusStatesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryConsensusStatesResponse {
    fn default() -> &'a QueryConsensusStatesResponse {
        <QueryConsensusStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryConsensusStatesResponse {
    pub fn new() -> QueryConsensusStatesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "consensus_states",
            |m: &QueryConsensusStatesResponse| { &m.consensus_states },
            |m: &mut QueryConsensusStatesResponse| { &mut m.consensus_states },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryConsensusStatesResponse| { &m.pagination },
            |m: &mut QueryConsensusStatesResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryConsensusStatesResponse>(
            "QueryConsensusStatesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryConsensusStatesResponse {
    const NAME: &'static str = "QueryConsensusStatesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.consensus_states.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.consensus_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.consensus_states {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryConsensusStatesResponse {
        QueryConsensusStatesResponse::new()
    }

    fn clear(&mut self) {
        self.consensus_states.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryConsensusStatesResponse {
        static instance: QueryConsensusStatesResponse = QueryConsensusStatesResponse {
            consensus_states: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryConsensusStatesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryConsensusStatesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryConsensusStatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConsensusStatesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryClientStatusRequest is the request type for the Query/ClientStatus RPC
///  method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientStatusRequest)
pub struct QueryClientStatusRequest {
    // message fields
    ///  client unique identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStatusRequest.client_id)
    pub client_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientStatusRequest {
    fn default() -> &'a QueryClientStatusRequest {
        <QueryClientStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientStatusRequest {
    pub fn new() -> QueryClientStatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &QueryClientStatusRequest| { &m.client_id },
            |m: &mut QueryClientStatusRequest| { &mut m.client_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientStatusRequest>(
            "QueryClientStatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientStatusRequest {
    const NAME: &'static str = "QueryClientStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientStatusRequest {
        QueryClientStatusRequest::new()
    }

    fn clear(&mut self) {
        self.client_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientStatusRequest {
        static instance: QueryClientStatusRequest = QueryClientStatusRequest {
            client_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientStatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientStatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientStatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
///  method. It returns the current status of the IBC client.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientStatusResponse)
pub struct QueryClientStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientStatusResponse.status)
    pub status: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientStatusResponse {
    fn default() -> &'a QueryClientStatusResponse {
        <QueryClientStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientStatusResponse {
    pub fn new() -> QueryClientStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &QueryClientStatusResponse| { &m.status },
            |m: &mut QueryClientStatusResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientStatusResponse>(
            "QueryClientStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientStatusResponse {
    const NAME: &'static str = "QueryClientStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.status = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientStatusResponse {
        QueryClientStatusResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientStatusResponse {
        static instance: QueryClientStatusResponse = QueryClientStatusResponse {
            status: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryClientParamsRequest is the request type for the Query/ClientParams RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientParamsRequest)
pub struct QueryClientParamsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientParamsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientParamsRequest {
    fn default() -> &'a QueryClientParamsRequest {
        <QueryClientParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientParamsRequest {
    pub fn new() -> QueryClientParamsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientParamsRequest>(
            "QueryClientParamsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientParamsRequest {
    const NAME: &'static str = "QueryClientParamsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientParamsRequest {
        QueryClientParamsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientParamsRequest {
        static instance: QueryClientParamsRequest = QueryClientParamsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientParamsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientParamsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientParamsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryClientParamsResponse is the response type for the Query/ClientParams RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryClientParamsResponse)
pub struct QueryClientParamsResponse {
    // message fields
    ///  params defines the parameters of the module.
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryClientParamsResponse.params)
    pub params: ::protobuf::MessageField<super::client::Params>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryClientParamsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryClientParamsResponse {
    fn default() -> &'a QueryClientParamsResponse {
        <QueryClientParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryClientParamsResponse {
    pub fn new() -> QueryClientParamsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client::Params>(
            "params",
            |m: &QueryClientParamsResponse| { &m.params },
            |m: &mut QueryClientParamsResponse| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryClientParamsResponse>(
            "QueryClientParamsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryClientParamsResponse {
    const NAME: &'static str = "QueryClientParamsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryClientParamsResponse {
        QueryClientParamsResponse::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryClientParamsResponse {
        static instance: QueryClientParamsResponse = QueryClientParamsResponse {
            params: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryClientParamsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryClientParamsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryClientParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryClientParamsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUpgradedClientStateRequest is the request type for the
///  Query/UpgradedClientState RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryUpgradedClientStateRequest)
pub struct QueryUpgradedClientStateRequest {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryUpgradedClientStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUpgradedClientStateRequest {
    fn default() -> &'a QueryUpgradedClientStateRequest {
        <QueryUpgradedClientStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryUpgradedClientStateRequest {
    pub fn new() -> QueryUpgradedClientStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUpgradedClientStateRequest>(
            "QueryUpgradedClientStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUpgradedClientStateRequest {
    const NAME: &'static str = "QueryUpgradedClientStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUpgradedClientStateRequest {
        QueryUpgradedClientStateRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUpgradedClientStateRequest {
        static instance: QueryUpgradedClientStateRequest = QueryUpgradedClientStateRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUpgradedClientStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUpgradedClientStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUpgradedClientStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUpgradedClientStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUpgradedClientStateResponse is the response type for the
///  Query/UpgradedClientState RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryUpgradedClientStateResponse)
pub struct QueryUpgradedClientStateResponse {
    // message fields
    ///  client state associated with the request identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryUpgradedClientStateResponse.upgraded_client_state)
    pub upgraded_client_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryUpgradedClientStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUpgradedClientStateResponse {
    fn default() -> &'a QueryUpgradedClientStateResponse {
        <QueryUpgradedClientStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryUpgradedClientStateResponse {
    pub fn new() -> QueryUpgradedClientStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "upgraded_client_state",
            |m: &QueryUpgradedClientStateResponse| { &m.upgraded_client_state },
            |m: &mut QueryUpgradedClientStateResponse| { &mut m.upgraded_client_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUpgradedClientStateResponse>(
            "QueryUpgradedClientStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUpgradedClientStateResponse {
    const NAME: &'static str = "QueryUpgradedClientStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upgraded_client_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgraded_client_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upgraded_client_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUpgradedClientStateResponse {
        QueryUpgradedClientStateResponse::new()
    }

    fn clear(&mut self) {
        self.upgraded_client_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUpgradedClientStateResponse {
        static instance: QueryUpgradedClientStateResponse = QueryUpgradedClientStateResponse {
            upgraded_client_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUpgradedClientStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUpgradedClientStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUpgradedClientStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUpgradedClientStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUpgradedConsensusStateRequest is the request type for the
///  Query/UpgradedConsensusState RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryUpgradedConsensusStateRequest)
pub struct QueryUpgradedConsensusStateRequest {
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryUpgradedConsensusStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUpgradedConsensusStateRequest {
    fn default() -> &'a QueryUpgradedConsensusStateRequest {
        <QueryUpgradedConsensusStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryUpgradedConsensusStateRequest {
    pub fn new() -> QueryUpgradedConsensusStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUpgradedConsensusStateRequest>(
            "QueryUpgradedConsensusStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUpgradedConsensusStateRequest {
    const NAME: &'static str = "QueryUpgradedConsensusStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUpgradedConsensusStateRequest {
        QueryUpgradedConsensusStateRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUpgradedConsensusStateRequest {
        static instance: QueryUpgradedConsensusStateRequest = QueryUpgradedConsensusStateRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUpgradedConsensusStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUpgradedConsensusStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUpgradedConsensusStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUpgradedConsensusStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUpgradedConsensusStateResponse is the response type for the
///  Query/UpgradedConsensusState RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.QueryUpgradedConsensusStateResponse)
pub struct QueryUpgradedConsensusStateResponse {
    // message fields
    ///  Consensus state associated with the request identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.QueryUpgradedConsensusStateResponse.upgraded_consensus_state)
    pub upgraded_consensus_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.QueryUpgradedConsensusStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUpgradedConsensusStateResponse {
    fn default() -> &'a QueryUpgradedConsensusStateResponse {
        <QueryUpgradedConsensusStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryUpgradedConsensusStateResponse {
    pub fn new() -> QueryUpgradedConsensusStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "upgraded_consensus_state",
            |m: &QueryUpgradedConsensusStateResponse| { &m.upgraded_consensus_state },
            |m: &mut QueryUpgradedConsensusStateResponse| { &mut m.upgraded_consensus_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUpgradedConsensusStateResponse>(
            "QueryUpgradedConsensusStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUpgradedConsensusStateResponse {
    const NAME: &'static str = "QueryUpgradedConsensusStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upgraded_consensus_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgraded_consensus_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upgraded_consensus_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUpgradedConsensusStateResponse {
        QueryUpgradedConsensusStateResponse::new()
    }

    fn clear(&mut self) {
        self.upgraded_consensus_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUpgradedConsensusStateResponse {
        static instance: QueryUpgradedConsensusStateResponse = QueryUpgradedConsensusStateResponse {
            upgraded_consensus_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUpgradedConsensusStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUpgradedConsensusStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUpgradedConsensusStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUpgradedConsensusStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1eibc/core/client/v1/query.proto\x12\x12ibc.core.client.v1\x1a*cosmo\
    s/base/query/v1beta1/pagination.proto\x1a\x1fibc/core/client/v1/client.p\
    roto\x1a\x19google/protobuf/any.proto\x1a\x1cgoogle/api/annotations.prot\
    o\x1a\x14gogoproto/gogo.proto\"6\n\x17QueryClientStateRequest\x12\x1b\n\
    \tclient_id\x18\x01\x20\x01(\tR\x08clientId\"\xae\x01\n\x18QueryClientSt\
    ateResponse\x127\n\x0cclient_state\x18\x01\x20\x01(\x0b2\x14.google.prot\
    obuf.AnyR\x0bclientState\x12\x14\n\x05proof\x18\x02\x20\x01(\x0cR\x05pro\
    of\x12C\n\x0cproof_height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.H\
    eightR\x0bproofHeightB\x04\xc8\xde\x1f\0\"b\n\x18QueryClientStatesReques\
    t\x12F\n\npagination\x18\x01\x20\x01(\x0b2&.cosmos.base.query.v1beta1.Pa\
    geRequestR\npagination\"\xd4\x01\n\x19QueryClientStatesResponse\x12n\n\r\
    client_states\x18\x01\x20\x03(\x0b2).ibc.core.client.v1.IdentifiedClient\
    StateR\x0cclientStatesB\x1e\xaa\xdf\x1f\x16IdentifiedClientStates\xc8\
    \xde\x1f\0\x12G\n\npagination\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v\
    1beta1.PageResponseR\npagination\"\xb0\x01\n\x1aQueryConsensusStateReque\
    st\x12\x1b\n\tclient_id\x18\x01\x20\x01(\tR\x08clientId\x12'\n\x0frevisi\
    on_number\x18\x02\x20\x01(\x04R\x0erevisionNumber\x12'\n\x0frevision_hei\
    ght\x18\x03\x20\x01(\x04R\x0erevisionHeight\x12#\n\rlatest_height\x18\
    \x04\x20\x01(\x08R\x0clatestHeight\"\xb7\x01\n\x1bQueryConsensusStateRes\
    ponse\x12=\n\x0fconsensus_state\x18\x01\x20\x01(\x0b2\x14.google.protobu\
    f.AnyR\x0econsensusState\x12\x14\n\x05proof\x18\x02\x20\x01(\x0cR\x05pro\
    of\x12C\n\x0cproof_height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.H\
    eightR\x0bproofHeightB\x04\xc8\xde\x1f\0\"\x82\x01\n\x1bQueryConsensusSt\
    atesRequest\x12\x1b\n\tclient_id\x18\x01\x20\x01(\tR\x08clientId\x12F\n\
    \npagination\x18\x02\x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageReques\
    tR\npagination\"\xc6\x01\n\x1cQueryConsensusStatesResponse\x12]\n\x10con\
    sensus_states\x18\x01\x20\x03(\x0b2,.ibc.core.client.v1.ConsensusStateWi\
    thHeightR\x0fconsensusStatesB\x04\xc8\xde\x1f\0\x12G\n\npagination\x18\
    \x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagination\
    \"7\n\x18QueryClientStatusRequest\x12\x1b\n\tclient_id\x18\x01\x20\x01(\
    \tR\x08clientId\"3\n\x19QueryClientStatusResponse\x12\x16\n\x06status\
    \x18\x01\x20\x01(\tR\x06status\"\x1a\n\x18QueryClientParamsRequest\"O\n\
    \x19QueryClientParamsResponse\x122\n\x06params\x18\x01\x20\x01(\x0b2\x1a\
    .ibc.core.client.v1.ParamsR\x06params\"!\n\x1fQueryUpgradedClientStateRe\
    quest\"l\n\x20QueryUpgradedClientStateResponse\x12H\n\x15upgraded_client\
    _state\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x13upgradedClientS\
    tate\"$\n\"QueryUpgradedConsensusStateRequest\"u\n#QueryUpgradedConsensu\
    sStateResponse\x12N\n\x18upgraded_consensus_state\x18\x01\x20\x01(\x0b2\
    \x14.google.protobuf.AnyR\x16upgradedConsensusState2\x81\x0b\n\x05Query\
    \x12\x9f\x01\n\x0bClientState\x12+.ibc.core.client.v1.QueryClientStateRe\
    quest\x1a,.ibc.core.client.v1.QueryClientStateResponse\"5\x82\xd3\xe4\
    \x93\x02/\x12-/ibc/core/client/v1/client_states/{client_id}\x12\x96\x01\
    \n\x0cClientStates\x12,.ibc.core.client.v1.QueryClientStatesRequest\x1a-\
    .ibc.core.client.v1.QueryClientStatesResponse\")\x82\xd3\xe4\x93\x02#\
    \x12!/ibc/core/client/v1/client_states\x12\xdf\x01\n\x0eConsensusState\
    \x12..ibc.core.client.v1.QueryConsensusStateRequest\x1a/.ibc.core.client\
    .v1.QueryConsensusStateResponse\"l\x82\xd3\xe4\x93\x02f\x12d/ibc/core/cl\
    ient/v1/consensus_states/{client_id}/revision/{revision_number}/height/{\
    revision_height}\x12\xae\x01\n\x0fConsensusStates\x12/.ibc.core.client.v\
    1.QueryConsensusStatesRequest\x1a0.ibc.core.client.v1.QueryConsensusStat\
    esResponse\"8\x82\xd3\xe4\x93\x022\x120/ibc/core/client/v1/consensus_sta\
    tes/{client_id}\x12\xa2\x01\n\x0cClientStatus\x12,.ibc.core.client.v1.Qu\
    eryClientStatusRequest\x1a-.ibc.core.client.v1.QueryClientStatusResponse\
    \"5\x82\xd3\xe4\x93\x02/\x12-/ibc/core/client/v1/client_status/{client_i\
    d}\x12\x8a\x01\n\x0cClientParams\x12,.ibc.core.client.v1.QueryClientPara\
    msRequest\x1a-.ibc.core.client.v1.QueryClientParamsResponse\"\x1d\x82\
    \xd3\xe4\x93\x02\x17\x12\x15/ibc/client/v1/params\x12\xb4\x01\n\x13Upgra\
    dedClientState\x123.ibc.core.client.v1.QueryUpgradedClientStateRequest\
    \x1a4.ibc.core.client.v1.QueryUpgradedClientStateResponse\"2\x82\xd3\xe4\
    \x93\x02,\x12*/ibc/core/client/v1/upgraded_client_states\x12\xc0\x01\n\
    \x16UpgradedConsensusState\x126.ibc.core.client.v1.QueryUpgradedConsensu\
    sStateRequest\x1a7.ibc.core.client.v1.QueryUpgradedConsensusStateRespons\
    e\"5\x82\xd3\xe4\x93\x02/\x12-/ibc/core/client/v1/upgraded_consensus_sta\
    tesB:Z8github.com/cosmos/ibc-go/v3/modules/core/02-client/typesJ\xa7.\n\
    \x07\x12\x05\0\0\xb7\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x02\0\x1b\n\x08\n\x01\x08\x12\x03\x04\0O\n\t\n\x02\x08\x0b\
    \x12\x03\x04\0O\n\t\n\x02\x03\0\x12\x03\x06\04\n\t\n\x02\x03\x01\x12\x03\
    \x07\0)\n\t\n\x02\x03\x02\x12\x03\x08\0#\n\t\n\x02\x03\x03\x12\x03\t\0&\
    \n\t\n\x02\x03\x04\x12\x03\n\0\x1e\n=\n\x02\x06\0\x12\x04\r\09\x01\x1a1\
    \x20Query\x20provides\x20defines\x20the\x20gRPC\x20querier\x20service\n\
    \n\n\n\x03\x06\0\x01\x12\x03\r\x08\r\n8\n\x04\x06\0\x02\0\x12\x04\x0f\
    \x02\x11\x03\x1a*\x20ClientState\x20queries\x20an\x20IBC\x20light\x20cli\
    ent.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x0f\x06\x11\n\x0c\n\x05\x06\0\
    \x02\0\x02\x12\x03\x0f\x12)\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x0f4L\n\
    \x0c\n\x05\x06\0\x02\0\x04\x12\x03\x10\x04S\n\x11\n\n\x06\0\x02\0\x04\
    \xb0\xca\xbc\"\x02\x12\x03\x10\x04S\nJ\n\x04\x06\0\x02\x01\x12\x04\x14\
    \x02\x16\x03\x1a<\x20ClientStates\x20queries\x20all\x20the\x20IBC\x20lig\
    ht\x20clients\x20of\x20a\x20chain.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\
    \x03\x14\x06\x12\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x14\x13+\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03\x146O\n\x0c\n\x05\x06\0\x02\x01\x04\x12\
    \x03\x15\x04G\n\x11\n\n\x06\0\x02\x01\x04\xb0\xca\xbc\"\x02\x12\x03\x15\
    \x04G\nk\n\x04\x06\0\x02\x02\x12\x04\x1a\x02\x1e\x03\x1a]\x20ConsensusSt\
    ate\x20queries\x20a\x20consensus\x20state\x20associated\x20with\x20a\x20\
    client\x20state\x20at\n\x20a\x20given\x20height.\n\n\x0c\n\x05\x06\0\x02\
    \x02\x01\x12\x03\x1a\x06\x14\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x1a\
    \x15/\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1a:U\n\r\n\x05\x06\0\x02\
    \x02\x04\x12\x04\x1b\x04\x1d>\n\x12\n\n\x06\0\x02\x02\x04\xb0\xca\xbc\"\
    \x02\x12\x04\x1b\x04\x1d>\n`\n\x04\x06\0\x02\x03\x12\x04\"\x02$\x03\x1aR\
    \x20ConsensusStates\x20queries\x20all\x20the\x20consensus\x20state\x20as\
    sociated\x20with\x20a\x20given\n\x20client.\n\n\x0c\n\x05\x06\0\x02\x03\
    \x01\x12\x03\"\x06\x15\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\"\x161\n\
    \x0c\n\x05\x06\0\x02\x03\x03\x12\x03\"<X\n\x0c\n\x05\x06\0\x02\x03\x04\
    \x12\x03#\x04V\n\x11\n\n\x06\0\x02\x03\x04\xb0\xca\xbc\"\x02\x12\x03#\
    \x04V\n;\n\x04\x06\0\x02\x04\x12\x04'\x02)\x03\x1a-\x20Status\x20queries\
    \x20the\x20status\x20of\x20an\x20IBC\x20client.\n\n\x0c\n\x05\x06\0\x02\
    \x04\x01\x12\x03'\x06\x12\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03'\x13+\n\
    \x0c\n\x05\x06\0\x02\x04\x03\x12\x03'6O\n\x0c\n\x05\x06\0\x02\x04\x04\
    \x12\x03(\x04S\n\x11\n\n\x06\0\x02\x04\x04\xb0\xca\xbc\"\x02\x12\x03(\
    \x04S\nF\n\x04\x06\0\x02\x05\x12\x04,\x02.\x03\x1a8\x20ClientParams\x20q\
    ueries\x20all\x20parameters\x20of\x20the\x20ibc\x20client.\n\n\x0c\n\x05\
    \x06\0\x02\x05\x01\x12\x03,\x06\x12\n\x0c\n\x05\x06\0\x02\x05\x02\x12\
    \x03,\x13+\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03,6O\n\x0c\n\x05\x06\0\
    \x02\x05\x04\x12\x03-\x04;\n\x11\n\n\x06\0\x02\x05\x04\xb0\xca\xbc\"\x02\
    \x12\x03-\x04;\nI\n\x04\x06\0\x02\x06\x12\x041\x023\x03\x1a;\x20Upgraded\
    ClientState\x20queries\x20an\x20Upgraded\x20IBC\x20light\x20client.\n\n\
    \x0c\n\x05\x06\0\x02\x06\x01\x12\x031\x06\x19\n\x0c\n\x05\x06\0\x02\x06\
    \x02\x12\x031\x1a9\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x031Dd\n\x0c\n\x05\
    \x06\0\x02\x06\x04\x12\x032\x04P\n\x11\n\n\x06\0\x02\x06\x04\xb0\xca\xbc\
    \"\x02\x12\x032\x04P\nO\n\x04\x06\0\x02\x07\x12\x046\x028\x03\x1aA\x20Up\
    gradedConsensusState\x20queries\x20an\x20Upgraded\x20IBC\x20consensus\
    \x20state.\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x036\x06\x1c\n\x0c\n\x05\
    \x06\0\x02\x07\x02\x12\x036\x1d?\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x036J\
    m\n\x0c\n\x05\x06\0\x02\x07\x04\x12\x037\x04S\n\x11\n\n\x06\0\x02\x07\
    \x04\xb0\xca\xbc\"\x02\x12\x037\x04S\n_\n\x02\x04\0\x12\x04=\0@\x01\x1aS\
    \x20QueryClientStateRequest\x20is\x20the\x20request\x20type\x20for\x20th\
    e\x20Query/ClientState\x20RPC\n\x20method\n\n\n\n\x03\x04\0\x01\x12\x03=\
    \x08\x1f\n-\n\x04\x04\0\x02\0\x12\x03?\x02\x17\x1a\x20\x20client\x20stat\
    e\x20unique\x20identifier\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03?\x02\x08\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03?\t\x12\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03?\x15\x16\n\xc5\x01\n\x02\x04\x01\x12\x04E\0L\x01\x1a\xb8\x01\
    \x20QueryClientStateResponse\x20is\x20the\x20response\x20type\x20for\x20\
    the\x20Query/ClientState\x20RPC\n\x20method.\x20Besides\x20the\x20client\
    \x20state,\x20it\x20includes\x20a\x20proof\x20and\x20the\x20height\x20fr\
    om\n\x20which\x20the\x20proof\x20was\x20retrieved.\n\n\n\n\x03\x04\x01\
    \x01\x12\x03E\x08\x20\nB\n\x04\x04\x01\x02\0\x12\x03G\x02'\x1a5\x20clien\
    t\x20state\x20associated\x20with\x20the\x20request\x20identifier\n\n\x0c\
    \n\x05\x04\x01\x02\0\x06\x12\x03G\x02\x15\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03G\x16\"\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03G%&\n(\n\x04\x04\
    \x01\x02\x01\x12\x03I\x02\x12\x1a\x1b\x20merkle\x20proof\x20of\x20existe\
    nce\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03I\x02\x07\n\x0c\n\x05\x04\
    \x01\x02\x01\x01\x12\x03I\x08\r\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03I\
    \x10\x11\n6\n\x04\x04\x01\x02\x02\x12\x03K\x02L\x1a)\x20height\x20at\x20\
    which\x20the\x20proof\x20was\x20retrieved\n\n\x0c\n\x05\x04\x01\x02\x02\
    \x06\x12\x03K\x02\x1b\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03K\x1c(\n\
    \x0c\n\x05\x04\x01\x02\x02\x03\x12\x03K+,\n\x0c\n\x05\x04\x01\x02\x02\
    \x08\x12\x03K-K\n\x0f\n\x08\x04\x01\x02\x02\x08\xe9\xfb\x03\x12\x03K.J\n\
    a\n\x02\x04\x02\x12\x04P\0S\x01\x1aU\x20QueryClientStatesRequest\x20is\
    \x20the\x20request\x20type\x20for\x20the\x20Query/ClientStates\x20RPC\n\
    \x20method\n\n\n\n\x03\x04\x02\x01\x12\x03P\x08\x20\n!\n\x04\x04\x02\x02\
    \0\x12\x03R\x027\x1a\x14\x20pagination\x20request\n\n\x0c\n\x05\x04\x02\
    \x02\0\x06\x12\x03R\x02'\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03R(2\n\x0c\
    \n\x05\x04\x02\x02\0\x03\x12\x03R56\nd\n\x02\x04\x03\x12\x04W\0]\x01\x1a\
    X\x20QueryClientStatesResponse\x20is\x20the\x20response\x20type\x20for\
    \x20the\x20Query/ClientStates\x20RPC\n\x20method.\n\n\n\n\x03\x04\x03\
    \x01\x12\x03W\x08!\n9\n\x04\x04\x03\x02\0\x12\x04Y\x02ZZ\x1a+\x20list\
    \x20of\x20stored\x20ClientStates\x20of\x20the\x20chain.\n\n\x0c\n\x05\
    \x04\x03\x02\0\x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03Y\
    \x0b\x20\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03Y!.\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03Y12\n\x0c\n\x05\x04\x03\x02\0\x08\x12\x03Z\x06Y\n\x0f\
    \n\x08\x04\x03\x02\0\x08\xe9\xfb\x03\x12\x03Z\x07#\n\x0f\n\x08\x04\x03\
    \x02\0\x08\xf5\xfb\x03\x12\x03Z%X\n\"\n\x04\x04\x03\x02\x01\x12\x03\\\
    \x028\x1a\x15\x20pagination\x20response\n\n\x0c\n\x05\x04\x03\x02\x01\
    \x06\x12\x03\\\x02(\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\\)3\n\x0c\n\
    \x05\x04\x03\x02\x01\x03\x12\x03\\67\n\xcc\x01\n\x02\x04\x04\x12\x04b\0l\
    \x01\x1a\xbf\x01\x20QueryConsensusStateRequest\x20is\x20the\x20request\
    \x20type\x20for\x20the\x20Query/ConsensusState\n\x20RPC\x20method.\x20Be\
    sides\x20the\x20consensus\x20state,\x20it\x20includes\x20a\x20proof\x20a\
    nd\x20the\x20height\n\x20from\x20which\x20the\x20proof\x20was\x20retriev\
    ed.\n\n\n\n\x03\x04\x04\x01\x12\x03b\x08\"\n\x20\n\x04\x04\x04\x02\0\x12\
    \x03d\x02\x17\x1a\x13\x20client\x20identifier\n\n\x0c\n\x05\x04\x04\x02\
    \0\x05\x12\x03d\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03d\t\x12\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03d\x15\x16\n.\n\x04\x04\x04\x02\x01\
    \x12\x03f\x02\x1d\x1a!\x20consensus\x20state\x20revision\x20number\n\n\
    \x0c\n\x05\x04\x04\x02\x01\x05\x12\x03f\x02\x08\n\x0c\n\x05\x04\x04\x02\
    \x01\x01\x12\x03f\t\x18\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03f\x1b\x1c\
    \n.\n\x04\x04\x04\x02\x02\x12\x03h\x02\x1d\x1a!\x20consensus\x20state\
    \x20revision\x20height\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03h\x02\
    \x08\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03h\t\x18\n\x0c\n\x05\x04\x04\
    \x02\x02\x03\x12\x03h\x1b\x1c\nf\n\x04\x04\x04\x02\x03\x12\x03k\x02\x19\
    \x1aY\x20latest_height\x20overrrides\x20the\x20height\x20field\x20and\
    \x20queries\x20the\x20latest\x20stored\n\x20ConsensusState\n\n\x0c\n\x05\
    \x04\x04\x02\x03\x05\x12\x03k\x02\x06\n\x0c\n\x05\x04\x04\x02\x03\x01\
    \x12\x03k\x07\x14\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03k\x17\x18\ng\n\
    \x02\x04\x05\x12\x04p\0w\x01\x1a[\x20QueryConsensusStateResponse\x20is\
    \x20the\x20response\x20type\x20for\x20the\x20Query/ConsensusState\n\x20R\
    PC\x20method\n\n\n\n\x03\x04\x05\x01\x12\x03p\x08#\nX\n\x04\x04\x05\x02\
    \0\x12\x03r\x02*\x1aK\x20consensus\x20state\x20associated\x20with\x20the\
    \x20client\x20identifier\x20at\x20the\x20given\x20height\n\n\x0c\n\x05\
    \x04\x05\x02\0\x06\x12\x03r\x02\x15\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03r\x16%\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03r()\n(\n\x04\x04\x05\x02\
    \x01\x12\x03t\x02\x12\x1a\x1b\x20merkle\x20proof\x20of\x20existence\n\n\
    \x0c\n\x05\x04\x05\x02\x01\x05\x12\x03t\x02\x07\n\x0c\n\x05\x04\x05\x02\
    \x01\x01\x12\x03t\x08\r\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03t\x10\x11\
    \n6\n\x04\x04\x05\x02\x02\x12\x03v\x02L\x1a)\x20height\x20at\x20which\
    \x20the\x20proof\x20was\x20retrieved\n\n\x0c\n\x05\x04\x05\x02\x02\x06\
    \x12\x03v\x02\x1b\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03v\x1c(\n\x0c\n\
    \x05\x04\x05\x02\x02\x03\x12\x03v+,\n\x0c\n\x05\x04\x05\x02\x02\x08\x12\
    \x03v-K\n\x0f\n\x08\x04\x05\x02\x02\x08\xe9\xfb\x03\x12\x03v.J\ni\n\x02\
    \x04\x06\x12\x05{\0\x80\x01\x01\x1a\\\x20QueryConsensusStatesRequest\x20\
    is\x20the\x20request\x20type\x20for\x20the\x20Query/ConsensusStates\n\
    \x20RPC\x20method.\n\n\n\n\x03\x04\x06\x01\x12\x03{\x08#\n\x20\n\x04\x04\
    \x06\x02\0\x12\x03}\x02\x17\x1a\x13\x20client\x20identifier\n\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03}\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03}\t\x12\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03}\x15\x16\n!\n\x04\
    \x04\x06\x02\x01\x12\x03\x7f\x027\x1a\x14\x20pagination\x20request\n\n\
    \x0c\n\x05\x04\x06\x02\x01\x06\x12\x03\x7f\x02'\n\x0c\n\x05\x04\x06\x02\
    \x01\x01\x12\x03\x7f(2\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03\x7f56\nk\
    \n\x02\x04\x07\x12\x06\x84\x01\0\x89\x01\x01\x1a]\x20QueryConsensusState\
    sResponse\x20is\x20the\x20response\x20type\x20for\x20the\n\x20Query/Cons\
    ensusStates\x20RPC\x20method\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x84\x01\
    \x08$\n?\n\x04\x04\x07\x02\0\x12\x04\x86\x01\x02X\x1a1\x20consensus\x20s\
    tates\x20associated\x20with\x20the\x20identifier\n\n\r\n\x05\x04\x07\x02\
    \0\x04\x12\x04\x86\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\x86\x01\
    \x0b#\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x86\x01$4\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\x86\x0178\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\x86\x01\
    9W\n\x10\n\x08\x04\x07\x02\0\x08\xe9\xfb\x03\x12\x04\x86\x01:V\n#\n\x04\
    \x04\x07\x02\x01\x12\x04\x88\x01\x028\x1a\x15\x20pagination\x20response\
    \n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\x88\x01\x02(\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\x88\x01)3\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x88\
    \x0167\nc\n\x02\x04\x08\x12\x06\x8d\x01\0\x90\x01\x01\x1aU\x20QueryClien\
    tStatusRequest\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/Cl\
    ientStatus\x20RPC\n\x20method\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x8d\x01\
    \x08\x20\n(\n\x04\x04\x08\x02\0\x12\x04\x8f\x01\x02\x17\x1a\x1a\x20clien\
    t\x20unique\x20identifier\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x8f\x01\
    \x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x8f\x01\t\x12\n\r\n\x05\x04\
    \x08\x02\0\x03\x12\x04\x8f\x01\x15\x16\n\x98\x01\n\x02\x04\t\x12\x06\x94\
    \x01\0\x96\x01\x01\x1a\x89\x01\x20QueryClientStatusResponse\x20is\x20the\
    \x20response\x20type\x20for\x20the\x20Query/ClientStatus\x20RPC\n\x20met\
    hod.\x20It\x20returns\x20the\x20current\x20status\x20of\x20the\x20IBC\
    \x20client.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x94\x01\x08!\n\x0c\n\x04\x04\
    \t\x02\0\x12\x04\x95\x01\x02\x14\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x95\
    \x01\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x95\x01\t\x0f\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\x95\x01\x12\x13\nb\n\x02\x04\n\x12\x04\x9a\x01\
    \0#\x1aV\x20QueryClientParamsRequest\x20is\x20the\x20request\x20type\x20\
    for\x20the\x20Query/ClientParams\x20RPC\n\x20method.\n\n\x0b\n\x03\x04\n\
    \x01\x12\x04\x9a\x01\x08\x20\nf\n\x02\x04\x0b\x12\x06\x9e\x01\0\xa1\x01\
    \x01\x1aX\x20QueryClientParamsResponse\x20is\x20the\x20response\x20type\
    \x20for\x20the\x20Query/ClientParams\x20RPC\n\x20method.\n\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\x9e\x01\x08!\n<\n\x04\x04\x0b\x02\0\x12\x04\xa0\x01\
    \x02\x14\x1a.\x20params\x20defines\x20the\x20parameters\x20of\x20the\x20\
    module.\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xa0\x01\x02\x08\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\xa0\x01\t\x0f\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\xa0\x01\x12\x13\no\n\x02\x04\x0c\x12\x04\xa5\x01\0*\x1ac\x20QueryUp\
    gradedClientStateRequest\x20is\x20the\x20request\x20type\x20for\x20the\n\
    \x20Query/UpgradedClientState\x20RPC\x20method\n\n\x0b\n\x03\x04\x0c\x01\
    \x12\x04\xa5\x01\x08'\nt\n\x02\x04\r\x12\x06\xa9\x01\0\xac\x01\x01\x1af\
    \x20QueryUpgradedClientStateResponse\x20is\x20the\x20response\x20type\
    \x20for\x20the\n\x20Query/UpgradedClientState\x20RPC\x20method.\n\n\x0b\
    \n\x03\x04\r\x01\x12\x04\xa9\x01\x08(\nC\n\x04\x04\r\x02\0\x12\x04\xab\
    \x01\x020\x1a5\x20client\x20state\x20associated\x20with\x20the\x20reques\
    t\x20identifier\n\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xab\x01\x02\x15\n\r\
    \n\x05\x04\r\x02\0\x01\x12\x04\xab\x01\x16+\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xab\x01./\nu\n\x02\x04\x0e\x12\x04\xb0\x01\0-\x1ai\x20QueryUpgr\
    adedConsensusStateRequest\x20is\x20the\x20request\x20type\x20for\x20the\
    \n\x20Query/UpgradedConsensusState\x20RPC\x20method\n\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xb0\x01\x08*\nz\n\x02\x04\x0f\x12\x06\xb4\x01\0\xb7\x01\
    \x01\x1al\x20QueryUpgradedConsensusStateResponse\x20is\x20the\x20respons\
    e\x20type\x20for\x20the\n\x20Query/UpgradedConsensusState\x20RPC\x20meth\
    od.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xb4\x01\x08+\nF\n\x04\x04\x0f\x02\
    \0\x12\x04\xb6\x01\x023\x1a8\x20Consensus\x20state\x20associated\x20with\
    \x20the\x20request\x20identifier\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\
    \xb6\x01\x02\x15\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xb6\x01\x16.\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\xb6\x0112b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::pagination::file_descriptor().clone());
            deps.push(super::client::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(QueryClientStateRequest::generated_message_descriptor_data());
            messages.push(QueryClientStateResponse::generated_message_descriptor_data());
            messages.push(QueryClientStatesRequest::generated_message_descriptor_data());
            messages.push(QueryClientStatesResponse::generated_message_descriptor_data());
            messages.push(QueryConsensusStateRequest::generated_message_descriptor_data());
            messages.push(QueryConsensusStateResponse::generated_message_descriptor_data());
            messages.push(QueryConsensusStatesRequest::generated_message_descriptor_data());
            messages.push(QueryConsensusStatesResponse::generated_message_descriptor_data());
            messages.push(QueryClientStatusRequest::generated_message_descriptor_data());
            messages.push(QueryClientStatusResponse::generated_message_descriptor_data());
            messages.push(QueryClientParamsRequest::generated_message_descriptor_data());
            messages.push(QueryClientParamsResponse::generated_message_descriptor_data());
            messages.push(QueryUpgradedClientStateRequest::generated_message_descriptor_data());
            messages.push(QueryUpgradedClientStateResponse::generated_message_descriptor_data());
            messages.push(QueryUpgradedConsensusStateRequest::generated_message_descriptor_data());
            messages.push(QueryUpgradedConsensusStateResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
