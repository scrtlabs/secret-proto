// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ibc/core/client/v1/client.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  IdentifiedClientState defines a client state with an additional client
///  identifier field.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.IdentifiedClientState)
pub struct IdentifiedClientState {
    // message fields
    ///  client identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.IdentifiedClientState.client_id)
    pub client_id: ::std::string::String,
    ///  client state
    // @@protoc_insertion_point(field:ibc.core.client.v1.IdentifiedClientState.client_state)
    pub client_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.IdentifiedClientState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdentifiedClientState {
    fn default() -> &'a IdentifiedClientState {
        <IdentifiedClientState as ::protobuf::Message>::default_instance()
    }
}

impl IdentifiedClientState {
    pub fn new() -> IdentifiedClientState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &IdentifiedClientState| { &m.client_id },
            |m: &mut IdentifiedClientState| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "client_state",
            |m: &IdentifiedClientState| { &m.client_state },
            |m: &mut IdentifiedClientState| { &mut m.client_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdentifiedClientState>(
            "IdentifiedClientState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdentifiedClientState {
    const NAME: &'static str = "IdentifiedClientState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.client_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        if let Some(v) = self.client_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        if let Some(v) = self.client_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdentifiedClientState {
        IdentifiedClientState::new()
    }

    fn clear(&mut self) {
        self.client_id.clear();
        self.client_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdentifiedClientState {
        static instance: IdentifiedClientState = IdentifiedClientState {
            client_id: ::std::string::String::new(),
            client_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdentifiedClientState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdentifiedClientState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdentifiedClientState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentifiedClientState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConsensusStateWithHeight defines a consensus state with an additional height
///  field.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.ConsensusStateWithHeight)
pub struct ConsensusStateWithHeight {
    // message fields
    ///  consensus state height
    // @@protoc_insertion_point(field:ibc.core.client.v1.ConsensusStateWithHeight.height)
    pub height: ::protobuf::MessageField<Height>,
    ///  consensus state
    // @@protoc_insertion_point(field:ibc.core.client.v1.ConsensusStateWithHeight.consensus_state)
    pub consensus_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.ConsensusStateWithHeight.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConsensusStateWithHeight {
    fn default() -> &'a ConsensusStateWithHeight {
        <ConsensusStateWithHeight as ::protobuf::Message>::default_instance()
    }
}

impl ConsensusStateWithHeight {
    pub fn new() -> ConsensusStateWithHeight {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Height>(
            "height",
            |m: &ConsensusStateWithHeight| { &m.height },
            |m: &mut ConsensusStateWithHeight| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "consensus_state",
            |m: &ConsensusStateWithHeight| { &m.consensus_state },
            |m: &mut ConsensusStateWithHeight| { &mut m.consensus_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConsensusStateWithHeight>(
            "ConsensusStateWithHeight",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConsensusStateWithHeight {
    const NAME: &'static str = "ConsensusStateWithHeight";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.consensus_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.consensus_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConsensusStateWithHeight {
        ConsensusStateWithHeight::new()
    }

    fn clear(&mut self) {
        self.height.clear();
        self.consensus_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConsensusStateWithHeight {
        static instance: ConsensusStateWithHeight = ConsensusStateWithHeight {
            height: ::protobuf::MessageField::none(),
            consensus_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConsensusStateWithHeight {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConsensusStateWithHeight").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConsensusStateWithHeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusStateWithHeight {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ClientConsensusStates defines all the stored consensus states for a given
///  client.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.ClientConsensusStates)
pub struct ClientConsensusStates {
    // message fields
    ///  client identifier
    // @@protoc_insertion_point(field:ibc.core.client.v1.ClientConsensusStates.client_id)
    pub client_id: ::std::string::String,
    ///  consensus states and their heights associated with the client
    // @@protoc_insertion_point(field:ibc.core.client.v1.ClientConsensusStates.consensus_states)
    pub consensus_states: ::std::vec::Vec<ConsensusStateWithHeight>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.ClientConsensusStates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientConsensusStates {
    fn default() -> &'a ClientConsensusStates {
        <ClientConsensusStates as ::protobuf::Message>::default_instance()
    }
}

impl ClientConsensusStates {
    pub fn new() -> ClientConsensusStates {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &ClientConsensusStates| { &m.client_id },
            |m: &mut ClientConsensusStates| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "consensus_states",
            |m: &ClientConsensusStates| { &m.consensus_states },
            |m: &mut ClientConsensusStates| { &mut m.consensus_states },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientConsensusStates>(
            "ClientConsensusStates",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientConsensusStates {
    const NAME: &'static str = "ClientConsensusStates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_id = is.read_string()?;
                },
                18 => {
                    self.consensus_states.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        for value in &self.consensus_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        for v in &self.consensus_states {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientConsensusStates {
        ClientConsensusStates::new()
    }

    fn clear(&mut self) {
        self.client_id.clear();
        self.consensus_states.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientConsensusStates {
        static instance: ClientConsensusStates = ClientConsensusStates {
            client_id: ::std::string::String::new(),
            consensus_states: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientConsensusStates {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientConsensusStates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientConsensusStates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientConsensusStates {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ClientUpdateProposal is a governance proposal. If it passes, the substitute
///  client's latest consensus state is copied over to the subject client. The proposal
///  handler may fail if the subject and the substitute do not match in client and
///  chain parameters (with exception to latest height, frozen height, and chain-id).
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.ClientUpdateProposal)
pub struct ClientUpdateProposal {
    // message fields
    ///  the title of the update proposal
    // @@protoc_insertion_point(field:ibc.core.client.v1.ClientUpdateProposal.title)
    pub title: ::std::string::String,
    ///  the description of the proposal
    // @@protoc_insertion_point(field:ibc.core.client.v1.ClientUpdateProposal.description)
    pub description: ::std::string::String,
    ///  the client identifier for the client to be updated if the proposal passes
    // @@protoc_insertion_point(field:ibc.core.client.v1.ClientUpdateProposal.subject_client_id)
    pub subject_client_id: ::std::string::String,
    ///  the substitute client identifier for the client standing in for the subject
    ///  client
    // @@protoc_insertion_point(field:ibc.core.client.v1.ClientUpdateProposal.substitute_client_id)
    pub substitute_client_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.ClientUpdateProposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientUpdateProposal {
    fn default() -> &'a ClientUpdateProposal {
        <ClientUpdateProposal as ::protobuf::Message>::default_instance()
    }
}

impl ClientUpdateProposal {
    pub fn new() -> ClientUpdateProposal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ClientUpdateProposal| { &m.title },
            |m: &mut ClientUpdateProposal| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ClientUpdateProposal| { &m.description },
            |m: &mut ClientUpdateProposal| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subject_client_id",
            |m: &ClientUpdateProposal| { &m.subject_client_id },
            |m: &mut ClientUpdateProposal| { &mut m.subject_client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "substitute_client_id",
            |m: &ClientUpdateProposal| { &m.substitute_client_id },
            |m: &mut ClientUpdateProposal| { &mut m.substitute_client_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientUpdateProposal>(
            "ClientUpdateProposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientUpdateProposal {
    const NAME: &'static str = "ClientUpdateProposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    self.subject_client_id = is.read_string()?;
                },
                34 => {
                    self.substitute_client_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.subject_client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subject_client_id);
        }
        if !self.substitute_client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.substitute_client_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.subject_client_id.is_empty() {
            os.write_string(3, &self.subject_client_id)?;
        }
        if !self.substitute_client_id.is_empty() {
            os.write_string(4, &self.substitute_client_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientUpdateProposal {
        ClientUpdateProposal::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.subject_client_id.clear();
        self.substitute_client_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientUpdateProposal {
        static instance: ClientUpdateProposal = ClientUpdateProposal {
            title: ::std::string::String::new(),
            description: ::std::string::String::new(),
            subject_client_id: ::std::string::String::new(),
            substitute_client_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientUpdateProposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientUpdateProposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientUpdateProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientUpdateProposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  UpgradeProposal is a gov Content type for initiating an IBC breaking
///  upgrade.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.UpgradeProposal)
pub struct UpgradeProposal {
    // message fields
    // @@protoc_insertion_point(field:ibc.core.client.v1.UpgradeProposal.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.client.v1.UpgradeProposal.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:ibc.core.client.v1.UpgradeProposal.plan)
    pub plan: ::protobuf::MessageField<super::upgrade::Plan>,
    ///  An UpgradedClientState must be provided to perform an IBC breaking upgrade.
    ///  This will make the chain commit to the correct upgraded (self) client state
    ///  before the upgrade occurs, so that connecting chains can verify that the
    ///  new upgraded client is valid by verifying a proof on the previous version
    ///  of the chain. This will allow IBC connections to persist smoothly across
    ///  planned chain upgrades
    // @@protoc_insertion_point(field:ibc.core.client.v1.UpgradeProposal.upgraded_client_state)
    pub upgraded_client_state: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.UpgradeProposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpgradeProposal {
    fn default() -> &'a UpgradeProposal {
        <UpgradeProposal as ::protobuf::Message>::default_instance()
    }
}

impl UpgradeProposal {
    pub fn new() -> UpgradeProposal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &UpgradeProposal| { &m.title },
            |m: &mut UpgradeProposal| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &UpgradeProposal| { &m.description },
            |m: &mut UpgradeProposal| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::upgrade::Plan>(
            "plan",
            |m: &UpgradeProposal| { &m.plan },
            |m: &mut UpgradeProposal| { &mut m.plan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "upgraded_client_state",
            |m: &UpgradeProposal| { &m.upgraded_client_state },
            |m: &mut UpgradeProposal| { &mut m.upgraded_client_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpgradeProposal>(
            "UpgradeProposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpgradeProposal {
    const NAME: &'static str = "UpgradeProposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.plan)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upgraded_client_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(v) = self.plan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.upgraded_client_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(v) = self.plan.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.upgraded_client_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpgradeProposal {
        UpgradeProposal::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.plan.clear();
        self.upgraded_client_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpgradeProposal {
        static instance: UpgradeProposal = UpgradeProposal {
            title: ::std::string::String::new(),
            description: ::std::string::String::new(),
            plan: ::protobuf::MessageField::none(),
            upgraded_client_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpgradeProposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpgradeProposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpgradeProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpgradeProposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Height is a monotonically increasing data type
///  that can be compared against another Height for the purposes of updating and
///  freezing clients
///
///  Normally the RevisionHeight is incremented at each height while keeping
///  RevisionNumber the same. However some consensus algorithms may choose to
///  reset the height in certain conditions e.g. hard forks, state-machine
///  breaking changes In these cases, the RevisionNumber is incremented so that
///  height continues to be monitonically increasing even as the RevisionHeight
///  gets reset
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.Height)
pub struct Height {
    // message fields
    ///  the revision that the client is currently on
    // @@protoc_insertion_point(field:ibc.core.client.v1.Height.revision_number)
    pub revision_number: u64,
    ///  the height within the given revision
    // @@protoc_insertion_point(field:ibc.core.client.v1.Height.revision_height)
    pub revision_height: u64,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.Height.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Height {
    fn default() -> &'a Height {
        <Height as ::protobuf::Message>::default_instance()
    }
}

impl Height {
    pub fn new() -> Height {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "revision_number",
            |m: &Height| { &m.revision_number },
            |m: &mut Height| { &mut m.revision_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "revision_height",
            |m: &Height| { &m.revision_height },
            |m: &mut Height| { &mut m.revision_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Height>(
            "Height",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Height {
    const NAME: &'static str = "Height";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.revision_number = is.read_uint64()?;
                },
                16 => {
                    self.revision_height = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.revision_number != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.revision_number);
        }
        if self.revision_height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.revision_height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.revision_number != 0 {
            os.write_uint64(1, self.revision_number)?;
        }
        if self.revision_height != 0 {
            os.write_uint64(2, self.revision_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Height {
        Height::new()
    }

    fn clear(&mut self) {
        self.revision_number = 0;
        self.revision_height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Height {
        static instance: Height = Height {
            revision_number: 0,
            revision_height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Height {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Height").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Height {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Height {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Params defines the set of IBC light client parameters.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ibc.core.client.v1.Params)
pub struct Params {
    // message fields
    ///  allowed_clients defines the list of allowed client state types.
    // @@protoc_insertion_point(field:ibc.core.client.v1.Params.allowed_clients)
    pub allowed_clients: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ibc.core.client.v1.Params.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Params {
    fn default() -> &'a Params {
        <Params as ::protobuf::Message>::default_instance()
    }
}

impl Params {
    pub fn new() -> Params {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allowed_clients",
            |m: &Params| { &m.allowed_clients },
            |m: &mut Params| { &mut m.allowed_clients },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Params>(
            "Params",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Params {
    const NAME: &'static str = "Params";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.allowed_clients.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.allowed_clients {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.allowed_clients {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Params {
        Params::new()
    }

    fn clear(&mut self) {
        self.allowed_clients.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Params {
        static instance: Params = Params {
            allowed_clients: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Params {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Params").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Params {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fibc/core/client/v1/client.proto\x12\x12ibc.core.client.v1\x1a\x14g\
    ogoproto/gogo.proto\x1a\x19google/protobuf/any.proto\x1a$cosmos/upgrade/\
    v1beta1/upgrade.proto\"\x9c\x01\n\x15IdentifiedClientState\x121\n\tclien\
    t_id\x18\x01\x20\x01(\tR\x08clientIdB\x14\xf2\xde\x1f\x10yaml:\"client_i\
    d\"\x12P\n\x0cclient_state\x18\x02\x20\x01(\x0b2\x14.google.protobuf.Any\
    R\x0bclientStateB\x17\xf2\xde\x1f\x13yaml:\"client_state\"\"\xaf\x01\n\
    \x18ConsensusStateWithHeight\x128\n\x06height\x18\x01\x20\x01(\x0b2\x1a.\
    ibc.core.client.v1.HeightR\x06heightB\x04\xc8\xde\x1f\0\x12Y\n\x0fconsen\
    sus_state\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x0econsensusSta\
    teB\x1a\xf2\xde\x1f\x16yaml:\"consensus_state\"\"\xc4\x01\n\x15ClientCon\
    sensusStates\x121\n\tclient_id\x18\x01\x20\x01(\tR\x08clientIdB\x14\xf2\
    \xde\x1f\x10yaml:\"client_id\"\x12x\n\x10consensus_states\x18\x02\x20\
    \x03(\x0b2,.ibc.core.client.v1.ConsensusStateWithHeightR\x0fconsensusSta\
    tesB\x1f\xf2\xde\x1f\x17yaml:\"consensus_states\"\xc8\xde\x1f\0\"\xf1\
    \x01\n\x14ClientUpdateProposal\x12\x14\n\x05title\x18\x01\x20\x01(\tR\
    \x05title\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\
    \x12H\n\x11subject_client_id\x18\x03\x20\x01(\tR\x0fsubjectClientIdB\x1c\
    \xf2\xde\x1f\x18yaml:\"subject_client_id\"\x12Q\n\x14substitute_client_i\
    d\x18\x04\x20\x01(\tR\x12substituteClientIdB\x1f\xf2\xde\x1f\x1byaml:\"s\
    ubstitute_client_id\":\x04\x88\xa0\x1f\0\"\xfb\x01\n\x0fUpgradeProposal\
    \x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x20\n\x0bdescriptio\
    n\x18\x02\x20\x01(\tR\x0bdescription\x126\n\x04plan\x18\x03\x20\x01(\x0b\
    2\x1c.cosmos.upgrade.v1beta1.PlanR\x04planB\x04\xc8\xde\x1f\0\x12j\n\x15\
    upgraded_client_state\x18\x04\x20\x01(\x0b2\x14.google.protobuf.AnyR\x13\
    upgradedClientStateB\x20\xf2\xde\x1f\x1cyaml:\"upgraded_client_state\":\
    \x0c\x88\xa0\x1f\0\x98\xa0\x1f\0\xe8\xa0\x1f\x01\"\x9c\x01\n\x06Height\
    \x12C\n\x0frevision_number\x18\x01\x20\x01(\x04R\x0erevisionNumberB\x1a\
    \xf2\xde\x1f\x16yaml:\"revision_number\"\x12C\n\x0frevision_height\x18\
    \x02\x20\x01(\x04R\x0erevisionHeightB\x1a\xf2\xde\x1f\x16yaml:\"revision\
    _height\":\x08\x88\xa0\x1f\0\x98\xa0\x1f\0\"M\n\x06Params\x12C\n\x0fallo\
    wed_clients\x18\x01\x20\x03(\tR\x0eallowedClientsB\x1a\xf2\xde\x1f\x16ya\
    ml:\"allowed_clients\"B:Z8github.com/cosmos/ibc-go/v3/modules/core/02-cl\
    ient/typesJ\xb7\x1f\n\x06\x12\x04\0\0c\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x02\0\x1b\n\x08\n\x01\x08\x12\x03\x04\0O\n\
    \t\n\x02\x08\x0b\x12\x03\x04\0O\n\t\n\x02\x03\0\x12\x03\x06\0\x1e\n\t\n\
    \x02\x03\x01\x12\x03\x07\0#\n\t\n\x02\x03\x02\x12\x03\x08\0.\ng\n\x02\
    \x04\0\x12\x04\x0c\0\x11\x01\x1a[\x20IdentifiedClientState\x20defines\
    \x20a\x20client\x20state\x20with\x20an\x20additional\x20client\n\x20iden\
    tifier\x20field.\n\n\n\n\x03\x04\0\x01\x12\x03\x0c\x08\x1d\n\x20\n\x04\
    \x04\0\x02\0\x12\x03\x0e\x02E\x1a\x13\x20client\x20identifier\n\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03\x0e\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x0e\t\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0e\x15\x16\n\x0c\n\
    \x05\x04\0\x02\0\x08\x12\x03\x0e\x17D\n\x0f\n\x08\x04\0\x02\0\x08\xee\
    \xfb\x03\x12\x03\x0e\x18C\n\x1b\n\x04\x04\0\x02\x01\x12\x03\x10\x02X\x1a\
    \x0e\x20client\x20state\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x10\x02\
    \x15\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x10\x16\"\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03\x10%&\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03\x10'W\n\
    \x0f\n\x08\x04\0\x02\x01\x08\xee\xfb\x03\x12\x03\x10(V\nb\n\x02\x04\x01\
    \x12\x04\x15\0\x1a\x01\x1aV\x20ConsensusStateWithHeight\x20defines\x20a\
    \x20consensus\x20state\x20with\x20an\x20additional\x20height\n\x20field.\
    \n\n\n\n\x03\x04\x01\x01\x12\x03\x15\x08\x20\n%\n\x04\x04\x01\x02\0\x12\
    \x03\x17\x023\x1a\x18\x20consensus\x20state\x20height\n\n\x0c\n\x05\x04\
    \x01\x02\0\x06\x12\x03\x17\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\
    \x17\t\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x17\x12\x13\n\x0c\n\x05\
    \x04\x01\x02\0\x08\x12\x03\x17\x142\n\x0f\n\x08\x04\x01\x02\0\x08\xe9\
    \xfb\x03\x12\x03\x17\x151\n\x1e\n\x04\x04\x01\x02\x01\x12\x03\x19\x02^\
    \x1a\x11\x20consensus\x20state\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\
    \x19\x02\x15\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x19\x16%\n\x0c\n\
    \x05\x04\x01\x02\x01\x03\x12\x03\x19()\n\x0c\n\x05\x04\x01\x02\x01\x08\
    \x12\x03\x19*]\n\x0f\n\x08\x04\x01\x02\x01\x08\xee\xfb\x03\x12\x03\x19+\
    \\\n`\n\x02\x04\x02\x12\x04\x1e\0$\x01\x1aT\x20ClientConsensusStates\x20\
    defines\x20all\x20the\x20stored\x20consensus\x20states\x20for\x20a\x20gi\
    ven\n\x20client.\n\n\n\n\x03\x04\x02\x01\x12\x03\x1e\x08\x1d\n\x20\n\x04\
    \x04\x02\x02\0\x12\x03\x20\x02E\x1a\x13\x20client\x20identifier\n\n\x0c\
    \n\x05\x04\x02\x02\0\x05\x12\x03\x20\x02\x08\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03\x20\t\x12\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x20\x15\x16\
    \n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03\x20\x17D\n\x0f\n\x08\x04\x02\x02\
    \0\x08\xee\xfb\x03\x12\x03\x20\x18C\nM\n\x04\x04\x02\x02\x01\x12\x04\"\
    \x02#Y\x1a?\x20consensus\x20states\x20and\x20their\x20heights\x20associa\
    ted\x20with\x20the\x20client\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03\"\
    \x02\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03\"\x0b#\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03\"$4\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\"78\
    \n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x03#\x06X\n\x0f\n\x08\x04\x02\x02\
    \x01\x08\xee\xfb\x03\x12\x03#\x079\n\x0f\n\x08\x04\x02\x02\x01\x08\xe9\
    \xfb\x03\x12\x03#;W\n\xcf\x02\n\x02\x04\x03\x12\x04*\05\x01\x1a\xc2\x02\
    \x20ClientUpdateProposal\x20is\x20a\x20governance\x20proposal.\x20If\x20\
    it\x20passes,\x20the\x20substitute\n\x20client's\x20latest\x20consensus\
    \x20state\x20is\x20copied\x20over\x20to\x20the\x20subject\x20client.\x20\
    The\x20proposal\n\x20handler\x20may\x20fail\x20if\x20the\x20subject\x20a\
    nd\x20the\x20substitute\x20do\x20not\x20match\x20in\x20client\x20and\n\
    \x20chain\x20parameters\x20(with\x20exception\x20to\x20latest\x20height,\
    \x20frozen\x20height,\x20and\x20chain-id).\n\n\n\n\x03\x04\x03\x01\x12\
    \x03*\x08\x1c\n\n\n\x03\x04\x03\x07\x12\x03+\x02-\n\r\n\x06\x04\x03\x07\
    \x81\xf4\x03\x12\x03+\x02-\n/\n\x04\x04\x03\x02\0\x12\x03-\x02\x13\x1a\"\
    \x20the\x20title\x20of\x20the\x20update\x20proposal\n\n\x0c\n\x05\x04\
    \x03\x02\0\x05\x12\x03-\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03-\t\
    \x0e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03-\x11\x12\n.\n\x04\x04\x03\x02\
    \x01\x12\x03/\x02\x19\x1a!\x20the\x20description\x20of\x20the\x20proposa\
    l\n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03/\x02\x08\n\x0c\n\x05\x04\x03\
    \x02\x01\x01\x12\x03/\t\x14\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03/\x17\
    \x18\nX\n\x04\x04\x03\x02\x02\x12\x031\x02U\x1aK\x20the\x20client\x20ide\
    ntifier\x20for\x20the\x20client\x20to\x20be\x20updated\x20if\x20the\x20p\
    roposal\x20passes\n\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x031\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x02\x01\x12\x031\t\x1a\n\x0c\n\x05\x04\x03\x02\
    \x02\x03\x12\x031\x1d\x1e\n\x0c\n\x05\x04\x03\x02\x02\x08\x12\x031\x1fT\
    \n\x0f\n\x08\x04\x03\x02\x02\x08\xee\xfb\x03\x12\x031\x20S\nb\n\x04\x04\
    \x03\x02\x03\x12\x034\x02[\x1aU\x20the\x20substitute\x20client\x20identi\
    fier\x20for\x20the\x20client\x20standing\x20in\x20for\x20the\x20subject\
    \n\x20client\n\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x034\x02\x08\n\x0c\n\
    \x05\x04\x03\x02\x03\x01\x12\x034\t\x1d\n\x0c\n\x05\x04\x03\x02\x03\x03\
    \x12\x034\x20!\n\x0c\n\x05\x04\x03\x02\x03\x08\x12\x034\"Z\n\x0f\n\x08\
    \x04\x03\x02\x03\x08\xee\xfb\x03\x12\x034#Y\n\\\n\x02\x04\x04\x12\x049\0\
    I\x01\x1aP\x20UpgradeProposal\x20is\x20a\x20gov\x20Content\x20type\x20fo\
    r\x20initiating\x20an\x20IBC\x20breaking\n\x20upgrade.\n\n\n\n\x03\x04\
    \x04\x01\x12\x039\x08\x17\n\n\n\x03\x04\x04\x07\x12\x03:\x02.\n\r\n\x06\
    \x04\x04\x07\x81\xf4\x03\x12\x03:\x02.\n\n\n\x03\x04\x04\x07\x12\x03;\
    \x02.\n\r\n\x06\x04\x04\x07\x83\xf4\x03\x12\x03;\x02.\n\n\n\x03\x04\x04\
    \x07\x12\x03<\x02-\n\r\n\x06\x04\x04\x07\x8d\xf4\x03\x12\x03<\x02-\n\x0b\
    \n\x04\x04\x04\x02\0\x12\x03>\x02.\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03\
    >\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03>\x1e#\n\x0c\n\x05\x04\
    \x04\x02\0\x03\x12\x03>,-\n\x0b\n\x04\x04\x04\x02\x01\x12\x03?\x02.\n\
    \x0c\n\x05\x04\x04\x02\x01\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\x04\x02\
    \x01\x01\x12\x03?\x1e)\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03?,-\n\x0b\
    \n\x04\x04\x04\x02\x02\x12\x03@\x02M\n\x0c\n\x05\x04\x04\x02\x02\x06\x12\
    \x03@\x02\x1d\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03@\x1e\"\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03@,-\n\x0c\n\x05\x04\x04\x02\x02\x08\x12\x03@\
    .L\n\x0f\n\x08\x04\x04\x02\x02\x08\xe9\xfb\x03\x12\x03@/K\n\x9f\x03\n\
    \x04\x04\x04\x02\x03\x12\x03H\x02j\x1a\x91\x03\x20An\x20UpgradedClientSt\
    ate\x20must\x20be\x20provided\x20to\x20perform\x20an\x20IBC\x20breaking\
    \x20upgrade.\n\x20This\x20will\x20make\x20the\x20chain\x20commit\x20to\
    \x20the\x20correct\x20upgraded\x20(self)\x20client\x20state\n\x20before\
    \x20the\x20upgrade\x20occurs,\x20so\x20that\x20connecting\x20chains\x20c\
    an\x20verify\x20that\x20the\n\x20new\x20upgraded\x20client\x20is\x20vali\
    d\x20by\x20verifying\x20a\x20proof\x20on\x20the\x20previous\x20version\n\
    \x20of\x20the\x20chain.\x20This\x20will\x20allow\x20IBC\x20connections\
    \x20to\x20persist\x20smoothly\x20across\n\x20planned\x20chain\x20upgrade\
    s\n\n\x0c\n\x05\x04\x04\x02\x03\x06\x12\x03H\x02\x15\n\x0c\n\x05\x04\x04\
    \x02\x03\x01\x12\x03H\x16+\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03H./\n\
    \x0c\n\x05\x04\x04\x02\x03\x08\x12\x03H0i\n\x0f\n\x08\x04\x04\x02\x03\
    \x08\xee\xfb\x03\x12\x03H1h\n\x9c\x04\n\x02\x04\x05\x12\x04U\0]\x01\x1a\
    \x8f\x04\x20Height\x20is\x20a\x20monotonically\x20increasing\x20data\x20\
    type\n\x20that\x20can\x20be\x20compared\x20against\x20another\x20Height\
    \x20for\x20the\x20purposes\x20of\x20updating\x20and\n\x20freezing\x20cli\
    ents\n\n\x20Normally\x20the\x20RevisionHeight\x20is\x20incremented\x20at\
    \x20each\x20height\x20while\x20keeping\n\x20RevisionNumber\x20the\x20sam\
    e.\x20However\x20some\x20consensus\x20algorithms\x20may\x20choose\x20to\
    \n\x20reset\x20the\x20height\x20in\x20certain\x20conditions\x20e.g.\x20h\
    ard\x20forks,\x20state-machine\n\x20breaking\x20changes\x20In\x20these\
    \x20cases,\x20the\x20RevisionNumber\x20is\x20incremented\x20so\x20that\n\
    \x20height\x20continues\x20to\x20be\x20monitonically\x20increasing\x20ev\
    en\x20as\x20the\x20RevisionHeight\n\x20gets\x20reset\n\n\n\n\x03\x04\x05\
    \x01\x12\x03U\x08\x0e\n\n\n\x03\x04\x05\x07\x12\x03V\x02.\n\r\n\x06\x04\
    \x05\x07\x81\xf4\x03\x12\x03V\x02.\n\n\n\x03\x04\x05\x07\x12\x03W\x02.\n\
    \r\n\x06\x04\x05\x07\x83\xf4\x03\x12\x03W\x02.\n;\n\x04\x04\x05\x02\0\
    \x12\x03Z\x02Q\x1a.\x20the\x20revision\x20that\x20the\x20client\x20is\
    \x20currently\x20on\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03Z\x02\x08\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03Z\t\x18\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03Z\x1b\x1c\n\x0c\n\x05\x04\x05\x02\0\x08\x12\x03Z\x1dP\n\x0f\
    \n\x08\x04\x05\x02\0\x08\xee\xfb\x03\x12\x03Z\x1eO\n3\n\x04\x04\x05\x02\
    \x01\x12\x03\\\x02Q\x1a&\x20the\x20height\x20within\x20the\x20given\x20r\
    evision\n\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03\\\x02\x08\n\x0c\n\x05\
    \x04\x05\x02\x01\x01\x12\x03\\\t\x18\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\
    \x03\\\x1b\x1c\n\x0c\n\x05\x04\x05\x02\x01\x08\x12\x03\\\x1dP\n\x0f\n\
    \x08\x04\x05\x02\x01\x08\xee\xfb\x03\x12\x03\\\x1eO\nD\n\x02\x04\x06\x12\
    \x04`\0c\x01\x1a8\x20Params\x20defines\x20the\x20set\x20of\x20IBC\x20lig\
    ht\x20client\x20parameters.\n\n\n\n\x03\x04\x06\x01\x12\x03`\x08\x0e\nN\
    \n\x04\x04\x06\x02\0\x12\x03b\x02Z\x1aA\x20allowed_clients\x20defines\
    \x20the\x20list\x20of\x20allowed\x20client\x20state\x20types.\n\n\x0c\n\
    \x05\x04\x06\x02\0\x04\x12\x03b\x02\n\n\x0c\n\x05\x04\x06\x02\0\x05\x12\
    \x03b\x0b\x11\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03b\x12!\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03b$%\n\x0c\n\x05\x04\x06\x02\0\x08\x12\x03b&Y\n\
    \x0f\n\x08\x04\x06\x02\0\x08\xee\xfb\x03\x12\x03b'Xb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::upgrade::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(IdentifiedClientState::generated_message_descriptor_data());
            messages.push(ConsensusStateWithHeight::generated_message_descriptor_data());
            messages.push(ClientConsensusStates::generated_message_descriptor_data());
            messages.push(ClientUpdateProposal::generated_message_descriptor_data());
            messages.push(UpgradeProposal::generated_message_descriptor_data());
            messages.push(Height::generated_message_descriptor_data());
            messages.push(Params::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
