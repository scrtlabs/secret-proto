// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `secret/compute/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  QueryContractInfoRequest is the request type for the Query/ContractInfo RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractInfoRequest)
pub struct QueryContractInfoRequest {
    // message fields
    ///  address is the canonical address of the contract to query
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractInfoRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractInfoRequest {
    fn default() -> &'a QueryContractInfoRequest {
        <QueryContractInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractInfoRequest {
    pub fn new() -> QueryContractInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &QueryContractInfoRequest| { &m.address },
            |m: &mut QueryContractInfoRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractInfoRequest>(
            "QueryContractInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractInfoRequest {
    const NAME: &'static str = "QueryContractInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractInfoRequest {
        QueryContractInfoRequest::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractInfoRequest {
        static instance: QueryContractInfoRequest = QueryContractInfoRequest {
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryContractInfoResponse is the response type for the Query/ContractInfo RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractInfoResponse)
pub struct QueryContractInfoResponse {
    // message fields
    ///  address is the canonical address of the contract
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractInfoResponse.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractInfoResponse.ContractInfo)
    pub ContractInfo: ::protobuf::MessageField<super::types::ContractInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractInfoResponse {
    fn default() -> &'a QueryContractInfoResponse {
        <QueryContractInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractInfoResponse {
    pub fn new() -> QueryContractInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &QueryContractInfoResponse| { &m.address },
            |m: &mut QueryContractInfoResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::ContractInfo>(
            "ContractInfo",
            |m: &QueryContractInfoResponse| { &m.ContractInfo },
            |m: &mut QueryContractInfoResponse| { &mut m.ContractInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractInfoResponse>(
            "QueryContractInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractInfoResponse {
    const NAME: &'static str = "QueryContractInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ContractInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if let Some(v) = self.ContractInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if let Some(v) = self.ContractInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractInfoResponse {
        QueryContractInfoResponse::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.ContractInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractInfoResponse {
        static instance: QueryContractInfoResponse = QueryContractInfoResponse {
            address: ::std::vec::Vec::new(),
            ContractInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractHistoryRequest)
pub struct QueryContractHistoryRequest {
    // message fields
    ///  address is the canonical address of the contract to query
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractHistoryRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractHistoryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractHistoryRequest {
    fn default() -> &'a QueryContractHistoryRequest {
        <QueryContractHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractHistoryRequest {
    pub fn new() -> QueryContractHistoryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &QueryContractHistoryRequest| { &m.address },
            |m: &mut QueryContractHistoryRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractHistoryRequest>(
            "QueryContractHistoryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractHistoryRequest {
    const NAME: &'static str = "QueryContractHistoryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractHistoryRequest {
        QueryContractHistoryRequest::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractHistoryRequest {
        static instance: QueryContractHistoryRequest = QueryContractHistoryRequest {
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractHistoryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractHistoryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractHistoryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractsByCodeRequest)
pub struct QueryContractsByCodeRequest {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractsByCodeRequest.code_id)
    pub code_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractsByCodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractsByCodeRequest {
    fn default() -> &'a QueryContractsByCodeRequest {
        <QueryContractsByCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractsByCodeRequest {
    pub fn new() -> QueryContractsByCodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code_id",
            |m: &QueryContractsByCodeRequest| { &m.code_id },
            |m: &mut QueryContractsByCodeRequest| { &mut m.code_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractsByCodeRequest>(
            "QueryContractsByCodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractsByCodeRequest {
    const NAME: &'static str = "QueryContractsByCodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code_id != 0 {
            os.write_uint64(1, self.code_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractsByCodeRequest {
        QueryContractsByCodeRequest::new()
    }

    fn clear(&mut self) {
        self.code_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractsByCodeRequest {
        static instance: QueryContractsByCodeRequest = QueryContractsByCodeRequest {
            code_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractsByCodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractsByCodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractsByCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractsByCodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ContractInfoWithAddress adds the address (key) to the ContractInfo representation
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.ContractInfoWithAddress)
pub struct ContractInfoWithAddress {
    // message fields
    ///  address is the canonical address of the contract
    // @@protoc_insertion_point(field:secret.compute.v1beta1.ContractInfoWithAddress.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.ContractInfoWithAddress.ContractInfo)
    pub ContractInfo: ::protobuf::MessageField<super::types::ContractInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.ContractInfoWithAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContractInfoWithAddress {
    fn default() -> &'a ContractInfoWithAddress {
        <ContractInfoWithAddress as ::protobuf::Message>::default_instance()
    }
}

impl ContractInfoWithAddress {
    pub fn new() -> ContractInfoWithAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &ContractInfoWithAddress| { &m.address },
            |m: &mut ContractInfoWithAddress| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::ContractInfo>(
            "ContractInfo",
            |m: &ContractInfoWithAddress| { &m.ContractInfo },
            |m: &mut ContractInfoWithAddress| { &mut m.ContractInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContractInfoWithAddress>(
            "ContractInfoWithAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContractInfoWithAddress {
    const NAME: &'static str = "ContractInfoWithAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ContractInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if let Some(v) = self.ContractInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if let Some(v) = self.ContractInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContractInfoWithAddress {
        ContractInfoWithAddress::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.ContractInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContractInfoWithAddress {
        static instance: ContractInfoWithAddress = ContractInfoWithAddress {
            address: ::std::vec::Vec::new(),
            ContractInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContractInfoWithAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContractInfoWithAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContractInfoWithAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractInfoWithAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractsByCodeResponse)
pub struct QueryContractsByCodeResponse {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractsByCodeResponse.contract_infos)
    pub contract_infos: ::std::vec::Vec<ContractInfoWithAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractsByCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractsByCodeResponse {
    fn default() -> &'a QueryContractsByCodeResponse {
        <QueryContractsByCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractsByCodeResponse {
    pub fn new() -> QueryContractsByCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contract_infos",
            |m: &QueryContractsByCodeResponse| { &m.contract_infos },
            |m: &mut QueryContractsByCodeResponse| { &mut m.contract_infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractsByCodeResponse>(
            "QueryContractsByCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractsByCodeResponse {
    const NAME: &'static str = "QueryContractsByCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.contract_infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.contract_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.contract_infos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractsByCodeResponse {
        QueryContractsByCodeResponse::new()
    }

    fn clear(&mut self) {
        self.contract_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractsByCodeResponse {
        static instance: QueryContractsByCodeResponse = QueryContractsByCodeResponse {
            contract_infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractsByCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractsByCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractsByCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractsByCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QuerySmartContractStateRequest)
pub struct QuerySmartContractStateRequest {
    // message fields
    ///  address is the canonical address of the contract
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QuerySmartContractStateRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QuerySmartContractStateRequest.query_data)
    pub query_data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QuerySmartContractStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuerySmartContractStateRequest {
    fn default() -> &'a QuerySmartContractStateRequest {
        <QuerySmartContractStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySmartContractStateRequest {
    pub fn new() -> QuerySmartContractStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &QuerySmartContractStateRequest| { &m.address },
            |m: &mut QuerySmartContractStateRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query_data",
            |m: &QuerySmartContractStateRequest| { &m.query_data },
            |m: &mut QuerySmartContractStateRequest| { &mut m.query_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuerySmartContractStateRequest>(
            "QuerySmartContractStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuerySmartContractStateRequest {
    const NAME: &'static str = "QuerySmartContractStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.query_data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.query_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.query_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.query_data.is_empty() {
            os.write_bytes(2, &self.query_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuerySmartContractStateRequest {
        QuerySmartContractStateRequest::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.query_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuerySmartContractStateRequest {
        static instance: QuerySmartContractStateRequest = QuerySmartContractStateRequest {
            address: ::std::vec::Vec::new(),
            query_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuerySmartContractStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuerySmartContractStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuerySmartContractStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySmartContractStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractAddressByLabelRequest)
pub struct QueryContractAddressByLabelRequest {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractAddressByLabelRequest.label)
    pub label: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractAddressByLabelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractAddressByLabelRequest {
    fn default() -> &'a QueryContractAddressByLabelRequest {
        <QueryContractAddressByLabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractAddressByLabelRequest {
    pub fn new() -> QueryContractAddressByLabelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &QueryContractAddressByLabelRequest| { &m.label },
            |m: &mut QueryContractAddressByLabelRequest| { &mut m.label },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractAddressByLabelRequest>(
            "QueryContractAddressByLabelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractAddressByLabelRequest {
    const NAME: &'static str = "QueryContractAddressByLabelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractAddressByLabelRequest {
        QueryContractAddressByLabelRequest::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractAddressByLabelRequest {
        static instance: QueryContractAddressByLabelRequest = QueryContractAddressByLabelRequest {
            label: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractAddressByLabelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractAddressByLabelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractAddressByLabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractAddressByLabelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractKeyRequest)
pub struct QueryContractKeyRequest {
    // message fields
    ///  address is the canonical address of the contract
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractKeyRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractKeyRequest {
    fn default() -> &'a QueryContractKeyRequest {
        <QueryContractKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractKeyRequest {
    pub fn new() -> QueryContractKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &QueryContractKeyRequest| { &m.address },
            |m: &mut QueryContractKeyRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractKeyRequest>(
            "QueryContractKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractKeyRequest {
    const NAME: &'static str = "QueryContractKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractKeyRequest {
        QueryContractKeyRequest::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractKeyRequest {
        static instance: QueryContractKeyRequest = QueryContractKeyRequest {
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractHashRequest)
pub struct QueryContractHashRequest {
    // message fields
    ///  address is the canonical address of the contract
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractHashRequest.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractHashRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractHashRequest {
    fn default() -> &'a QueryContractHashRequest {
        <QueryContractHashRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractHashRequest {
    pub fn new() -> QueryContractHashRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &QueryContractHashRequest| { &m.address },
            |m: &mut QueryContractHashRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractHashRequest>(
            "QueryContractHashRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractHashRequest {
    const NAME: &'static str = "QueryContractHashRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractHashRequest {
        QueryContractHashRequest::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractHashRequest {
        static instance: QueryContractHashRequest = QueryContractHashRequest {
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractHashRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractHashRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractHashRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractHashRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QuerySmartContractStateResponse)
pub struct QuerySmartContractStateResponse {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QuerySmartContractStateResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QuerySmartContractStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuerySmartContractStateResponse {
    fn default() -> &'a QuerySmartContractStateResponse {
        <QuerySmartContractStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySmartContractStateResponse {
    pub fn new() -> QuerySmartContractStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &QuerySmartContractStateResponse| { &m.data },
            |m: &mut QuerySmartContractStateResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuerySmartContractStateResponse>(
            "QuerySmartContractStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuerySmartContractStateResponse {
    const NAME: &'static str = "QuerySmartContractStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuerySmartContractStateResponse {
        QuerySmartContractStateResponse::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuerySmartContractStateResponse {
        static instance: QuerySmartContractStateResponse = QuerySmartContractStateResponse {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuerySmartContractStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuerySmartContractStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuerySmartContractStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySmartContractStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryCodeRequest)
pub struct QueryCodeRequest {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryCodeRequest.code_id)
    pub code_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryCodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryCodeRequest {
    fn default() -> &'a QueryCodeRequest {
        <QueryCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryCodeRequest {
    pub fn new() -> QueryCodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code_id",
            |m: &QueryCodeRequest| { &m.code_id },
            |m: &mut QueryCodeRequest| { &mut m.code_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryCodeRequest>(
            "QueryCodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryCodeRequest {
    const NAME: &'static str = "QueryCodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code_id != 0 {
            os.write_uint64(1, self.code_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryCodeRequest {
        QueryCodeRequest::new()
    }

    fn clear(&mut self) {
        self.code_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryCodeRequest {
        static instance: QueryCodeRequest = QueryCodeRequest {
            code_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryCodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryCodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.CodeInfoResponse)
pub struct CodeInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.CodeInfoResponse.code_id)
    pub code_id: u64,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.CodeInfoResponse.creator)
    pub creator: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.CodeInfoResponse.data_hash)
    pub data_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.CodeInfoResponse.source)
    pub source: ::std::string::String,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.CodeInfoResponse.builder)
    pub builder: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.CodeInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeInfoResponse {
    fn default() -> &'a CodeInfoResponse {
        <CodeInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CodeInfoResponse {
    pub fn new() -> CodeInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code_id",
            |m: &CodeInfoResponse| { &m.code_id },
            |m: &mut CodeInfoResponse| { &mut m.code_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &CodeInfoResponse| { &m.creator },
            |m: &mut CodeInfoResponse| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_hash",
            |m: &CodeInfoResponse| { &m.data_hash },
            |m: &mut CodeInfoResponse| { &mut m.data_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &CodeInfoResponse| { &m.source },
            |m: &mut CodeInfoResponse| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "builder",
            |m: &CodeInfoResponse| { &m.builder },
            |m: &mut CodeInfoResponse| { &mut m.builder },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeInfoResponse>(
            "CodeInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodeInfoResponse {
    const NAME: &'static str = "CodeInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code_id = is.read_uint64()?;
                },
                18 => {
                    self.creator = is.read_bytes()?;
                },
                26 => {
                    self.data_hash = is.read_bytes()?;
                },
                34 => {
                    self.source = is.read_string()?;
                },
                42 => {
                    self.builder = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.code_id);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.creator);
        }
        if !self.data_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data_hash);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.source);
        }
        if !self.builder.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.builder);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code_id != 0 {
            os.write_uint64(1, self.code_id)?;
        }
        if !self.creator.is_empty() {
            os.write_bytes(2, &self.creator)?;
        }
        if !self.data_hash.is_empty() {
            os.write_bytes(3, &self.data_hash)?;
        }
        if !self.source.is_empty() {
            os.write_string(4, &self.source)?;
        }
        if !self.builder.is_empty() {
            os.write_string(5, &self.builder)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeInfoResponse {
        CodeInfoResponse::new()
    }

    fn clear(&mut self) {
        self.code_id = 0;
        self.creator.clear();
        self.data_hash.clear();
        self.source.clear();
        self.builder.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeInfoResponse {
        static instance: CodeInfoResponse = CodeInfoResponse {
            code_id: 0,
            creator: ::std::vec::Vec::new(),
            data_hash: ::std::vec::Vec::new(),
            source: ::std::string::String::new(),
            builder: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodeInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryCodeResponse)
pub struct QueryCodeResponse {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryCodeResponse.code_info)
    pub code_info: ::protobuf::MessageField<CodeInfoResponse>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryCodeResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryCodeResponse {
    fn default() -> &'a QueryCodeResponse {
        <QueryCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryCodeResponse {
    pub fn new() -> QueryCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CodeInfoResponse>(
            "code_info",
            |m: &QueryCodeResponse| { &m.code_info },
            |m: &mut QueryCodeResponse| { &mut m.code_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &QueryCodeResponse| { &m.data },
            |m: &mut QueryCodeResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryCodeResponse>(
            "QueryCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryCodeResponse {
    const NAME: &'static str = "QueryCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.code_info)?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryCodeResponse {
        QueryCodeResponse::new()
    }

    fn clear(&mut self) {
        self.code_info.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryCodeResponse {
        static instance: QueryCodeResponse = QueryCodeResponse {
            code_info: ::protobuf::MessageField::none(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryCodesResponse)
pub struct QueryCodesResponse {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryCodesResponse.code_infos)
    pub code_infos: ::std::vec::Vec<CodeInfoResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryCodesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryCodesResponse {
    fn default() -> &'a QueryCodesResponse {
        <QueryCodesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryCodesResponse {
    pub fn new() -> QueryCodesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "code_infos",
            |m: &QueryCodesResponse| { &m.code_infos },
            |m: &mut QueryCodesResponse| { &mut m.code_infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryCodesResponse>(
            "QueryCodesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryCodesResponse {
    const NAME: &'static str = "QueryCodesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code_infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.code_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.code_infos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryCodesResponse {
        QueryCodesResponse::new()
    }

    fn clear(&mut self) {
        self.code_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryCodesResponse {
        static instance: QueryCodesResponse = QueryCodesResponse {
            code_infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryCodesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryCodesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryCodesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCodesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractAddressByLabelResponse)
pub struct QueryContractAddressByLabelResponse {
    // message fields
    ///  address is the canonical address of the contract
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractAddressByLabelResponse.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractAddressByLabelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractAddressByLabelResponse {
    fn default() -> &'a QueryContractAddressByLabelResponse {
        <QueryContractAddressByLabelResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractAddressByLabelResponse {
    pub fn new() -> QueryContractAddressByLabelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &QueryContractAddressByLabelResponse| { &m.address },
            |m: &mut QueryContractAddressByLabelResponse| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractAddressByLabelResponse>(
            "QueryContractAddressByLabelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractAddressByLabelResponse {
    const NAME: &'static str = "QueryContractAddressByLabelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractAddressByLabelResponse {
        QueryContractAddressByLabelResponse::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractAddressByLabelResponse {
        static instance: QueryContractAddressByLabelResponse = QueryContractAddressByLabelResponse {
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractAddressByLabelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractAddressByLabelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractAddressByLabelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractAddressByLabelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractKeyResponse)
pub struct QueryContractKeyResponse {
    // message fields
    ///  address is the address of the contract
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractKeyResponse.key)
    pub key: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractKeyResponse {
    fn default() -> &'a QueryContractKeyResponse {
        <QueryContractKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractKeyResponse {
    pub fn new() -> QueryContractKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &QueryContractKeyResponse| { &m.key },
            |m: &mut QueryContractKeyResponse| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractKeyResponse>(
            "QueryContractKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractKeyResponse {
    const NAME: &'static str = "QueryContractKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractKeyResponse {
        QueryContractKeyResponse::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractKeyResponse {
        static instance: QueryContractKeyResponse = QueryContractKeyResponse {
            key: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.QueryContractHashResponse)
pub struct QueryContractHashResponse {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.QueryContractHashResponse.code_hash)
    pub code_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.QueryContractHashResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryContractHashResponse {
    fn default() -> &'a QueryContractHashResponse {
        <QueryContractHashResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryContractHashResponse {
    pub fn new() -> QueryContractHashResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code_hash",
            |m: &QueryContractHashResponse| { &m.code_hash },
            |m: &mut QueryContractHashResponse| { &mut m.code_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryContractHashResponse>(
            "QueryContractHashResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryContractHashResponse {
    const NAME: &'static str = "QueryContractHashResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.code_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code_hash.is_empty() {
            os.write_bytes(1, &self.code_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryContractHashResponse {
        QueryContractHashResponse::new()
    }

    fn clear(&mut self) {
        self.code_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryContractHashResponse {
        static instance: QueryContractHashResponse = QueryContractHashResponse {
            code_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryContractHashResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryContractHashResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryContractHashResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContractHashResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DecryptedAnswer is a struct that represents a decrypted tx-query
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:secret.compute.v1beta1.DecryptedAnswer)
pub struct DecryptedAnswer {
    // message fields
    // @@protoc_insertion_point(field:secret.compute.v1beta1.DecryptedAnswer.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.DecryptedAnswer.input)
    pub input: ::std::string::String,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.DecryptedAnswer.output_data)
    pub output_data: ::std::string::String,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.DecryptedAnswer.output_data_as_string)
    pub output_data_as_string: ::std::string::String,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.DecryptedAnswer.output_logs)
    pub output_logs: ::std::vec::Vec<super::abci::StringEvent>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.DecryptedAnswer.output_error)
    pub output_error: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:secret.compute.v1beta1.DecryptedAnswer.plaintext_error)
    pub plaintext_error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:secret.compute.v1beta1.DecryptedAnswer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DecryptedAnswer {
    fn default() -> &'a DecryptedAnswer {
        <DecryptedAnswer as ::protobuf::Message>::default_instance()
    }
}

impl DecryptedAnswer {
    pub fn new() -> DecryptedAnswer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &DecryptedAnswer| { &m.type_ },
            |m: &mut DecryptedAnswer| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &DecryptedAnswer| { &m.input },
            |m: &mut DecryptedAnswer| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_data",
            |m: &DecryptedAnswer| { &m.output_data },
            |m: &mut DecryptedAnswer| { &mut m.output_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_data_as_string",
            |m: &DecryptedAnswer| { &m.output_data_as_string },
            |m: &mut DecryptedAnswer| { &mut m.output_data_as_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_logs",
            |m: &DecryptedAnswer| { &m.output_logs },
            |m: &mut DecryptedAnswer| { &mut m.output_logs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_error",
            |m: &DecryptedAnswer| { &m.output_error },
            |m: &mut DecryptedAnswer| { &mut m.output_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "plaintext_error",
            |m: &DecryptedAnswer| { &m.plaintext_error },
            |m: &mut DecryptedAnswer| { &mut m.plaintext_error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DecryptedAnswer>(
            "DecryptedAnswer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DecryptedAnswer {
    const NAME: &'static str = "DecryptedAnswer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.input = is.read_string()?;
                },
                26 => {
                    self.output_data = is.read_string()?;
                },
                34 => {
                    self.output_data_as_string = is.read_string()?;
                },
                42 => {
                    self.output_logs.push(is.read_message()?);
                },
                50 => {
                    self.output_error = is.read_bytes()?;
                },
                58 => {
                    self.plaintext_error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input);
        }
        if !self.output_data.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.output_data);
        }
        if !self.output_data_as_string.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.output_data_as_string);
        }
        for value in &self.output_logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.output_error.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.output_error);
        }
        if !self.plaintext_error.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.plaintext_error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if !self.input.is_empty() {
            os.write_string(2, &self.input)?;
        }
        if !self.output_data.is_empty() {
            os.write_string(3, &self.output_data)?;
        }
        if !self.output_data_as_string.is_empty() {
            os.write_string(4, &self.output_data_as_string)?;
        }
        for v in &self.output_logs {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if !self.output_error.is_empty() {
            os.write_bytes(6, &self.output_error)?;
        }
        if !self.plaintext_error.is_empty() {
            os.write_string(7, &self.plaintext_error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DecryptedAnswer {
        DecryptedAnswer::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.input.clear();
        self.output_data.clear();
        self.output_data_as_string.clear();
        self.output_logs.clear();
        self.output_error.clear();
        self.plaintext_error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DecryptedAnswer {
        static instance: DecryptedAnswer = DecryptedAnswer {
            type_: ::std::string::String::new(),
            input: ::std::string::String::new(),
            output_data: ::std::string::String::new(),
            output_data_as_string: ::std::string::String::new(),
            output_logs: ::std::vec::Vec::new(),
            output_error: ::std::vec::Vec::new(),
            plaintext_error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DecryptedAnswer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DecryptedAnswer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DecryptedAnswer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptedAnswer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"secret/compute/v1beta1/query.proto\x12\x16secret.compute.v1beta1\x1a\
    \x14gogoproto/gogo.proto\x1a\"secret/compute/v1beta1/types.proto\x1a\x1b\
    google/protobuf/empty.proto\x1a\x1cgoogle/api/annotations.proto\x1a#cosm\
    os/base/abci/v1beta1/abci.proto\"g\n\x18QueryContractInfoRequest\x12K\n\
    \x07address\x18\x01\x20\x01(\x0cR\x07addressB1\xfa\xde\x1f-github.com/co\
    smos/cosmos-sdk/types.AccAddress\"\xbc\x01\n\x19QueryContractInfoRespons\
    e\x12K\n\x07address\x18\x01\x20\x01(\x0cR\x07addressB1\xfa\xde\x1f-githu\
    b.com/cosmos/cosmos-sdk/types.AccAddress\x12R\n\x0cContractInfo\x18\x02\
    \x20\x01(\x0b2$.secret.compute.v1beta1.ContractInfoR\x0cContractInfoB\
    \x08\xd0\xde\x1f\x01\xea\xde\x1f\0\"j\n\x1bQueryContractHistoryRequest\
    \x12K\n\x07address\x18\x01\x20\x01(\x0cR\x07addressB1\xfa\xde\x1f-github\
    .com/cosmos/cosmos-sdk/types.AccAddress\"6\n\x1bQueryContractsByCodeRequ\
    est\x12\x17\n\x07code_id\x18\x01\x20\x01(\x04R\x06codeId\"\xba\x01\n\x17\
    ContractInfoWithAddress\x12K\n\x07address\x18\x01\x20\x01(\x0cR\x07addre\
    ssB1\xfa\xde\x1f-github.com/cosmos/cosmos-sdk/types.AccAddress\x12R\n\
    \x0cContractInfo\x18\x02\x20\x01(\x0b2$.secret.compute.v1beta1.ContractI\
    nfoR\x0cContractInfoB\x08\xd0\xde\x1f\x01\xea\xde\x1f\0\"|\n\x1cQueryCon\
    tractsByCodeResponse\x12\\\n\x0econtract_infos\x18\x01\x20\x03(\x0b2/.se\
    cret.compute.v1beta1.ContractInfoWithAddressR\rcontractInfosB\x04\xc8\
    \xde\x1f\0\"\x8c\x01\n\x1eQuerySmartContractStateRequest\x12K\n\x07addre\
    ss\x18\x01\x20\x01(\x0cR\x07addressB1\xfa\xde\x1f-github.com/cosmos/cosm\
    os-sdk/types.AccAddress\x12\x1d\n\nquery_data\x18\x02\x20\x01(\x0cR\tque\
    ryData\":\n\"QueryContractAddressByLabelRequest\x12\x14\n\x05label\x18\
    \x01\x20\x01(\tR\x05label\"f\n\x17QueryContractKeyRequest\x12K\n\x07addr\
    ess\x18\x01\x20\x01(\x0cR\x07addressB1\xfa\xde\x1f-github.com/cosmos/cos\
    mos-sdk/types.AccAddress\"g\n\x18QueryContractHashRequest\x12K\n\x07addr\
    ess\x18\x01\x20\x01(\x0cR\x07addressB1\xfa\xde\x1f-github.com/cosmos/cos\
    mos-sdk/types.AccAddress\"5\n\x1fQuerySmartContractStateResponse\x12\x12\
    \n\x04data\x18\x01\x20\x01(\x0cR\x04data\"+\n\x10QueryCodeRequest\x12\
    \x17\n\x07code_id\x18\x01\x20\x01(\x04R\x06codeId\"\x93\x02\n\x10CodeInf\
    oResponse\x12)\n\x07code_id\x18\x01\x20\x01(\x04R\x06codeIdB\x10\xe2\xde\
    \x1f\x06CodeID\xea\xde\x1f\x02id\x12K\n\x07creator\x18\x02\x20\x01(\x0cR\
    \x07creatorB1\xfa\xde\x1f-github.com/cosmos/cosmos-sdk/types.AccAddress\
    \x12U\n\tdata_hash\x18\x03\x20\x01(\x0cR\x08dataHashB8\xfa\xde\x1f4githu\
    b.com/tendermint/tendermint/libs/bytes.HexBytes\x12\x16\n\x06source\x18\
    \x04\x20\x01(\tR\x06source\x12\x18\n\x07builder\x18\x05\x20\x01(\tR\x07b\
    uilder\"\x82\x01\n\x11QueryCodeResponse\x12O\n\tcode_info\x18\x01\x20\
    \x01(\x0b2(.secret.compute.v1beta1.CodeInfoResponseR\x08codeInfoB\x08\
    \xd0\xde\x1f\x01\xea\xde\x1f\0\x12\x1c\n\x04data\x18\x02\x20\x01(\x0cR\
    \x04dataB\x08\xea\xde\x1f\x04data\"c\n\x12QueryCodesResponse\x12M\n\ncod\
    e_infos\x18\x01\x20\x03(\x0b2(.secret.compute.v1beta1.CodeInfoResponseR\
    \tcodeInfosB\x04\xc8\xde\x1f\0\"r\n#QueryContractAddressByLabelResponse\
    \x12K\n\x07address\x18\x01\x20\x01(\x0cR\x07addressB1\xfa\xde\x1f-github\
    .com/cosmos/cosmos-sdk/types.AccAddress\"f\n\x18QueryContractKeyResponse\
    \x12J\n\x03key\x18\x01\x20\x01(\x0cR\x03keyB8\xfa\xde\x1f4github.com/ten\
    dermint/tendermint/libs/bytes.HexBytes\"r\n\x19QueryContractHashResponse\
    \x12U\n\tcode_hash\x18\x01\x20\x01(\x0cR\x08codeHashB8\xfa\xde\x1f4githu\
    b.com/tendermint/tendermint/libs/bytes.HexBytes\"\xcd\x02\n\x0fDecrypted\
    Answer\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x14\n\x05input\
    \x18\x02\x20\x01(\tR\x05input\x12\x1f\n\x0boutput_data\x18\x03\x20\x01(\
    \tR\noutputData\x121\n\x15output_data_as_string\x18\x04\x20\x01(\tR\x12o\
    utputDataAsString\x12L\n\x0boutput_logs\x18\x05\x20\x03(\x0b2%.cosmos.ba\
    se.abci.v1beta1.StringEventR\noutputLogsB\x04\xc8\xde\x1f\0\x12?\n\x0cou\
    tput_error\x18\x06\x20\x01(\x0cR\x0boutputErrorB\x1c\xfa\xde\x1f\x18enco\
    ding/json.RawMessage\x12'\n\x0fplaintext_error\x18\x07\x20\x01(\tR\x0epl\
    aintextError:\x04\xe8\xa0\x1f\02\x8a\x06\n\x05Query\x12\xa0\x01\n\x0cCon\
    tractInfo\x120.secret.compute.v1beta1.QueryContractInfoRequest\x1a1.secr\
    et.compute.v1beta1.QueryContractInfoResponse\"+\x82\xd3\xe4\x93\x02%\x12\
    #/compute/v1beta1/contract/{address}\x12\xaf\x01\n\x0fContractsByCode\
    \x123.secret.compute.v1beta1.QueryContractsByCodeRequest\x1a4.secret.com\
    pute.v1beta1.QueryContractsByCodeResponse\"1\x82\xd3\xe4\x93\x02+\x12)/c\
    ompute/v1beta1/code/{code_id}/contracts\x12\xb8\x01\n\x12SmartContractSt\
    ate\x126.secret.compute.v1beta1.QuerySmartContractStateRequest\x1a7.secr\
    et.compute.v1beta1.QuerySmartContractStateResponse\"1\x82\xd3\xe4\x93\
    \x02+\x12)/compute/v1beta1/contract/{address}/smart\x12\x84\x01\n\x04Cod\
    e\x12(.secret.compute.v1beta1.QueryCodeRequest\x1a).secret.compute.v1bet\
    a1.QueryCodeResponse\"'\x82\xd3\xe4\x93\x02!\x12\x1f/compute/v1beta1/cod\
    e/{code_id}\x12j\n\x05Codes\x12\x16.google.protobuf.Empty\x1a*.secret.co\
    mpute.v1beta1.QueryCodesResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\x12\x15/c\
    ompute/v1beta1/codeBEZ;github.com/enigmampc/SecretNetwork/x/compute/inte\
    rnal/types\xc8\xe1\x1e\0\xa8\xe2\x1e\x01J\xb2+\n\x07\x12\x05\0\0\xa7\x01\
    \x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x1f\n\
    \t\n\x02\x03\0\x12\x03\x03\0\x1e\n\t\n\x02\x03\x01\x12\x03\x04\0,\n\t\n\
    \x02\x03\x02\x12\x03\x05\0%\n\t\n\x02\x03\x03\x12\x03\x06\0&\n\t\n\x02\
    \x03\x04\x12\x03\x07\0-\n\x08\n\x01\x08\x12\x03\t\0R\n\t\n\x02\x08\x0b\
    \x12\x03\t\0R\n\x08\n\x01\x08\x12\x03\n\0/\n\x0b\n\x04\x08\x99\xec\x03\
    \x12\x03\n\0/\n\x08\n\x01\x08\x12\x03\x0b\0$\n\x0b\n\x04\x08\xa5\xec\x03\
    \x12\x03\x0b\0$\n=\n\x02\x06\0\x12\x04\x0f\0$\x01\x1a1\x20Query\x20provi\
    des\x20defines\x20the\x20gRPC\x20querier\x20service\n\n\n\n\x03\x06\0\
    \x01\x12\x03\x0f\x08\r\n\x1e\n\x04\x06\0\x02\0\x12\x04\x11\x04\x13\x05\
    \x1a\x10\x20Query\x20contract\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x11\
    \x08\x14\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x11\x16.\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x03\x119R\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03\x12\x08M\n\
    \x11\n\n\x06\0\x02\0\x04\xb0\xca\xbc\"\x02\x12\x03\x12\x08M\n\x1e\n\x04\
    \x06\0\x02\x01\x12\x04\x15\x04\x17\x05\x1a\x10\x20Query\x20contract\n\n\
    \x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x15\x08\x17\n\x0c\n\x05\x06\0\x02\
    \x01\x02\x12\x03\x15\x194\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x15?[\n\
    \x0c\n\x05\x06\0\x02\x01\x04\x12\x03\x16\x08S\n\x11\n\n\x06\0\x02\x01\
    \x04\xb0\xca\xbc\"\x02\x12\x03\x16\x08S\n\x1e\n\x04\x06\0\x02\x02\x12\
    \x04\x19\x04\x1b\x05\x1a\x10\x20Query\x20contract\n\n\x0c\n\x05\x06\0\
    \x02\x02\x01\x12\x03\x19\x08\x1a\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\
    \x19\x1c:\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x19Ed\n\x0c\n\x05\x06\0\
    \x02\x02\x04\x12\x03\x1a\x08S\n\x11\n\n\x06\0\x02\x02\x04\xb0\xca\xbc\"\
    \x02\x12\x03\x1a\x08S\n.\n\x04\x06\0\x02\x03\x12\x04\x1d\x04\x1f\x05\x1a\
    \x20\x20Query\x20a\x20specific\x20contract\x20code\n\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03\x1d\x08\x0c\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\
    \x1d\x0e\x1e\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x1d):\n\x0c\n\x05\x06\
    \0\x02\x03\x04\x12\x03\x1e\x08I\n\x11\n\n\x06\0\x02\x03\x04\xb0\xca\xbc\
    \"\x02\x12\x03\x1e\x08I\n1\n\x04\x06\0\x02\x04\x12\x04!\x04#\x05\x1a#\
    \x20Query\x20all\x20contract\x20codes\x20on-chain\n\n\x0c\n\x05\x06\0\
    \x02\x04\x01\x12\x03!\x08\r\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03!\x0f$\
    \n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03!/A\n\x0c\n\x05\x06\0\x02\x04\x04\
    \x12\x03\"\x08?\n\x11\n\n\x06\0\x02\x04\x04\xb0\xca\xbc\"\x02\x12\x03\"\
    \x08?\n`\n\x02\x04\0\x12\x04'\0*\x01\x1aT\x20QueryContractInfoRequest\
    \x20is\x20the\x20request\x20type\x20for\x20the\x20Query/ContractInfo\x20\
    RPC\x20method\n\n\n\n\x03\x04\0\x01\x12\x03'\x08\x20\nH\n\x04\x04\0\x02\
    \0\x12\x03)\x04_\x1a;\x20address\x20is\x20the\x20canonical\x20address\
    \x20of\x20the\x20contract\x20to\x20query\n\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03)\x04\t\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03)\n\x11\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03)\x14\x15\n\x0c\n\x05\x04\0\x02\0\x08\x12\x03)\
    \x16^\n\x0f\n\x08\x04\0\x02\0\x08\xef\xfb\x03\x12\x03)\x17]\nb\n\x02\x04\
    \x01\x12\x04,\00\x01\x1aV\x20QueryContractInfoResponse\x20is\x20the\x20r\
    esponse\x20type\x20for\x20the\x20Query/ContractInfo\x20RPC\x20method\n\n\
    \n\n\x03\x04\x01\x01\x12\x03,\x08!\n?\n\x04\x04\x01\x02\0\x12\x03.\x04_\
    \x1a2\x20address\x20is\x20the\x20canonical\x20address\x20of\x20the\x20co\
    ntract\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03.\x04\t\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03.\n\x11\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03.\x14\
    \x15\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03.\x16^\n\x0f\n\x08\x04\x01\x02\
    \0\x08\xef\xfb\x03\x12\x03.\x17]\n\x0b\n\x04\x04\x01\x02\x01\x12\x03/\
    \x04W\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03/\x04\x10\n\x0c\n\x05\x04\
    \x01\x02\x01\x01\x12\x03/\x11\x1d\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\
    \x03/\x20!\n\x0c\n\x05\x04\x01\x02\x01\x08\x12\x03/\"V\n\x0f\n\x08\x04\
    \x01\x02\x01\x08\xea\xfb\x03\x12\x03/#;\n\x0f\n\x08\x04\x01\x02\x01\x08\
    \xed\xfb\x03\x12\x03/=U\n\n\n\x02\x04\x02\x12\x042\05\x01\n\n\n\x03\x04\
    \x02\x01\x12\x032\x08#\nH\n\x04\x04\x02\x02\0\x12\x034\x04_\x1a;\x20addr\
    ess\x20is\x20the\x20canonical\x20address\x20of\x20the\x20contract\x20to\
    \x20query\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x034\x04\t\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x034\n\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x034\x14\
    \x15\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x034\x16^\n\x0f\n\x08\x04\x02\x02\
    \0\x08\xef\xfb\x03\x12\x034\x17]\n\x84\x01\n\x02\x04\x03\x12\x04=\0?\x01\
    2x\nmessage\x20QueryContractHistoryResponse\x20{\nrepeated\x20ContractCo\
    deHistoryEntry\x20entries\x20=\x201\x20[(gogoproto.nullable)\x20=\x20fal\
    se];\n}\n\n\n\n\x03\x04\x03\x01\x12\x03=\x08#\n?\n\x04\x04\x03\x02\0\x12\
    \x03>\x04\x17\"2\x20grpc-gateway_out\x20does\x20not\x20support\x20Go\x20\
    style\x20CodID\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03>\x04\n\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x03>\x0b\x12\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03>\x15\x16\n_\n\x02\x04\x04\x12\x04B\0F\x01\x1aS\x20ContractInfoW\
    ithAddress\x20adds\x20the\x20address\x20(key)\x20to\x20the\x20ContractIn\
    fo\x20representation\n\n\n\n\x03\x04\x04\x01\x12\x03B\x08\x1f\n?\n\x04\
    \x04\x04\x02\0\x12\x03D\x04_\x1a2\x20address\x20is\x20the\x20canonical\
    \x20address\x20of\x20the\x20contract\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x03D\x04\t\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03D\n\x11\n\x0c\n\x05\x04\
    \x04\x02\0\x03\x12\x03D\x14\x15\n\x0c\n\x05\x04\x04\x02\0\x08\x12\x03D\
    \x16^\n\x0f\n\x08\x04\x04\x02\0\x08\xef\xfb\x03\x12\x03D\x17]\n\x0b\n\
    \x04\x04\x04\x02\x01\x12\x03E\x04W\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\
    \x03E\x04\x10\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03E\x11\x1d\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03E\x20!\n\x0c\n\x05\x04\x04\x02\x01\x08\
    \x12\x03E\"V\n\x0f\n\x08\x04\x04\x02\x01\x08\xea\xfb\x03\x12\x03E#;\n\
    \x0f\n\x08\x04\x04\x02\x01\x08\xed\xfb\x03\x12\x03E=U\n\n\n\x02\x04\x05\
    \x12\x04H\0J\x01\n\n\n\x03\x04\x05\x01\x12\x03H\x08$\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03I\x04W\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03I\x04\x0c\n\
    \x0c\n\x05\x04\x05\x02\0\x06\x12\x03I\r$\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03I%3\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03I67\n\x0c\n\x05\x04\x05\
    \x02\0\x08\x12\x03I8V\n\x0f\n\x08\x04\x05\x02\0\x08\xe9\xfb\x03\x12\x03I\
    9U\n\xa3\x04\n\x02\x04\x06\x12\x04a\0e\x012\x96\x04\nmessage\x20QueryAll\
    ContractStateRequest\x20{\n//\x20address\x20is\x20the\x20address\x20of\
    \x20the\x20contract\nbytes\x20address\x20=\x201\x20[(gogoproto.casttype)\
    \x20=\x20\"github.com/cosmos/cosmos-sdk/types.AccAddress\"];\n}\n\nmessa\
    ge\x20QueryAllContractStateResponse\x20{\nrepeated\x20Model\x20models\
    \x20=\x201\x20[(gogoproto.nullable)\x20=\x20false];\n}\n\nmessage\x20Que\
    ryRawContractStateRequest\x20{\n//\x20address\x20is\x20the\x20address\
    \x20of\x20the\x20contract\nbytes\x20address\x20=\x201\x20[(gogoproto.cas\
    ttype)\x20=\x20\"github.com/cosmos/cosmos-sdk/types.AccAddress\"];\nbyte\
    s\x20query_data\x20=\x202;\n}\n\nmessage\x20QueryRawContractStateRespons\
    e\x20{\nbytes\x20data\x20=\x201;\n}\n\n\n\n\x03\x04\x06\x01\x12\x03a\x08\
    &\n?\n\x04\x04\x06\x02\0\x12\x03c\x04_\x1a2\x20address\x20is\x20the\x20c\
    anonical\x20address\x20of\x20the\x20contract\n\n\x0c\n\x05\x04\x06\x02\0\
    \x05\x12\x03c\x04\t\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03c\n\x11\n\x0c\n\
    \x05\x04\x06\x02\0\x03\x12\x03c\x14\x15\n\x0c\n\x05\x04\x06\x02\0\x08\
    \x12\x03c\x16^\n\x0f\n\x08\x04\x06\x02\0\x08\xef\xfb\x03\x12\x03c\x17]\n\
    \x0b\n\x04\x04\x06\x02\x01\x12\x03d\x04\x19\n\x0c\n\x05\x04\x06\x02\x01\
    \x05\x12\x03d\x04\t\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03d\n\x14\n\x0c\
    \n\x05\x04\x06\x02\x01\x03\x12\x03d\x17\x18\n\n\n\x02\x04\x07\x12\x04g\0\
    i\x01\n\n\n\x03\x04\x07\x01\x12\x03g\x08*\n\x0b\n\x04\x04\x07\x02\0\x12\
    \x03h\x04\x15\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03h\x04\n\n\x0c\n\x05\
    \x04\x07\x02\0\x01\x12\x03h\x0b\x10\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03h\x13\x14\n\n\n\x02\x04\x08\x12\x04k\0n\x01\n\n\n\x03\x04\x08\x01\
    \x12\x03k\x08\x1f\n?\n\x04\x04\x08\x02\0\x12\x03m\x04_\x1a2\x20address\
    \x20is\x20the\x20canonical\x20address\x20of\x20the\x20contract\n\n\x0c\n\
    \x05\x04\x08\x02\0\x05\x12\x03m\x04\t\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03m\n\x11\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03m\x14\x15\n\x0c\n\x05\
    \x04\x08\x02\0\x08\x12\x03m\x16^\n\x0f\n\x08\x04\x08\x02\0\x08\xef\xfb\
    \x03\x12\x03m\x17]\n\n\n\x02\x04\t\x12\x04p\0s\x01\n\n\n\x03\x04\t\x01\
    \x12\x03p\x08\x20\n?\n\x04\x04\t\x02\0\x12\x03r\x04_\x1a2\x20address\x20\
    is\x20the\x20canonical\x20address\x20of\x20the\x20contract\n\n\x0c\n\x05\
    \x04\t\x02\0\x05\x12\x03r\x04\t\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03r\n\
    \x11\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03r\x14\x15\n\x0c\n\x05\x04\t\x02\
    \0\x08\x12\x03r\x16^\n\x0f\n\x08\x04\t\x02\0\x08\xef\xfb\x03\x12\x03r\
    \x17]\n\n\n\x02\x04\n\x12\x04u\0w\x01\n\n\n\x03\x04\n\x01\x12\x03u\x08'\
    \n\x0b\n\x04\x04\n\x02\0\x12\x03v\x04\x13\n\x0c\n\x05\x04\n\x02\0\x05\
    \x12\x03v\x04\t\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03v\n\x0e\n\x0c\n\x05\
    \x04\n\x02\0\x03\x12\x03v\x11\x12\n\n\n\x02\x04\x0b\x12\x04y\0{\x01\n\n\
    \n\x03\x04\x0b\x01\x12\x03y\x08\x18\n?\n\x04\x04\x0b\x02\0\x12\x03z\x04\
    \x17\"2\x20grpc-gateway_out\x20does\x20not\x20support\x20Go\x20style\x20\
    CodID\n\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03z\x04\n\n\x0c\n\x05\x04\x0b\
    \x02\0\x01\x12\x03z\x0b\x12\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03z\x15\
    \x16\n\x0b\n\x02\x04\x0c\x12\x05}\0\x83\x01\x01\n\n\n\x03\x04\x0c\x01\
    \x12\x03}\x08\x18\n$\n\x04\x04\x0c\x02\0\x12\x03~\x04W\"\x17\x20id\x20fo\
    r\x20legacy\x20support\n\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03~\x04\n\n\
    \x0c\n\x05\x04\x0c\x02\0\x01\x12\x03~\x0b\x12\n\x0c\n\x05\x04\x0c\x02\0\
    \x03\x12\x03~\x15\x16\n\x0c\n\x05\x04\x0c\x02\0\x08\x12\x03~\x17V\n\x0f\
    \n\x08\x04\x0c\x02\0\x08\xec\xfb\x03\x12\x03~\x189\n\x0f\n\x08\x04\x0c\
    \x02\0\x08\xed\xfb\x03\x12\x03~;U\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03\
    \x7f\x04_\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03\x7f\x04\t\n\x0c\n\x05\
    \x04\x0c\x02\x01\x01\x12\x03\x7f\n\x11\n\x0c\n\x05\x04\x0c\x02\x01\x03\
    \x12\x03\x7f\x14\x15\n\x0c\n\x05\x04\x0c\x02\x01\x08\x12\x03\x7f\x16^\n\
    \x0f\n\x08\x04\x0c\x02\x01\x08\xef\xfb\x03\x12\x03\x7f\x17]\n\x0c\n\x04\
    \x04\x0c\x02\x02\x12\x04\x80\x01\x04h\n\r\n\x05\x04\x0c\x02\x02\x05\x12\
    \x04\x80\x01\x04\t\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x80\x01\n\x13\n\
    \r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x80\x01\x16\x17\n\r\n\x05\x04\x0c\
    \x02\x02\x08\x12\x04\x80\x01\x18g\n\x10\n\x08\x04\x0c\x02\x02\x08\xef\
    \xfb\x03\x12\x04\x80\x01\x19f\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\x81\
    \x01\x04\x16\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\x81\x01\x04\n\n\r\n\
    \x05\x04\x0c\x02\x03\x01\x12\x04\x81\x01\x0b\x11\n\r\n\x05\x04\x0c\x02\
    \x03\x03\x12\x04\x81\x01\x14\x15\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\x82\
    \x01\x04\x17\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\x82\x01\x04\n\n\r\n\
    \x05\x04\x0c\x02\x04\x01\x12\x04\x82\x01\x0b\x12\n\r\n\x05\x04\x0c\x02\
    \x04\x03\x12\x04\x82\x01\x15\x16\n\x0c\n\x02\x04\r\x12\x06\x85\x01\0\x88\
    \x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x85\x01\x08\x19\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\x86\x01\x04X\n\r\n\x05\x04\r\x02\0\x06\x12\x04\x86\x01\
    \x04\x14\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x86\x01\x15\x1e\n\r\n\x05\x04\
    \r\x02\0\x03\x12\x04\x86\x01!\"\n\r\n\x05\x04\r\x02\0\x08\x12\x04\x86\
    \x01#W\n\x10\n\x08\x04\r\x02\0\x08\xea\xfb\x03\x12\x04\x86\x01$<\n\x10\n\
    \x08\x04\r\x02\0\x08\xed\xfb\x03\x12\x04\x86\x01>V\n\x0c\n\x04\x04\r\x02\
    \x01\x12\x04\x87\x01\x042\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x87\x01\
    \x04\t\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x87\x01\n\x0e\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\x87\x01\x11\x12\n\r\n\x05\x04\r\x02\x01\x08\x12\x04\
    \x87\x01\x131\n\x10\n\x08\x04\r\x02\x01\x08\xed\xfb\x03\x12\x04\x87\x01\
    \x140\n\x0c\n\x02\x04\x0e\x12\x06\x8a\x01\0\x8c\x01\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\x8a\x01\x08\x1a\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x8b\
    \x01\x04L\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x8b\x01\x04\x0c\n\r\n\x05\
    \x04\x0e\x02\0\x06\x12\x04\x8b\x01\r\x1d\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x8b\x01\x1e(\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x8b\x01+,\n\r\n\
    \x05\x04\x0e\x02\0\x08\x12\x04\x8b\x01-K\n\x10\n\x08\x04\x0e\x02\0\x08\
    \xe9\xfb\x03\x12\x04\x8b\x01.J\n\x0c\n\x02\x04\x0f\x12\x06\x8e\x01\0\x91\
    \x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x8e\x01\x08+\n@\n\x04\x04\x0f\
    \x02\0\x12\x04\x90\x01\x04_\x1a2\x20address\x20is\x20the\x20canonical\
    \x20address\x20of\x20the\x20contract\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\
    \x04\x90\x01\x04\t\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x90\x01\n\x11\n\r\
    \n\x05\x04\x0f\x02\0\x03\x12\x04\x90\x01\x14\x15\n\r\n\x05\x04\x0f\x02\0\
    \x08\x12\x04\x90\x01\x16^\n\x10\n\x08\x04\x0f\x02\0\x08\xef\xfb\x03\x12\
    \x04\x90\x01\x17]\n\x0c\n\x02\x04\x10\x12\x06\x93\x01\0\x96\x01\x01\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\x93\x01\x08\x20\n6\n\x04\x04\x10\x02\0\
    \x12\x04\x95\x01\x04b\x1a(\x20address\x20is\x20the\x20address\x20of\x20t\
    he\x20contract\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x95\x01\x04\t\n\r\n\
    \x05\x04\x10\x02\0\x01\x12\x04\x95\x01\n\r\n\r\n\x05\x04\x10\x02\0\x03\
    \x12\x04\x95\x01\x10\x11\n\r\n\x05\x04\x10\x02\0\x08\x12\x04\x95\x01\x12\
    a\n\x10\n\x08\x04\x10\x02\0\x08\xef\xfb\x03\x12\x04\x95\x01\x13`\n\x0c\n\
    \x02\x04\x11\x12\x06\x98\x01\0\x9a\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\x98\x01\x08!\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x99\x01\x04h\n\r\n\
    \x05\x04\x11\x02\0\x05\x12\x04\x99\x01\x04\t\n\r\n\x05\x04\x11\x02\0\x01\
    \x12\x04\x99\x01\n\x13\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x99\x01\x16\
    \x17\n\r\n\x05\x04\x11\x02\0\x08\x12\x04\x99\x01\x18g\n\x10\n\x08\x04\
    \x11\x02\0\x08\xef\xfb\x03\x12\x04\x99\x01\x19f\nP\n\x02\x04\x12\x12\x06\
    \x9d\x01\0\xa7\x01\x01\x1aB\x20DecryptedAnswer\x20is\x20a\x20struct\x20t\
    hat\x20represents\x20a\x20decrypted\x20tx-query\n\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\x9d\x01\x08\x17\n\x0b\n\x03\x04\x12\x07\x12\x04\x9e\x01\x04\
    %\n\x0e\n\x06\x04\x12\x07\x8d\xf4\x03\x12\x04\x9e\x01\x04%\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xa0\x01\x04\x14\n\r\n\x05\x04\x12\x02\0\x05\x12\
    \x04\xa0\x01\x04\n\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xa0\x01\x0b\x0f\n\
    \r\n\x05\x04\x12\x02\0\x03\x12\x04\xa0\x01\x12\x13\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xa1\x01\x04\x15\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xa1\x01\x04\n\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xa1\x01\x0b\x10\n\r\
    \n\x05\x04\x12\x02\x01\x03\x12\x04\xa1\x01\x13\x14\n\x0c\n\x04\x04\x12\
    \x02\x02\x12\x04\xa2\x01\x04\x1b\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\
    \xa2\x01\x04\n\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xa2\x01\x0b\x16\n\r\
    \n\x05\x04\x12\x02\x02\x03\x12\x04\xa2\x01\x19\x1a\n\x0c\n\x04\x04\x12\
    \x02\x03\x12\x04\xa3\x01\x04%\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xa3\
    \x01\x04\n\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xa3\x01\x0b\x20\n\r\n\
    \x05\x04\x12\x02\x03\x03\x12\x04\xa3\x01#$\n\x0c\n\x04\x04\x12\x02\x04\
    \x12\x04\xa4\x01\x04a\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xa4\x01\x04\
    \x0c\n\r\n\x05\x04\x12\x02\x04\x06\x12\x04\xa4\x01\r1\n\r\n\x05\x04\x12\
    \x02\x04\x01\x12\x04\xa4\x012=\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xa4\
    \x01@A\n\r\n\x05\x04\x12\x02\x04\x08\x12\x04\xa4\x01B`\n\x10\n\x08\x04\
    \x12\x02\x04\x08\xe9\xfb\x03\x12\x04\xa4\x01C_\n\x0c\n\x04\x04\x12\x02\
    \x05\x12\x04\xa5\x01\x04O\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xa5\x01\
    \x04\t\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\xa5\x01\n\x16\n\r\n\x05\x04\
    \x12\x02\x05\x03\x12\x04\xa5\x01\x19\x1a\n\r\n\x05\x04\x12\x02\x05\x08\
    \x12\x04\xa5\x01\x1bN\n\x10\n\x08\x04\x12\x02\x05\x08\xef\xfb\x03\x12\
    \x04\xa5\x01\x1cM\n\x0c\n\x04\x04\x12\x02\x06\x12\x04\xa6\x01\x04\x1f\n\
    \r\n\x05\x04\x12\x02\x06\x05\x12\x04\xa6\x01\x04\n\n\r\n\x05\x04\x12\x02\
    \x06\x01\x12\x04\xa6\x01\x0b\x1a\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\
    \xa6\x01\x1d\x1eb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::abci::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(19);
            messages.push(QueryContractInfoRequest::generated_message_descriptor_data());
            messages.push(QueryContractInfoResponse::generated_message_descriptor_data());
            messages.push(QueryContractHistoryRequest::generated_message_descriptor_data());
            messages.push(QueryContractsByCodeRequest::generated_message_descriptor_data());
            messages.push(ContractInfoWithAddress::generated_message_descriptor_data());
            messages.push(QueryContractsByCodeResponse::generated_message_descriptor_data());
            messages.push(QuerySmartContractStateRequest::generated_message_descriptor_data());
            messages.push(QueryContractAddressByLabelRequest::generated_message_descriptor_data());
            messages.push(QueryContractKeyRequest::generated_message_descriptor_data());
            messages.push(QueryContractHashRequest::generated_message_descriptor_data());
            messages.push(QuerySmartContractStateResponse::generated_message_descriptor_data());
            messages.push(QueryCodeRequest::generated_message_descriptor_data());
            messages.push(CodeInfoResponse::generated_message_descriptor_data());
            messages.push(QueryCodeResponse::generated_message_descriptor_data());
            messages.push(QueryCodesResponse::generated_message_descriptor_data());
            messages.push(QueryContractAddressByLabelResponse::generated_message_descriptor_data());
            messages.push(QueryContractKeyResponse::generated_message_descriptor_data());
            messages.push(QueryContractHashResponse::generated_message_descriptor_data());
            messages.push(DecryptedAnswer::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
