// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos/distribution/v1beta1/distribution.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  Params defines the set of params for the distribution module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.Params)
pub struct Params {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.Params.community_tax)
    pub community_tax: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.Params.base_proposer_reward)
    pub base_proposer_reward: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.Params.bonus_proposer_reward)
    pub bonus_proposer_reward: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.Params.withdraw_addr_enabled)
    pub withdraw_addr_enabled: bool,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.Params.secret_foundation_tax)
    pub secret_foundation_tax: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.Params.secret_foundation_address)
    pub secret_foundation_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.Params.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Params {
    fn default() -> &'a Params {
        <Params as ::protobuf::Message>::default_instance()
    }
}

impl Params {
    pub fn new() -> Params {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "community_tax",
            |m: &Params| { &m.community_tax },
            |m: &mut Params| { &mut m.community_tax },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base_proposer_reward",
            |m: &Params| { &m.base_proposer_reward },
            |m: &mut Params| { &mut m.base_proposer_reward },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bonus_proposer_reward",
            |m: &Params| { &m.bonus_proposer_reward },
            |m: &mut Params| { &mut m.bonus_proposer_reward },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdraw_addr_enabled",
            |m: &Params| { &m.withdraw_addr_enabled },
            |m: &mut Params| { &mut m.withdraw_addr_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "secret_foundation_tax",
            |m: &Params| { &m.secret_foundation_tax },
            |m: &mut Params| { &mut m.secret_foundation_tax },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "secret_foundation_address",
            |m: &Params| { &m.secret_foundation_address },
            |m: &mut Params| { &mut m.secret_foundation_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Params>(
            "Params",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Params {
    const NAME: &'static str = "Params";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.community_tax = is.read_string()?;
                },
                18 => {
                    self.base_proposer_reward = is.read_string()?;
                },
                26 => {
                    self.bonus_proposer_reward = is.read_string()?;
                },
                32 => {
                    self.withdraw_addr_enabled = is.read_bool()?;
                },
                42 => {
                    self.secret_foundation_tax = is.read_string()?;
                },
                50 => {
                    self.secret_foundation_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.community_tax.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.community_tax);
        }
        if !self.base_proposer_reward.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.base_proposer_reward);
        }
        if !self.bonus_proposer_reward.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bonus_proposer_reward);
        }
        if self.withdraw_addr_enabled != false {
            my_size += 1 + 1;
        }
        if !self.secret_foundation_tax.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.secret_foundation_tax);
        }
        if !self.secret_foundation_address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.secret_foundation_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.community_tax.is_empty() {
            os.write_string(1, &self.community_tax)?;
        }
        if !self.base_proposer_reward.is_empty() {
            os.write_string(2, &self.base_proposer_reward)?;
        }
        if !self.bonus_proposer_reward.is_empty() {
            os.write_string(3, &self.bonus_proposer_reward)?;
        }
        if self.withdraw_addr_enabled != false {
            os.write_bool(4, self.withdraw_addr_enabled)?;
        }
        if !self.secret_foundation_tax.is_empty() {
            os.write_string(5, &self.secret_foundation_tax)?;
        }
        if !self.secret_foundation_address.is_empty() {
            os.write_string(6, &self.secret_foundation_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Params {
        Params::new()
    }

    fn clear(&mut self) {
        self.community_tax.clear();
        self.base_proposer_reward.clear();
        self.bonus_proposer_reward.clear();
        self.withdraw_addr_enabled = false;
        self.secret_foundation_tax.clear();
        self.secret_foundation_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Params {
        static instance: Params = Params {
            community_tax: ::std::string::String::new(),
            base_proposer_reward: ::std::string::String::new(),
            bonus_proposer_reward: ::std::string::String::new(),
            withdraw_addr_enabled: false,
            secret_foundation_tax: ::std::string::String::new(),
            secret_foundation_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Params {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Params").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Params {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.ValidatorHistoricalRewards)
pub struct ValidatorHistoricalRewards {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.cumulative_reward_ratio)
    pub cumulative_reward_ratio: ::std::vec::Vec<super::coin::DecCoin>,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.reference_count)
    pub reference_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorHistoricalRewards {
    fn default() -> &'a ValidatorHistoricalRewards {
        <ValidatorHistoricalRewards as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorHistoricalRewards {
    pub fn new() -> ValidatorHistoricalRewards {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cumulative_reward_ratio",
            |m: &ValidatorHistoricalRewards| { &m.cumulative_reward_ratio },
            |m: &mut ValidatorHistoricalRewards| { &mut m.cumulative_reward_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reference_count",
            |m: &ValidatorHistoricalRewards| { &m.reference_count },
            |m: &mut ValidatorHistoricalRewards| { &mut m.reference_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorHistoricalRewards>(
            "ValidatorHistoricalRewards",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorHistoricalRewards {
    const NAME: &'static str = "ValidatorHistoricalRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cumulative_reward_ratio.push(is.read_message()?);
                },
                16 => {
                    self.reference_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cumulative_reward_ratio {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.reference_count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.reference_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cumulative_reward_ratio {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.reference_count != 0 {
            os.write_uint32(2, self.reference_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorHistoricalRewards {
        ValidatorHistoricalRewards::new()
    }

    fn clear(&mut self) {
        self.cumulative_reward_ratio.clear();
        self.reference_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorHistoricalRewards {
        static instance: ValidatorHistoricalRewards = ValidatorHistoricalRewards {
            cumulative_reward_ratio: ::std::vec::Vec::new(),
            reference_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorHistoricalRewards {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorHistoricalRewards").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorHistoricalRewards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorHistoricalRewards {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValidatorCurrentRewards represents current rewards and current
///  period for a validator kept as a running counter and incremented
///  each block as long as the validator's tokens remain constant.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.ValidatorCurrentRewards)
pub struct ValidatorCurrentRewards {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorCurrentRewards.rewards)
    pub rewards: ::std::vec::Vec<super::coin::DecCoin>,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorCurrentRewards.period)
    pub period: u64,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.ValidatorCurrentRewards.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorCurrentRewards {
    fn default() -> &'a ValidatorCurrentRewards {
        <ValidatorCurrentRewards as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorCurrentRewards {
    pub fn new() -> ValidatorCurrentRewards {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rewards",
            |m: &ValidatorCurrentRewards| { &m.rewards },
            |m: &mut ValidatorCurrentRewards| { &mut m.rewards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "period",
            |m: &ValidatorCurrentRewards| { &m.period },
            |m: &mut ValidatorCurrentRewards| { &mut m.period },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorCurrentRewards>(
            "ValidatorCurrentRewards",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorCurrentRewards {
    const NAME: &'static str = "ValidatorCurrentRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rewards.push(is.read_message()?);
                },
                16 => {
                    self.period = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.period != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.period);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rewards {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.period != 0 {
            os.write_uint64(2, self.period)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorCurrentRewards {
        ValidatorCurrentRewards::new()
    }

    fn clear(&mut self) {
        self.rewards.clear();
        self.period = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorCurrentRewards {
        static instance: ValidatorCurrentRewards = ValidatorCurrentRewards {
            rewards: ::std::vec::Vec::new(),
            period: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorCurrentRewards {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorCurrentRewards").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorCurrentRewards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorCurrentRewards {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValidatorAccumulatedCommission represents accumulated commission
///  for a validator kept as a running counter, can be withdrawn at any time.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission)
pub struct ValidatorAccumulatedCommission {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission.commission)
    pub commission: ::std::vec::Vec<super::coin::DecCoin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorAccumulatedCommission {
    fn default() -> &'a ValidatorAccumulatedCommission {
        <ValidatorAccumulatedCommission as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorAccumulatedCommission {
    pub fn new() -> ValidatorAccumulatedCommission {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "commission",
            |m: &ValidatorAccumulatedCommission| { &m.commission },
            |m: &mut ValidatorAccumulatedCommission| { &mut m.commission },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorAccumulatedCommission>(
            "ValidatorAccumulatedCommission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorAccumulatedCommission {
    const NAME: &'static str = "ValidatorAccumulatedCommission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commission.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.commission {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.commission {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorAccumulatedCommission {
        ValidatorAccumulatedCommission::new()
    }

    fn clear(&mut self) {
        self.commission.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorAccumulatedCommission {
        static instance: ValidatorAccumulatedCommission = ValidatorAccumulatedCommission {
            commission: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorAccumulatedCommission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorAccumulatedCommission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorAccumulatedCommission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorAccumulatedCommission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
///  for a validator inexpensive to track, allows simple sanity checks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.ValidatorOutstandingRewards)
pub struct ValidatorOutstandingRewards {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorOutstandingRewards.rewards)
    pub rewards: ::std::vec::Vec<super::coin::DecCoin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.ValidatorOutstandingRewards.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorOutstandingRewards {
    fn default() -> &'a ValidatorOutstandingRewards {
        <ValidatorOutstandingRewards as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorOutstandingRewards {
    pub fn new() -> ValidatorOutstandingRewards {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rewards",
            |m: &ValidatorOutstandingRewards| { &m.rewards },
            |m: &mut ValidatorOutstandingRewards| { &mut m.rewards },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorOutstandingRewards>(
            "ValidatorOutstandingRewards",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorOutstandingRewards {
    const NAME: &'static str = "ValidatorOutstandingRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rewards.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rewards {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorOutstandingRewards {
        ValidatorOutstandingRewards::new()
    }

    fn clear(&mut self) {
        self.rewards.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorOutstandingRewards {
        static instance: ValidatorOutstandingRewards = ValidatorOutstandingRewards {
            rewards: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorOutstandingRewards {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorOutstandingRewards").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorOutstandingRewards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorOutstandingRewards {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValidatorSlashEvent represents a validator slash event.
///  Height is implicit within the store key.
///  This is needed to calculate appropriate amount of staking tokens
///  for delegations which are withdrawn after a slash has occurred.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.ValidatorSlashEvent)
pub struct ValidatorSlashEvent {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorSlashEvent.validator_period)
    pub validator_period: u64,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorSlashEvent.fraction)
    pub fraction: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.ValidatorSlashEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorSlashEvent {
    fn default() -> &'a ValidatorSlashEvent {
        <ValidatorSlashEvent as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorSlashEvent {
    pub fn new() -> ValidatorSlashEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_period",
            |m: &ValidatorSlashEvent| { &m.validator_period },
            |m: &mut ValidatorSlashEvent| { &mut m.validator_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fraction",
            |m: &ValidatorSlashEvent| { &m.fraction },
            |m: &mut ValidatorSlashEvent| { &mut m.fraction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorSlashEvent>(
            "ValidatorSlashEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorSlashEvent {
    const NAME: &'static str = "ValidatorSlashEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.validator_period = is.read_uint64()?;
                },
                18 => {
                    self.fraction = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.validator_period != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.validator_period);
        }
        if !self.fraction.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.fraction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.validator_period != 0 {
            os.write_uint64(1, self.validator_period)?;
        }
        if !self.fraction.is_empty() {
            os.write_string(2, &self.fraction)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorSlashEvent {
        ValidatorSlashEvent::new()
    }

    fn clear(&mut self) {
        self.validator_period = 0;
        self.fraction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorSlashEvent {
        static instance: ValidatorSlashEvent = ValidatorSlashEvent {
            validator_period: 0,
            fraction: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorSlashEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorSlashEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorSlashEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorSlashEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValidatorSlashEvents is a collection of ValidatorSlashEvent messages.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.ValidatorSlashEvents)
pub struct ValidatorSlashEvents {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.ValidatorSlashEvents.validator_slash_events)
    pub validator_slash_events: ::std::vec::Vec<ValidatorSlashEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.ValidatorSlashEvents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorSlashEvents {
    fn default() -> &'a ValidatorSlashEvents {
        <ValidatorSlashEvents as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorSlashEvents {
    pub fn new() -> ValidatorSlashEvents {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validator_slash_events",
            |m: &ValidatorSlashEvents| { &m.validator_slash_events },
            |m: &mut ValidatorSlashEvents| { &mut m.validator_slash_events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorSlashEvents>(
            "ValidatorSlashEvents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorSlashEvents {
    const NAME: &'static str = "ValidatorSlashEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validator_slash_events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.validator_slash_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.validator_slash_events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorSlashEvents {
        ValidatorSlashEvents::new()
    }

    fn clear(&mut self) {
        self.validator_slash_events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorSlashEvents {
        static instance: ValidatorSlashEvents = ValidatorSlashEvents {
            validator_slash_events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorSlashEvents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorSlashEvents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorSlashEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorSlashEvents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  FeePool is the global fee pool for distribution.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.FeePool)
pub struct FeePool {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.FeePool.community_pool)
    pub community_pool: ::std::vec::Vec<super::coin::DecCoin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.FeePool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeePool {
    fn default() -> &'a FeePool {
        <FeePool as ::protobuf::Message>::default_instance()
    }
}

impl FeePool {
    pub fn new() -> FeePool {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "community_pool",
            |m: &FeePool| { &m.community_pool },
            |m: &mut FeePool| { &mut m.community_pool },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeePool>(
            "FeePool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeePool {
    const NAME: &'static str = "FeePool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.community_pool.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.community_pool {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.community_pool {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeePool {
        FeePool::new()
    }

    fn clear(&mut self) {
        self.community_pool.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeePool {
        static instance: FeePool = FeePool {
            community_pool: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeePool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeePool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeePool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeePool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CommunityPoolSpendProposal details a proposal for use of community funds,
///  together with how many coins are proposed to be spent, and to which
///  recipient account.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.CommunityPoolSpendProposal)
pub struct CommunityPoolSpendProposal {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.recipient)
    pub recipient: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.amount)
    pub amount: ::std::vec::Vec<super::coin::Coin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommunityPoolSpendProposal {
    fn default() -> &'a CommunityPoolSpendProposal {
        <CommunityPoolSpendProposal as ::protobuf::Message>::default_instance()
    }
}

impl CommunityPoolSpendProposal {
    pub fn new() -> CommunityPoolSpendProposal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &CommunityPoolSpendProposal| { &m.title },
            |m: &mut CommunityPoolSpendProposal| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &CommunityPoolSpendProposal| { &m.description },
            |m: &mut CommunityPoolSpendProposal| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recipient",
            |m: &CommunityPoolSpendProposal| { &m.recipient },
            |m: &mut CommunityPoolSpendProposal| { &mut m.recipient },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "amount",
            |m: &CommunityPoolSpendProposal| { &m.amount },
            |m: &mut CommunityPoolSpendProposal| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommunityPoolSpendProposal>(
            "CommunityPoolSpendProposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommunityPoolSpendProposal {
    const NAME: &'static str = "CommunityPoolSpendProposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    self.recipient = is.read_string()?;
                },
                34 => {
                    self.amount.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.recipient);
        }
        for value in &self.amount {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.recipient.is_empty() {
            os.write_string(3, &self.recipient)?;
        }
        for v in &self.amount {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommunityPoolSpendProposal {
        CommunityPoolSpendProposal::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.recipient.clear();
        self.amount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommunityPoolSpendProposal {
        static instance: CommunityPoolSpendProposal = CommunityPoolSpendProposal {
            title: ::std::string::String::new(),
            description: ::std::string::String::new(),
            recipient: ::std::string::String::new(),
            amount: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommunityPoolSpendProposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommunityPoolSpendProposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommunityPoolSpendProposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunityPoolSpendProposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DelegatorStartingInfo represents the starting info for a delegator reward
///  period. It tracks the previous validator period, the delegation's amount of
///  staking token, and the creation height (to check later on if any slashes have
///  occurred). NOTE: Even though validators are slashed to whole staking tokens,
///  the delegators within the validator may be left with less than a full token,
///  thus sdk.Dec is used.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.DelegatorStartingInfo)
pub struct DelegatorStartingInfo {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.DelegatorStartingInfo.previous_period)
    pub previous_period: u64,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.DelegatorStartingInfo.stake)
    pub stake: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.DelegatorStartingInfo.height)
    pub height: u64,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.DelegatorStartingInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DelegatorStartingInfo {
    fn default() -> &'a DelegatorStartingInfo {
        <DelegatorStartingInfo as ::protobuf::Message>::default_instance()
    }
}

impl DelegatorStartingInfo {
    pub fn new() -> DelegatorStartingInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "previous_period",
            |m: &DelegatorStartingInfo| { &m.previous_period },
            |m: &mut DelegatorStartingInfo| { &mut m.previous_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stake",
            |m: &DelegatorStartingInfo| { &m.stake },
            |m: &mut DelegatorStartingInfo| { &mut m.stake },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &DelegatorStartingInfo| { &m.height },
            |m: &mut DelegatorStartingInfo| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelegatorStartingInfo>(
            "DelegatorStartingInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DelegatorStartingInfo {
    const NAME: &'static str = "DelegatorStartingInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.previous_period = is.read_uint64()?;
                },
                18 => {
                    self.stake = is.read_string()?;
                },
                24 => {
                    self.height = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.previous_period != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.previous_period);
        }
        if !self.stake.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.stake);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.previous_period != 0 {
            os.write_uint64(1, self.previous_period)?;
        }
        if !self.stake.is_empty() {
            os.write_string(2, &self.stake)?;
        }
        if self.height != 0 {
            os.write_uint64(3, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DelegatorStartingInfo {
        DelegatorStartingInfo::new()
    }

    fn clear(&mut self) {
        self.previous_period = 0;
        self.stake.clear();
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DelegatorStartingInfo {
        static instance: DelegatorStartingInfo = DelegatorStartingInfo {
            previous_period: 0,
            stake: ::std::string::String::new(),
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DelegatorStartingInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DelegatorStartingInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DelegatorStartingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatorStartingInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DelegationDelegatorReward represents the properties
///  of a delegator's delegation reward.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.DelegationDelegatorReward)
pub struct DelegationDelegatorReward {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.DelegationDelegatorReward.validator_address)
    pub validator_address: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.DelegationDelegatorReward.reward)
    pub reward: ::std::vec::Vec<super::coin::DecCoin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.DelegationDelegatorReward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DelegationDelegatorReward {
    fn default() -> &'a DelegationDelegatorReward {
        <DelegationDelegatorReward as ::protobuf::Message>::default_instance()
    }
}

impl DelegationDelegatorReward {
    pub fn new() -> DelegationDelegatorReward {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &DelegationDelegatorReward| { &m.validator_address },
            |m: &mut DelegationDelegatorReward| { &mut m.validator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reward",
            |m: &DelegationDelegatorReward| { &m.reward },
            |m: &mut DelegationDelegatorReward| { &mut m.reward },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelegationDelegatorReward>(
            "DelegationDelegatorReward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DelegationDelegatorReward {
    const NAME: &'static str = "DelegationDelegatorReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validator_address = is.read_string()?;
                },
                18 => {
                    self.reward.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_address);
        }
        for value in &self.reward {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.validator_address.is_empty() {
            os.write_string(1, &self.validator_address)?;
        }
        for v in &self.reward {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DelegationDelegatorReward {
        DelegationDelegatorReward::new()
    }

    fn clear(&mut self) {
        self.validator_address.clear();
        self.reward.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DelegationDelegatorReward {
        static instance: DelegationDelegatorReward = DelegationDelegatorReward {
            validator_address: ::std::string::String::new(),
            reward: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DelegationDelegatorReward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DelegationDelegatorReward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DelegationDelegatorReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegationDelegatorReward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CommunityPoolSpendProposalWithDeposit defines a CommunityPoolSpendProposal
///  with a deposit
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit)
pub struct CommunityPoolSpendProposalWithDeposit {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.recipient)
    pub recipient: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.amount)
    pub amount: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.deposit)
    pub deposit: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommunityPoolSpendProposalWithDeposit {
    fn default() -> &'a CommunityPoolSpendProposalWithDeposit {
        <CommunityPoolSpendProposalWithDeposit as ::protobuf::Message>::default_instance()
    }
}

impl CommunityPoolSpendProposalWithDeposit {
    pub fn new() -> CommunityPoolSpendProposalWithDeposit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &CommunityPoolSpendProposalWithDeposit| { &m.title },
            |m: &mut CommunityPoolSpendProposalWithDeposit| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &CommunityPoolSpendProposalWithDeposit| { &m.description },
            |m: &mut CommunityPoolSpendProposalWithDeposit| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recipient",
            |m: &CommunityPoolSpendProposalWithDeposit| { &m.recipient },
            |m: &mut CommunityPoolSpendProposalWithDeposit| { &mut m.recipient },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &CommunityPoolSpendProposalWithDeposit| { &m.amount },
            |m: &mut CommunityPoolSpendProposalWithDeposit| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deposit",
            |m: &CommunityPoolSpendProposalWithDeposit| { &m.deposit },
            |m: &mut CommunityPoolSpendProposalWithDeposit| { &mut m.deposit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommunityPoolSpendProposalWithDeposit>(
            "CommunityPoolSpendProposalWithDeposit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommunityPoolSpendProposalWithDeposit {
    const NAME: &'static str = "CommunityPoolSpendProposalWithDeposit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    self.recipient = is.read_string()?;
                },
                34 => {
                    self.amount = is.read_string()?;
                },
                42 => {
                    self.deposit = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.recipient);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.amount);
        }
        if !self.deposit.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.deposit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.recipient.is_empty() {
            os.write_string(3, &self.recipient)?;
        }
        if !self.amount.is_empty() {
            os.write_string(4, &self.amount)?;
        }
        if !self.deposit.is_empty() {
            os.write_string(5, &self.deposit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommunityPoolSpendProposalWithDeposit {
        CommunityPoolSpendProposalWithDeposit::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.recipient.clear();
        self.amount.clear();
        self.deposit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommunityPoolSpendProposalWithDeposit {
        static instance: CommunityPoolSpendProposalWithDeposit = CommunityPoolSpendProposalWithDeposit {
            title: ::std::string::String::new(),
            description: ::std::string::String::new(),
            recipient: ::std::string::String::new(),
            amount: ::std::string::String::new(),
            deposit: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommunityPoolSpendProposalWithDeposit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommunityPoolSpendProposalWithDeposit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommunityPoolSpendProposalWithDeposit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunityPoolSpendProposalWithDeposit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n.cosmos/distribution/v1beta1/distribution.proto\x12\x1bcosmos.distribu\
    tion.v1beta1\x1a\x14gogoproto/gogo.proto\x1a\x1ecosmos/base/v1beta1/coin\
    .proto\"\xbe\x05\n\x06Params\x12k\n\rcommunity_tax\x18\x01\x20\x01(\tR\
    \x0ccommunityTaxBF\xf2\xde\x1f\x14yaml:\"community_tax\"\xda\xde\x1f&git\
    hub.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\x12\x7f\n\x14base_prop\
    oser_reward\x18\x02\x20\x01(\tR\x12baseProposerRewardBM\xf2\xde\x1f\x1by\
    aml:\"base_proposer_reward\"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/ty\
    pes.Dec\xc8\xde\x1f\0\x12\x82\x01\n\x15bonus_proposer_reward\x18\x03\x20\
    \x01(\tR\x13bonusProposerRewardBN\xf2\xde\x1f\x1cyaml:\"bonus_proposer_r\
    eward\"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\
    \x12T\n\x15withdraw_addr_enabled\x18\x04\x20\x01(\x08R\x13withdrawAddrEn\
    abledB\x20\xf2\xde\x1f\x1cyaml:\"withdraw_addr_enabled\"\x12\x82\x01\n\
    \x15secret_foundation_tax\x18\x05\x20\x01(\tR\x13secretFoundationTaxBN\
    \xf2\xde\x1f\x1cyaml:\"secret_foundation_tax\"\xda\xde\x1f&github.com/co\
    smos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\x12`\n\x19secret_foundation_addr\
    ess\x18\x06\x20\x01(\tR\x17secretFoundationAddressB$\xf2\xde\x1f\x20yaml\
    :\"secret_foundation_address\":\x04\x98\xa0\x1f\0\"\x8f\x02\n\x1aValidat\
    orHistoricalRewards\x12\xab\x01\n\x17cumulative_reward_ratio\x18\x01\x20\
    \x03(\x0b2\x1c.cosmos.base.v1beta1.DecCoinR\x15cumulativeRewardRatioBU\
    \xf2\xde\x1f\x1eyaml:\"cumulative_reward_ratio\"\xaa\xdf\x1f+github.com/\
    cosmos/cosmos-sdk/types.DecCoins\xc8\xde\x1f\0\x12C\n\x0freference_count\
    \x18\x02\x20\x01(\rR\x0ereferenceCountB\x1a\xf2\xde\x1f\x16yaml:\"refere\
    nce_count\"\"\x9e\x01\n\x17ValidatorCurrentRewards\x12k\n\x07rewards\x18\
    \x01\x20\x03(\x0b2\x1c.cosmos.base.v1beta1.DecCoinR\x07rewardsB3\xaa\xdf\
    \x1f+github.com/cosmos/cosmos-sdk/types.DecCoins\xc8\xde\x1f\0\x12\x16\n\
    \x06period\x18\x02\x20\x01(\x04R\x06period\"\x93\x01\n\x1eValidatorAccum\
    ulatedCommission\x12q\n\ncommission\x18\x01\x20\x03(\x0b2\x1c.cosmos.bas\
    e.v1beta1.DecCoinR\ncommissionB3\xaa\xdf\x1f+github.com/cosmos/cosmos-sd\
    k/types.DecCoins\xc8\xde\x1f\0\"\x9c\x01\n\x1bValidatorOutstandingReward\
    s\x12}\n\x07rewards\x18\x01\x20\x03(\x0b2\x1c.cosmos.base.v1beta1.DecCoi\
    nR\x07rewardsBE\xf2\xde\x1f\x0eyaml:\"rewards\"\xaa\xdf\x1f+github.com/c\
    osmos/cosmos-sdk/types.DecCoins\xc8\xde\x1f\0\"\xa9\x01\n\x13ValidatorSl\
    ashEvent\x12F\n\x10validator_period\x18\x01\x20\x01(\x04R\x0fvalidatorPe\
    riodB\x1b\xf2\xde\x1f\x17yaml:\"validator_period\"\x12J\n\x08fraction\
    \x18\x02\x20\x01(\tR\x08fractionB.\xda\xde\x1f&github.com/cosmos/cosmos-\
    sdk/types.Dec\xc8\xde\x1f\0\"\xac\x01\n\x14ValidatorSlashEvents\x12\x8d\
    \x01\n\x16validator_slash_events\x18\x01\x20\x03(\x0b20.cosmos.distribut\
    ion.v1beta1.ValidatorSlashEventR\x14validatorSlashEventsB%\xf2\xde\x1f\
    \x1dyaml:\"validator_slash_events\"\xc8\xde\x1f\0:\x04\x98\xa0\x1f\0\"\
    \x9d\x01\n\x07FeePool\x12\x91\x01\n\x0ecommunity_pool\x18\x01\x20\x03(\
    \x0b2\x1c.cosmos.base.v1beta1.DecCoinR\rcommunityPoolBL\xaa\xdf\x1f+gith\
    ub.com/cosmos/cosmos-sdk/types.DecCoins\xc8\xde\x1f\0\xf2\xde\x1f\x15yam\
    l:\"community_pool\"\"\xe5\x01\n\x1aCommunityPoolSpendProposal\x12\x14\n\
    \x05title\x18\x01\x20\x01(\tR\x05title\x12\x20\n\x0bdescription\x18\x02\
    \x20\x01(\tR\x0bdescription\x12\x1c\n\trecipient\x18\x03\x20\x01(\tR\tre\
    cipient\x12c\n\x06amount\x18\x04\x20\x03(\x0b2\x19.cosmos.base.v1beta1.C\
    oinR\x06amountB0\xaa\xdf\x1f(github.com/cosmos/cosmos-sdk/types.Coins\
    \xc8\xde\x1f\0:\x0c\x88\xa0\x1f\0\xe8\xa0\x1f\0\x98\xa0\x1f\0\"\xf9\x01\
    \n\x15DelegatorStartingInfo\x12C\n\x0fprevious_period\x18\x01\x20\x01(\
    \x04R\x0epreviousPeriodB\x1a\xf2\xde\x1f\x16yaml:\"previous_period\"\x12\
    T\n\x05stake\x18\x02\x20\x01(\tR\x05stakeB>\xf2\xde\x1f\x0cyaml:\"stake\
    \"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\x12E\
    \n\x06height\x18\x03\x20\x01(\x04R\x06heightB-\xf2\xde\x1f\x16yaml:\"cre\
    ation_height\"\xea\xde\x1f\x0fcreation_height\"\xdb\x01\n\x19DelegationD\
    elegatorReward\x12I\n\x11validator_address\x18\x01\x20\x01(\tR\x10valida\
    torAddressB\x1c\xf2\xde\x1f\x18yaml:\"validator_address\"\x12i\n\x06rewa\
    rd\x18\x02\x20\x03(\x0b2\x1c.cosmos.base.v1beta1.DecCoinR\x06rewardB3\
    \xaa\xdf\x1f+github.com/cosmos/cosmos-sdk/types.DecCoins\xc8\xde\x1f\0:\
    \x08\x88\xa0\x1f\0\x98\xa0\x1f\x01\"\xa0\x02\n%CommunityPoolSpendProposa\
    lWithDeposit\x12&\n\x05title\x18\x01\x20\x01(\tR\x05titleB\x10\xf2\xde\
    \x1f\x0cyaml:\"title\"\x128\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdesc\
    riptionB\x16\xf2\xde\x1f\x12yaml:\"description\"\x122\n\trecipient\x18\
    \x03\x20\x01(\tR\trecipientB\x14\xf2\xde\x1f\x10yaml:\"recipient\"\x12)\
    \n\x06amount\x18\x04\x20\x01(\tR\x06amountB\x11\xf2\xde\x1f\ryaml:\"amou\
    nt\"\x12,\n\x07deposit\x18\x05\x20\x01(\tR\x07depositB\x12\xf2\xde\x1f\
    \x0eyaml:\"deposit\":\x08\x88\xa0\x1f\0\x98\xa0\x1f\x01B7Z1github.com/co\
    smos/cosmos-sdk/x/distribution/types\xa8\xe2\x1e\x01J\x86/\n\x07\x12\x05\
    \0\0\xa4\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\
    \x01\0$\n\x08\n\x01\x08\x12\x03\x03\0S\n\t\n\x02\x08\x0b\x12\x03\x03\0S\
    \n\x08\n\x01\x08\x12\x03\x04\0$\n\x0b\n\x04\x08\xa5\xec\x03\x12\x03\x04\
    \0$\n\t\n\x02\x03\0\x12\x03\x06\0\x1e\n\t\n\x02\x03\x01\x12\x03\x07\0(\n\
    K\n\x02\x04\0\x12\x04\n\0$\x01\x1a?\x20Params\x20defines\x20the\x20set\
    \x20of\x20params\x20for\x20the\x20distribution\x20module.\n\n\n\n\x03\
    \x04\0\x01\x12\x03\n\x08\x0e\n\n\n\x03\x04\0\x07\x12\x03\x0b\x02.\n\r\n\
    \x06\x04\0\x07\x83\xf4\x03\x12\x03\x0b\x02.\n\x0c\n\x04\x04\0\x02\0\x12\
    \x04\x0c\x02\x10\x04\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0c\x02\x08\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0c\t\x16\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x0c()\n\r\n\x05\x04\0\x02\0\x08\x12\x04\x0c*\x10\x03\n\x0f\n\
    \x08\x04\0\x02\0\x08\xee\xfb\x03\x12\x03\r\x045\n\x0f\n\x08\x04\0\x02\0\
    \x08\xeb\xfb\x03\x12\x03\x0e\x04E\n\x0f\n\x08\x04\0\x02\0\x08\xe9\xfb\
    \x03\x12\x03\x0f\x04\"\n\x0c\n\x04\x04\0\x02\x01\x12\x04\x11\x02\x15\x04\
    \n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x11\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x11\t\x1d\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x11\x20\
    !\n\r\n\x05\x04\0\x02\x01\x08\x12\x04\x11\"\x15\x03\n\x0f\n\x08\x04\0\
    \x02\x01\x08\xee\xfb\x03\x12\x03\x12\x04<\n\x0f\n\x08\x04\0\x02\x01\x08\
    \xeb\xfb\x03\x12\x03\x13\x04E\n\x0f\n\x08\x04\0\x02\x01\x08\xe9\xfb\x03\
    \x12\x03\x14\x04\"\n\x0c\n\x04\x04\0\x02\x02\x12\x04\x16\x02\x1a\x04\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03\x16\t\x1e\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x16!\"\
    \n\r\n\x05\x04\0\x02\x02\x08\x12\x04\x16#\x1a\x03\n\x0f\n\x08\x04\0\x02\
    \x02\x08\xee\xfb\x03\x12\x03\x17\x04=\n\x0f\n\x08\x04\0\x02\x02\x08\xeb\
    \xfb\x03\x12\x03\x18\x04E\n\x0f\n\x08\x04\0\x02\x02\x08\xe9\xfb\x03\x12\
    \x03\x19\x04\"\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x1b\x02[\n\x0c\n\x05\
    \x04\0\x02\x03\x05\x12\x03\x1b\x02\x06\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03\x1b\x07\x1c\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x1b\x1f\x20\n\x0c\
    \n\x05\x04\0\x02\x03\x08\x12\x03\x1b!Z\n\x0f\n\x08\x04\0\x02\x03\x08\xee\
    \xfb\x03\x12\x03\x1b\"Y\n\x0c\n\x04\x04\0\x02\x04\x12\x04\x1c\x02\x20\
    \x04\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x1c\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x04\x01\x12\x03\x1c\t\x1e\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x1c\
    !\"\n\r\n\x05\x04\0\x02\x04\x08\x12\x04\x1c#\x20\x03\n\x0f\n\x08\x04\0\
    \x02\x04\x08\xee\xfb\x03\x12\x03\x1d\x04=\n\x0f\n\x08\x04\0\x02\x04\x08\
    \xeb\xfb\x03\x12\x03\x1e\x04E\n\x0f\n\x08\x04\0\x02\x04\x08\xe9\xfb\x03\
    \x12\x03\x1f\x04\"\n\x0c\n\x04\x04\0\x02\x05\x12\x04!\x02#\x04\n\x0c\n\
    \x05\x04\0\x02\x05\x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\0\x02\x05\x01\
    \x12\x03!\t\"\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03!%&\n\r\n\x05\x04\0\
    \x02\x05\x08\x12\x04!'#\x03\n\x0f\n\x08\x04\0\x02\x05\x08\xee\xfb\x03\
    \x12\x03\"\x04A\n\x92\x05\n\x02\x04\x01\x12\x042\09\x01\x1a\x85\x05\x20V\
    alidatorHistoricalRewards\x20represents\x20historical\x20rewards\x20for\
    \x20a\x20validator.\n\x20Height\x20is\x20implicit\x20within\x20the\x20st\
    ore\x20key.\n\x20Cumulative\x20reward\x20ratio\x20is\x20the\x20sum\x20fr\
    om\x20the\x20zeroeth\x20period\n\x20until\x20this\x20period\x20of\x20rew\
    ards\x20/\x20tokens,\x20per\x20the\x20spec.\n\x20The\x20reference\x20cou\
    nt\x20indicates\x20the\x20number\x20of\x20objects\n\x20which\x20might\
    \x20need\x20to\x20reference\x20this\x20historical\x20entry\x20at\x20any\
    \x20point.\n\x20ReferenceCount\x20=\n\x20\x20\x20\x20number\x20of\x20out\
    standing\x20delegations\x20which\x20ended\x20the\x20associated\x20period\
    \x20(and\n\x20\x20\x20\x20might\x20need\x20to\x20read\x20that\x20record)\
    \n\x20\x20+\x20number\x20of\x20slashes\x20which\x20ended\x20the\x20assoc\
    iated\x20period\x20(and\x20might\x20need\x20to\n\x20\x20read\x20that\x20\
    record)\n\x20\x20+\x20one\x20per\x20validator\x20for\x20the\x20zeroeth\
    \x20period,\x20set\x20on\x20initialization\n\n\n\n\x03\x04\x01\x01\x12\
    \x032\x08\"\n\x0c\n\x04\x04\x01\x02\0\x12\x043\x027\x04\n\x0c\n\x05\x04\
    \x01\x02\0\x04\x12\x033\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x033\x0b\
    &\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x033'>\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x033AB\n\r\n\x05\x04\x01\x02\0\x08\x12\x043C7\x03\n\x0f\n\x08\x04\
    \x01\x02\0\x08\xee\xfb\x03\x12\x034\x04A\n\x0f\n\x08\x04\x01\x02\0\x08\
    \xf5\xfb\x03\x12\x035\x04L\n\x0f\n\x08\x04\x01\x02\0\x08\xe9\xfb\x03\x12\
    \x036\x04$\n\x0b\n\x04\x04\x01\x02\x01\x12\x038\x02Q\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x038\t\
    \x18\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x038\x1b\x1c\n\x0c\n\x05\x04\
    \x01\x02\x01\x08\x12\x038\x1dP\n\x0f\n\x08\x04\x01\x02\x01\x08\xee\xfb\
    \x03\x12\x038\x1eO\n\xce\x01\n\x02\x04\x02\x12\x04>\0B\x01\x1a\xc1\x01\
    \x20ValidatorCurrentRewards\x20represents\x20current\x20rewards\x20and\
    \x20current\n\x20period\x20for\x20a\x20validator\x20kept\x20as\x20a\x20r\
    unning\x20counter\x20and\x20incremented\n\x20each\x20block\x20as\x20long\
    \x20as\x20the\x20validator's\x20tokens\x20remain\x20constant.\n\n\n\n\
    \x03\x04\x02\x01\x12\x03>\x08\x1f\n\x0c\n\x04\x04\x02\x02\0\x12\x04?\x02\
    @o\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03?\x02\n\n\x0c\n\x05\x04\x02\x02\
    \0\x06\x12\x03?\x0b&\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03?'.\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03?12\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03@\
    \x06n\n\x0f\n\x08\x04\x02\x02\0\x08\xf5\xfb\x03\x12\x03@\x07O\n\x0f\n\
    \x08\x04\x02\x02\0\x08\xe9\xfb\x03\x12\x03@Qm\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03A\x02\x14\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03A\x02\x08\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03A\t\x0f\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x03A\x12\x13\n\x99\x01\n\x02\x04\x03\x12\x04F\0I\x01\x1a\
    \x8c\x01\x20ValidatorAccumulatedCommission\x20represents\x20accumulated\
    \x20commission\n\x20for\x20a\x20validator\x20kept\x20as\x20a\x20running\
    \x20counter,\x20can\x20be\x20withdrawn\x20at\x20any\x20time.\n\n\n\n\x03\
    \x04\x03\x01\x12\x03F\x08&\n\x0c\n\x04\x04\x03\x02\0\x12\x04G\x02Ho\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x03G\x02\n\n\x0c\n\x05\x04\x03\x02\0\
    \x06\x12\x03G\x0b&\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03G'1\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03G45\n\x0c\n\x05\x04\x03\x02\0\x08\x12\x03H\x06\
    n\n\x0f\n\x08\x04\x03\x02\0\x08\xf5\xfb\x03\x12\x03H\x07O\n\x0f\n\x08\
    \x04\x03\x02\0\x08\xe9\xfb\x03\x12\x03HQm\n\x9c\x01\n\x02\x04\x04\x12\
    \x04M\0S\x01\x1a\x8f\x01\x20ValidatorOutstandingRewards\x20represents\
    \x20outstanding\x20(un-withdrawn)\x20rewards\n\x20for\x20a\x20validator\
    \x20inexpensive\x20to\x20track,\x20allows\x20simple\x20sanity\x20checks.\
    \n\n\n\n\x03\x04\x04\x01\x12\x03M\x08#\n\x0c\n\x04\x04\x04\x02\0\x12\x04\
    N\x02R\x04\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03N\x02\n\n\x0c\n\x05\x04\
    \x04\x02\0\x06\x12\x03N\x0b&\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03N'.\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03N12\n\r\n\x05\x04\x04\x02\0\x08\x12\
    \x04N3R\x03\n\x0f\n\x08\x04\x04\x02\0\x08\xee\xfb\x03\x12\x03O\x041\n\
    \x0f\n\x08\x04\x04\x02\0\x08\xf5\xfb\x03\x12\x03P\x04L\n\x0f\n\x08\x04\
    \x04\x02\0\x08\xe9\xfb\x03\x12\x03Q\x04$\n\xf3\x01\n\x02\x04\x05\x12\x04\
    Y\0\\\x01\x1a\xe6\x01\x20ValidatorSlashEvent\x20represents\x20a\x20valid\
    ator\x20slash\x20event.\n\x20Height\x20is\x20implicit\x20within\x20the\
    \x20store\x20key.\n\x20This\x20is\x20needed\x20to\x20calculate\x20approp\
    riate\x20amount\x20of\x20staking\x20tokens\n\x20for\x20delegations\x20wh\
    ich\x20are\x20withdrawn\x20after\x20a\x20slash\x20has\x20occurred.\n\n\n\
    \n\x03\x04\x05\x01\x12\x03Y\x08\x1b\n\x0b\n\x04\x04\x05\x02\0\x12\x03Z\
    \x02S\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03Z\x02\x08\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03Z\t\x19\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03Z\x1c\x1d\
    \n\x0c\n\x05\x04\x05\x02\0\x08\x12\x03Z\x1eR\n\x0f\n\x08\x04\x05\x02\0\
    \x08\xee\xfb\x03\x12\x03Z\x1fQ\n\x0b\n\x04\x04\x05\x02\x01\x12\x03[\x02x\
    \n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x05\
    \x02\x01\x01\x12\x03[\t\x11\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03[\x14\
    \x15\n\x0c\n\x05\x04\x05\x02\x01\x08\x12\x03[\x16w\n\x0f\n\x08\x04\x05\
    \x02\x01\x08\xeb\xfb\x03\x12\x03[\x17X\n\x0f\n\x08\x04\x05\x02\x01\x08\
    \xe9\xfb\x03\x12\x03[Zv\nS\n\x02\x04\x06\x12\x04_\0c\x01\x1aG\x20Validat\
    orSlashEvents\x20is\x20a\x20collection\x20of\x20ValidatorSlashEvent\x20m\
    essages.\n\n\n\n\x03\x04\x06\x01\x12\x03_\x08\x1c\n\n\n\x03\x04\x06\x07\
    \x12\x03`\x02>\n\r\n\x06\x04\x06\x07\x83\xf4\x03\x12\x03`\x02>\n\x0c\n\
    \x04\x04\x06\x02\0\x12\x04a\x02b_\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03a\
    \x02\n\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03a\x0b\x1e\n\x0c\n\x05\x04\
    \x06\x02\0\x01\x12\x03a\x1f5\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03a89\n\
    \x0c\n\x05\x04\x06\x02\0\x08\x12\x03b\x06^\n\x0f\n\x08\x04\x06\x02\0\x08\
    \xee\xfb\x03\x12\x03b\x07?\n\x0f\n\x08\x04\x06\x02\0\x08\xe9\xfb\x03\x12\
    \x03bA]\n>\n\x02\x04\x07\x12\x04f\0l\x01\x1a2\x20FeePool\x20is\x20the\
    \x20global\x20fee\x20pool\x20for\x20distribution.\n\n\n\n\x03\x04\x07\
    \x01\x12\x03f\x08\x0f\n\x0c\n\x04\x04\x07\x02\0\x12\x04g\x02k\x04\n\x0c\
    \n\x05\x04\x07\x02\0\x04\x12\x03g\x02\n\n\x0c\n\x05\x04\x07\x02\0\x06\
    \x12\x03g\x0b&\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03g'5\n\x0c\n\x05\x04\
    \x07\x02\0\x03\x12\x03g89\n\r\n\x05\x04\x07\x02\0\x08\x12\x04g:k\x03\n\
    \x0f\n\x08\x04\x07\x02\0\x08\xe9\xfb\x03\x12\x03h\x04$\n\x0f\n\x08\x04\
    \x07\x02\0\x08\xf5\xfb\x03\x12\x03i\x04L\n\x0f\n\x08\x04\x07\x02\0\x08\
    \xee\xfb\x03\x12\x03j\x048\n\xb1\x01\n\x02\x04\x08\x12\x04q\0{\x01\x1a\
    \xa4\x01\x20CommunityPoolSpendProposal\x20details\x20a\x20proposal\x20fo\
    r\x20use\x20of\x20community\x20funds,\n\x20together\x20with\x20how\x20ma\
    ny\x20coins\x20are\x20proposed\x20to\x20be\x20spent,\x20and\x20to\x20whi\
    ch\n\x20recipient\x20account.\n\n\n\n\x03\x04\x08\x01\x12\x03q\x08\"\n\n\
    \n\x03\x04\x08\x07\x12\x03r\x02.\n\r\n\x06\x04\x08\x07\x8d\xf4\x03\x12\
    \x03r\x02.\n\n\n\x03\x04\x08\x07\x12\x03s\x02.\n\r\n\x06\x04\x08\x07\x81\
    \xf4\x03\x12\x03s\x02.\n\n\n\x03\x04\x08\x07\x12\x03t\x02.\n\r\n\x06\x04\
    \x08\x07\x83\xf4\x03\x12\x03t\x02.\n\x0b\n\x04\x04\x08\x02\0\x12\x03v\
    \x02/\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03v\x02\x08\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x03v\x0b\x10\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03v-.\n\
    \x0b\n\x04\x04\x08\x02\x01\x12\x03w\x02/\n\x0c\n\x05\x04\x08\x02\x01\x05\
    \x12\x03w\x02\x08\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03w\x0b\x16\n\x0c\
    \n\x05\x04\x08\x02\x01\x03\x12\x03w-.\n\x0b\n\x04\x04\x08\x02\x02\x12\
    \x03x\x02/\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03x\x02\x08\n\x0c\n\x05\
    \x04\x08\x02\x02\x01\x12\x03x\x0b\x14\n\x0c\n\x05\x04\x08\x02\x02\x03\
    \x12\x03x-.\n\x0c\n\x04\x04\x08\x02\x03\x12\x04y\x02zl\n\x0c\n\x05\x04\
    \x08\x02\x03\x04\x12\x03y\x02\n\n\x0c\n\x05\x04\x08\x02\x03\x06\x12\x03y\
    \x0b#\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03y$*\n\x0c\n\x05\x04\x08\x02\
    \x03\x03\x12\x03y-.\n\x0c\n\x05\x04\x08\x02\x03\x08\x12\x03z\x06k\n\x0f\
    \n\x08\x04\x08\x02\x03\x08\xe9\xfb\x03\x12\x03z\x07#\n\x0f\n\x08\x04\x08\
    \x02\x03\x08\xf5\xfb\x03\x12\x03z%j\n\xa9\x03\n\x02\x04\t\x12\x06\x83\
    \x01\0\x8b\x01\x01\x1a\x9a\x03\x20DelegatorStartingInfo\x20represents\
    \x20the\x20starting\x20info\x20for\x20a\x20delegator\x20reward\n\x20peri\
    od.\x20It\x20tracks\x20the\x20previous\x20validator\x20period,\x20the\
    \x20delegation's\x20amount\x20of\n\x20staking\x20token,\x20and\x20the\
    \x20creation\x20height\x20(to\x20check\x20later\x20on\x20if\x20any\x20sl\
    ashes\x20have\n\x20occurred).\x20NOTE:\x20Even\x20though\x20validators\
    \x20are\x20slashed\x20to\x20whole\x20staking\x20tokens,\n\x20the\x20dele\
    gators\x20within\x20the\x20validator\x20may\x20be\x20left\x20with\x20les\
    s\x20than\x20a\x20full\x20token,\n\x20thus\x20sdk.Dec\x20is\x20used.\n\n\
    \x0b\n\x03\x04\t\x01\x12\x04\x83\x01\x08\x1d\n\x0c\n\x04\x04\t\x02\0\x12\
    \x04\x84\x01\x02Q\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x84\x01\x02\x08\n\r\
    \n\x05\x04\t\x02\0\x01\x12\x04\x84\x01\t\x18\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\x84\x01\x1b\x1c\n\r\n\x05\x04\t\x02\0\x08\x12\x04\x84\x01\x1dP\
    \n\x10\n\x08\x04\t\x02\0\x08\xee\xfb\x03\x12\x04\x84\x01\x1eO\n\x0e\n\
    \x04\x04\t\x02\x01\x12\x06\x85\x01\x02\x89\x01\x04\n\r\n\x05\x04\t\x02\
    \x01\x05\x12\x04\x85\x01\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x85\
    \x01\t\x0e\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x85\x01\x1b\x1c\n\x0f\n\
    \x05\x04\t\x02\x01\x08\x12\x06\x85\x01\x1d\x89\x01\x03\n\x10\n\x08\x04\t\
    \x02\x01\x08\xee\xfb\x03\x12\x04\x86\x01\x04-\n\x10\n\x08\x04\t\x02\x01\
    \x08\xeb\xfb\x03\x12\x04\x87\x01\x04E\n\x10\n\x08\x04\t\x02\x01\x08\xe9\
    \xfb\x03\x12\x04\x88\x01\x04\"\n\x0c\n\x04\x04\t\x02\x02\x12\x04\x8a\x01\
    \x02q\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\x8a\x01\x02\x08\n\r\n\x05\x04\
    \t\x02\x02\x01\x12\x04\x8a\x01\t\x0f\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\
    \x8a\x01\x12\x13\n\r\n\x05\x04\t\x02\x02\x08\x12\x04\x8a\x01\x14p\n\x10\
    \n\x08\x04\t\x02\x02\x08\xee\xfb\x03\x12\x04\x8a\x01\x15F\n\x10\n\x08\
    \x04\t\x02\x02\x08\xed\xfb\x03\x12\x04\x8a\x01Ho\nh\n\x02\x04\n\x12\x06\
    \x8f\x01\0\x97\x01\x01\x1aZ\x20DelegationDelegatorReward\x20represents\
    \x20the\x20properties\n\x20of\x20a\x20delegator's\x20delegation\x20rewar\
    d.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x8f\x01\x08!\n\x0b\n\x03\x04\n\x07\
    \x12\x04\x90\x01\x02.\n\x0e\n\x06\x04\n\x07\x81\xf4\x03\x12\x04\x90\x01\
    \x02.\n\x0b\n\x03\x04\n\x07\x12\x04\x91\x01\x02-\n\x0e\n\x06\x04\n\x07\
    \x83\xf4\x03\x12\x04\x91\x01\x02-\n\x0c\n\x04\x04\n\x02\0\x12\x04\x93\
    \x01\x02U\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x93\x01\x02\x08\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\x93\x01\t\x1a\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \x93\x01\x1d\x1e\n\r\n\x05\x04\n\x02\0\x08\x12\x04\x93\x01\x1fT\n\x10\n\
    \x08\x04\n\x02\0\x08\xee\xfb\x03\x12\x04\x93\x01\x20S\n\x0e\n\x04\x04\n\
    \x02\x01\x12\x06\x95\x01\x02\x96\x01o\n\r\n\x05\x04\n\x02\x01\x04\x12\
    \x04\x95\x01\x02\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x95\x01\x0b&\n\r\
    \n\x05\x04\n\x02\x01\x01\x12\x04\x95\x01'-\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\x95\x0101\n\r\n\x05\x04\n\x02\x01\x08\x12\x04\x96\x01\x06n\n\
    \x10\n\x08\x04\n\x02\x01\x08\xf5\xfb\x03\x12\x04\x96\x01\x07O\n\x10\n\
    \x08\x04\n\x02\x01\x08\xe9\xfb\x03\x12\x04\x96\x01Qm\nj\n\x02\x04\x0b\
    \x12\x06\x9b\x01\0\xa4\x01\x01\x1a\\\x20CommunityPoolSpendProposalWithDe\
    posit\x20defines\x20a\x20CommunityPoolSpendProposal\n\x20with\x20a\x20de\
    posit\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x9b\x01\x08-\n\x0b\n\x03\x04\x0b\
    \x07\x12\x04\x9c\x01\x02.\n\x0e\n\x06\x04\x0b\x07\x81\xf4\x03\x12\x04\
    \x9c\x01\x02.\n\x0b\n\x03\x04\x0b\x07\x12\x04\x9d\x01\x02-\n\x0e\n\x06\
    \x04\x0b\x07\x83\xf4\x03\x12\x04\x9d\x01\x02-\n\x0c\n\x04\x04\x0b\x02\0\
    \x12\x04\x9f\x01\x02C\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x9f\x01\x02\
    \x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9f\x01\t\x0e\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\x9f\x01\x17\x18\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\
    \x9f\x01\x19B\n\x10\n\x08\x04\x0b\x02\0\x08\xee\xfb\x03\x12\x04\x9f\x01\
    \x1aA\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xa0\x01\x02I\n\r\n\x05\x04\x0b\
    \x02\x01\x05\x12\x04\xa0\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\xa0\x01\t\x14\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xa0\x01\x17\x18\
    \n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xa0\x01\x19H\n\x10\n\x08\x04\x0b\
    \x02\x01\x08\xee\xfb\x03\x12\x04\xa0\x01\x1aG\n\x0c\n\x04\x04\x0b\x02\
    \x02\x12\x04\xa1\x01\x02G\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xa1\x01\
    \x02\x08\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xa1\x01\t\x12\n\r\n\x05\
    \x04\x0b\x02\x02\x03\x12\x04\xa1\x01\x17\x18\n\r\n\x05\x04\x0b\x02\x02\
    \x08\x12\x04\xa1\x01\x19F\n\x10\n\x08\x04\x0b\x02\x02\x08\xee\xfb\x03\
    \x12\x04\xa1\x01\x1aE\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\xa2\x01\x02D\n\
    \r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xa2\x01\x02\x08\n\r\n\x05\x04\x0b\
    \x02\x03\x01\x12\x04\xa2\x01\t\x0f\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\
    \xa2\x01\x17\x18\n\r\n\x05\x04\x0b\x02\x03\x08\x12\x04\xa2\x01\x19C\n\
    \x10\n\x08\x04\x0b\x02\x03\x08\xee\xfb\x03\x12\x04\xa2\x01\x1aB\n\x0c\n\
    \x04\x04\x0b\x02\x04\x12\x04\xa3\x01\x02E\n\r\n\x05\x04\x0b\x02\x04\x05\
    \x12\x04\xa3\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xa3\x01\t\
    \x10\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xa3\x01\x17\x18\n\r\n\x05\x04\
    \x0b\x02\x04\x08\x12\x04\xa3\x01\x19D\n\x10\n\x08\x04\x0b\x02\x04\x08\
    \xee\xfb\x03\x12\x04\xa3\x01\x1aCb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(super::coin::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(Params::generated_message_descriptor_data());
            messages.push(ValidatorHistoricalRewards::generated_message_descriptor_data());
            messages.push(ValidatorCurrentRewards::generated_message_descriptor_data());
            messages.push(ValidatorAccumulatedCommission::generated_message_descriptor_data());
            messages.push(ValidatorOutstandingRewards::generated_message_descriptor_data());
            messages.push(ValidatorSlashEvent::generated_message_descriptor_data());
            messages.push(ValidatorSlashEvents::generated_message_descriptor_data());
            messages.push(FeePool::generated_message_descriptor_data());
            messages.push(CommunityPoolSpendProposal::generated_message_descriptor_data());
            messages.push(DelegatorStartingInfo::generated_message_descriptor_data());
            messages.push(DelegationDelegatorReward::generated_message_descriptor_data());
            messages.push(CommunityPoolSpendProposalWithDeposit::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
