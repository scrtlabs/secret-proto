// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos/distribution/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  QueryParamsRequest is the request type for the Query/Params RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryParamsRequest)
pub struct QueryParamsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryParamsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryParamsRequest {
    fn default() -> &'a QueryParamsRequest {
        <QueryParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsRequest {
    pub fn new() -> QueryParamsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryParamsRequest>(
            "QueryParamsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryParamsRequest {
        QueryParamsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryParamsRequest {
        static instance: QueryParamsRequest = QueryParamsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryParamsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryParamsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryParamsResponse is the response type for the Query/Params RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryParamsResponse)
pub struct QueryParamsResponse {
    // message fields
    ///  params defines the parameters of the module.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryParamsResponse.params)
    pub params: ::protobuf::MessageField<super::distribution::Params>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryParamsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryParamsResponse {
    fn default() -> &'a QueryParamsResponse {
        <QueryParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsResponse {
    pub fn new() -> QueryParamsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::distribution::Params>(
            "params",
            |m: &QueryParamsResponse| { &m.params },
            |m: &mut QueryParamsResponse| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryParamsResponse>(
            "QueryParamsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryParamsResponse {
        QueryParamsResponse::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryParamsResponse {
        static instance: QueryParamsResponse = QueryParamsResponse {
            params: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryParamsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryParamsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryValidatorOutstandingRewardsRequest is the request type for the
///  Query/ValidatorOutstandingRewards RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest)
pub struct QueryValidatorOutstandingRewardsRequest {
    // message fields
    ///  validator_address defines the validator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest.validator_address)
    pub validator_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryValidatorOutstandingRewardsRequest {
    fn default() -> &'a QueryValidatorOutstandingRewardsRequest {
        <QueryValidatorOutstandingRewardsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorOutstandingRewardsRequest {
    pub fn new() -> QueryValidatorOutstandingRewardsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &QueryValidatorOutstandingRewardsRequest| { &m.validator_address },
            |m: &mut QueryValidatorOutstandingRewardsRequest| { &mut m.validator_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryValidatorOutstandingRewardsRequest>(
            "QueryValidatorOutstandingRewardsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryValidatorOutstandingRewardsRequest {
    const NAME: &'static str = "QueryValidatorOutstandingRewardsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validator_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.validator_address.is_empty() {
            os.write_string(1, &self.validator_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryValidatorOutstandingRewardsRequest {
        QueryValidatorOutstandingRewardsRequest::new()
    }

    fn clear(&mut self) {
        self.validator_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryValidatorOutstandingRewardsRequest {
        static instance: QueryValidatorOutstandingRewardsRequest = QueryValidatorOutstandingRewardsRequest {
            validator_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryValidatorOutstandingRewardsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryValidatorOutstandingRewardsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryValidatorOutstandingRewardsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorOutstandingRewardsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryValidatorOutstandingRewardsResponse is the response type for the
///  Query/ValidatorOutstandingRewards RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse)
pub struct QueryValidatorOutstandingRewardsResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse.rewards)
    pub rewards: ::protobuf::MessageField<super::distribution::ValidatorOutstandingRewards>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryValidatorOutstandingRewardsResponse {
    fn default() -> &'a QueryValidatorOutstandingRewardsResponse {
        <QueryValidatorOutstandingRewardsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorOutstandingRewardsResponse {
    pub fn new() -> QueryValidatorOutstandingRewardsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::distribution::ValidatorOutstandingRewards>(
            "rewards",
            |m: &QueryValidatorOutstandingRewardsResponse| { &m.rewards },
            |m: &mut QueryValidatorOutstandingRewardsResponse| { &mut m.rewards },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryValidatorOutstandingRewardsResponse>(
            "QueryValidatorOutstandingRewardsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryValidatorOutstandingRewardsResponse {
    const NAME: &'static str = "QueryValidatorOutstandingRewardsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rewards)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rewards.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rewards.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryValidatorOutstandingRewardsResponse {
        QueryValidatorOutstandingRewardsResponse::new()
    }

    fn clear(&mut self) {
        self.rewards.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryValidatorOutstandingRewardsResponse {
        static instance: QueryValidatorOutstandingRewardsResponse = QueryValidatorOutstandingRewardsResponse {
            rewards: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryValidatorOutstandingRewardsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryValidatorOutstandingRewardsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryValidatorOutstandingRewardsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorOutstandingRewardsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryValidatorCommissionRequest is the request type for the
///  Query/ValidatorCommission RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryValidatorCommissionRequest)
pub struct QueryValidatorCommissionRequest {
    // message fields
    ///  validator_address defines the validator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorCommissionRequest.validator_address)
    pub validator_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryValidatorCommissionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryValidatorCommissionRequest {
    fn default() -> &'a QueryValidatorCommissionRequest {
        <QueryValidatorCommissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorCommissionRequest {
    pub fn new() -> QueryValidatorCommissionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &QueryValidatorCommissionRequest| { &m.validator_address },
            |m: &mut QueryValidatorCommissionRequest| { &mut m.validator_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryValidatorCommissionRequest>(
            "QueryValidatorCommissionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryValidatorCommissionRequest {
    const NAME: &'static str = "QueryValidatorCommissionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validator_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.validator_address.is_empty() {
            os.write_string(1, &self.validator_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryValidatorCommissionRequest {
        QueryValidatorCommissionRequest::new()
    }

    fn clear(&mut self) {
        self.validator_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryValidatorCommissionRequest {
        static instance: QueryValidatorCommissionRequest = QueryValidatorCommissionRequest {
            validator_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryValidatorCommissionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryValidatorCommissionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryValidatorCommissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorCommissionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryValidatorCommissionResponse is the response type for the
///  Query/ValidatorCommission RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryValidatorCommissionResponse)
pub struct QueryValidatorCommissionResponse {
    // message fields
    ///  commission defines the commision the validator received.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorCommissionResponse.commission)
    pub commission: ::protobuf::MessageField<super::distribution::ValidatorAccumulatedCommission>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryValidatorCommissionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryValidatorCommissionResponse {
    fn default() -> &'a QueryValidatorCommissionResponse {
        <QueryValidatorCommissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorCommissionResponse {
    pub fn new() -> QueryValidatorCommissionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::distribution::ValidatorAccumulatedCommission>(
            "commission",
            |m: &QueryValidatorCommissionResponse| { &m.commission },
            |m: &mut QueryValidatorCommissionResponse| { &mut m.commission },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryValidatorCommissionResponse>(
            "QueryValidatorCommissionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryValidatorCommissionResponse {
    const NAME: &'static str = "QueryValidatorCommissionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commission)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.commission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryValidatorCommissionResponse {
        QueryValidatorCommissionResponse::new()
    }

    fn clear(&mut self) {
        self.commission.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryValidatorCommissionResponse {
        static instance: QueryValidatorCommissionResponse = QueryValidatorCommissionResponse {
            commission: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryValidatorCommissionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryValidatorCommissionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryValidatorCommissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorCommissionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryValidatorSlashesRequest is the request type for the
///  Query/ValidatorSlashes RPC method
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryValidatorSlashesRequest)
pub struct QueryValidatorSlashesRequest {
    // message fields
    ///  validator_address defines the validator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorSlashesRequest.validator_address)
    pub validator_address: ::std::string::String,
    ///  starting_height defines the optional starting height to query the slashes.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorSlashesRequest.starting_height)
    pub starting_height: u64,
    ///  starting_height defines the optional ending height to query the slashes.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorSlashesRequest.ending_height)
    pub ending_height: u64,
    ///  pagination defines an optional pagination for the request.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorSlashesRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryValidatorSlashesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryValidatorSlashesRequest {
    fn default() -> &'a QueryValidatorSlashesRequest {
        <QueryValidatorSlashesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorSlashesRequest {
    pub fn new() -> QueryValidatorSlashesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &QueryValidatorSlashesRequest| { &m.validator_address },
            |m: &mut QueryValidatorSlashesRequest| { &mut m.validator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starting_height",
            |m: &QueryValidatorSlashesRequest| { &m.starting_height },
            |m: &mut QueryValidatorSlashesRequest| { &mut m.starting_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ending_height",
            |m: &QueryValidatorSlashesRequest| { &m.ending_height },
            |m: &mut QueryValidatorSlashesRequest| { &mut m.ending_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryValidatorSlashesRequest| { &m.pagination },
            |m: &mut QueryValidatorSlashesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryValidatorSlashesRequest>(
            "QueryValidatorSlashesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryValidatorSlashesRequest {
    const NAME: &'static str = "QueryValidatorSlashesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validator_address = is.read_string()?;
                },
                16 => {
                    self.starting_height = is.read_uint64()?;
                },
                24 => {
                    self.ending_height = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_address);
        }
        if self.starting_height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.starting_height);
        }
        if self.ending_height != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.ending_height);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.validator_address.is_empty() {
            os.write_string(1, &self.validator_address)?;
        }
        if self.starting_height != 0 {
            os.write_uint64(2, self.starting_height)?;
        }
        if self.ending_height != 0 {
            os.write_uint64(3, self.ending_height)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryValidatorSlashesRequest {
        QueryValidatorSlashesRequest::new()
    }

    fn clear(&mut self) {
        self.validator_address.clear();
        self.starting_height = 0;
        self.ending_height = 0;
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryValidatorSlashesRequest {
        static instance: QueryValidatorSlashesRequest = QueryValidatorSlashesRequest {
            validator_address: ::std::string::String::new(),
            starting_height: 0,
            ending_height: 0,
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryValidatorSlashesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryValidatorSlashesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryValidatorSlashesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorSlashesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryValidatorSlashesResponse is the response type for the
///  Query/ValidatorSlashes RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryValidatorSlashesResponse)
pub struct QueryValidatorSlashesResponse {
    // message fields
    ///  slashes defines the slashes the validator received.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorSlashesResponse.slashes)
    pub slashes: ::std::vec::Vec<super::distribution::ValidatorSlashEvent>,
    ///  pagination defines the pagination in the response.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryValidatorSlashesResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryValidatorSlashesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryValidatorSlashesResponse {
    fn default() -> &'a QueryValidatorSlashesResponse {
        <QueryValidatorSlashesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorSlashesResponse {
    pub fn new() -> QueryValidatorSlashesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "slashes",
            |m: &QueryValidatorSlashesResponse| { &m.slashes },
            |m: &mut QueryValidatorSlashesResponse| { &mut m.slashes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryValidatorSlashesResponse| { &m.pagination },
            |m: &mut QueryValidatorSlashesResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryValidatorSlashesResponse>(
            "QueryValidatorSlashesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryValidatorSlashesResponse {
    const NAME: &'static str = "QueryValidatorSlashesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.slashes.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.slashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.slashes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryValidatorSlashesResponse {
        QueryValidatorSlashesResponse::new()
    }

    fn clear(&mut self) {
        self.slashes.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryValidatorSlashesResponse {
        static instance: QueryValidatorSlashesResponse = QueryValidatorSlashesResponse {
            slashes: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryValidatorSlashesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryValidatorSlashesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryValidatorSlashesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorSlashesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegationRewardsRequest is the request type for the
///  Query/DelegationRewards RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegationRewardsRequest)
pub struct QueryDelegationRewardsRequest {
    // message fields
    ///  delegator_address defines the delegator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegationRewardsRequest.delegator_address)
    pub delegator_address: ::std::string::String,
    ///  validator_address defines the validator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegationRewardsRequest.validator_address)
    pub validator_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegationRewardsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegationRewardsRequest {
    fn default() -> &'a QueryDelegationRewardsRequest {
        <QueryDelegationRewardsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegationRewardsRequest {
    pub fn new() -> QueryDelegationRewardsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &QueryDelegationRewardsRequest| { &m.delegator_address },
            |m: &mut QueryDelegationRewardsRequest| { &mut m.delegator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &QueryDelegationRewardsRequest| { &m.validator_address },
            |m: &mut QueryDelegationRewardsRequest| { &mut m.validator_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegationRewardsRequest>(
            "QueryDelegationRewardsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegationRewardsRequest {
    const NAME: &'static str = "QueryDelegationRewardsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                18 => {
                    self.validator_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_address.is_empty() {
            os.write_string(2, &self.validator_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegationRewardsRequest {
        QueryDelegationRewardsRequest::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegationRewardsRequest {
        static instance: QueryDelegationRewardsRequest = QueryDelegationRewardsRequest {
            delegator_address: ::std::string::String::new(),
            validator_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegationRewardsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegationRewardsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegationRewardsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegationRewardsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegationRewardsResponse is the response type for the
///  Query/DelegationRewards RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegationRewardsResponse)
pub struct QueryDelegationRewardsResponse {
    // message fields
    ///  rewards defines the rewards accrued by a delegation.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegationRewardsResponse.rewards)
    pub rewards: ::std::vec::Vec<super::coin::DecCoin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegationRewardsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegationRewardsResponse {
    fn default() -> &'a QueryDelegationRewardsResponse {
        <QueryDelegationRewardsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegationRewardsResponse {
    pub fn new() -> QueryDelegationRewardsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rewards",
            |m: &QueryDelegationRewardsResponse| { &m.rewards },
            |m: &mut QueryDelegationRewardsResponse| { &mut m.rewards },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegationRewardsResponse>(
            "QueryDelegationRewardsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegationRewardsResponse {
    const NAME: &'static str = "QueryDelegationRewardsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rewards.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rewards {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegationRewardsResponse {
        QueryDelegationRewardsResponse::new()
    }

    fn clear(&mut self) {
        self.rewards.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegationRewardsResponse {
        static instance: QueryDelegationRewardsResponse = QueryDelegationRewardsResponse {
            rewards: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegationRewardsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegationRewardsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegationRewardsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegationRewardsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegationTotalRewardsRequest is the request type for the
///  Query/DelegationTotalRewards RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest)
pub struct QueryDelegationTotalRewardsRequest {
    // message fields
    ///  delegator_address defines the delegator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest.delegator_address)
    pub delegator_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegationTotalRewardsRequest {
    fn default() -> &'a QueryDelegationTotalRewardsRequest {
        <QueryDelegationTotalRewardsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegationTotalRewardsRequest {
    pub fn new() -> QueryDelegationTotalRewardsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &QueryDelegationTotalRewardsRequest| { &m.delegator_address },
            |m: &mut QueryDelegationTotalRewardsRequest| { &mut m.delegator_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegationTotalRewardsRequest>(
            "QueryDelegationTotalRewardsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegationTotalRewardsRequest {
    const NAME: &'static str = "QueryDelegationTotalRewardsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegationTotalRewardsRequest {
        QueryDelegationTotalRewardsRequest::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegationTotalRewardsRequest {
        static instance: QueryDelegationTotalRewardsRequest = QueryDelegationTotalRewardsRequest {
            delegator_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegationTotalRewardsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegationTotalRewardsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegationTotalRewardsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegationTotalRewardsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegationTotalRewardsResponse is the response type for the
///  Query/DelegationTotalRewards RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse)
pub struct QueryDelegationTotalRewardsResponse {
    // message fields
    ///  rewards defines all the rewards accrued by a delegator.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse.rewards)
    pub rewards: ::std::vec::Vec<super::distribution::DelegationDelegatorReward>,
    ///  total defines the sum of all the rewards.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse.total)
    pub total: ::std::vec::Vec<super::coin::DecCoin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegationTotalRewardsResponse {
    fn default() -> &'a QueryDelegationTotalRewardsResponse {
        <QueryDelegationTotalRewardsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegationTotalRewardsResponse {
    pub fn new() -> QueryDelegationTotalRewardsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rewards",
            |m: &QueryDelegationTotalRewardsResponse| { &m.rewards },
            |m: &mut QueryDelegationTotalRewardsResponse| { &mut m.rewards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "total",
            |m: &QueryDelegationTotalRewardsResponse| { &m.total },
            |m: &mut QueryDelegationTotalRewardsResponse| { &mut m.total },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegationTotalRewardsResponse>(
            "QueryDelegationTotalRewardsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegationTotalRewardsResponse {
    const NAME: &'static str = "QueryDelegationTotalRewardsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rewards.push(is.read_message()?);
                },
                18 => {
                    self.total.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.total {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rewards {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.total {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegationTotalRewardsResponse {
        QueryDelegationTotalRewardsResponse::new()
    }

    fn clear(&mut self) {
        self.rewards.clear();
        self.total.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegationTotalRewardsResponse {
        static instance: QueryDelegationTotalRewardsResponse = QueryDelegationTotalRewardsResponse {
            rewards: ::std::vec::Vec::new(),
            total: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegationTotalRewardsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegationTotalRewardsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegationTotalRewardsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegationTotalRewardsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegatorValidatorsRequest is the request type for the
///  Query/DelegatorValidators RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest)
pub struct QueryDelegatorValidatorsRequest {
    // message fields
    ///  delegator_address defines the delegator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest.delegator_address)
    pub delegator_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorValidatorsRequest {
    fn default() -> &'a QueryDelegatorValidatorsRequest {
        <QueryDelegatorValidatorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorValidatorsRequest {
    pub fn new() -> QueryDelegatorValidatorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &QueryDelegatorValidatorsRequest| { &m.delegator_address },
            |m: &mut QueryDelegatorValidatorsRequest| { &mut m.delegator_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegatorValidatorsRequest>(
            "QueryDelegatorValidatorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegatorValidatorsRequest {
    const NAME: &'static str = "QueryDelegatorValidatorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegatorValidatorsRequest {
        QueryDelegatorValidatorsRequest::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegatorValidatorsRequest {
        static instance: QueryDelegatorValidatorsRequest = QueryDelegatorValidatorsRequest {
            delegator_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegatorValidatorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegatorValidatorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegatorValidatorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorValidatorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegatorValidatorsResponse is the response type for the
///  Query/DelegatorValidators RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse)
pub struct QueryDelegatorValidatorsResponse {
    // message fields
    ///  validators defines the validators a delegator is delegating for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse.validators)
    pub validators: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorValidatorsResponse {
    fn default() -> &'a QueryDelegatorValidatorsResponse {
        <QueryDelegatorValidatorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorValidatorsResponse {
    pub fn new() -> QueryDelegatorValidatorsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validators",
            |m: &QueryDelegatorValidatorsResponse| { &m.validators },
            |m: &mut QueryDelegatorValidatorsResponse| { &mut m.validators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegatorValidatorsResponse>(
            "QueryDelegatorValidatorsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegatorValidatorsResponse {
    const NAME: &'static str = "QueryDelegatorValidatorsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validators.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.validators {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.validators {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegatorValidatorsResponse {
        QueryDelegatorValidatorsResponse::new()
    }

    fn clear(&mut self) {
        self.validators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegatorValidatorsResponse {
        static instance: QueryDelegatorValidatorsResponse = QueryDelegatorValidatorsResponse {
            validators: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegatorValidatorsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegatorValidatorsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegatorValidatorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorValidatorsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegatorWithdrawAddressRequest is the request type for the
///  Query/DelegatorWithdrawAddress RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest)
pub struct QueryDelegatorWithdrawAddressRequest {
    // message fields
    ///  delegator_address defines the delegator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest.delegator_address)
    pub delegator_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorWithdrawAddressRequest {
    fn default() -> &'a QueryDelegatorWithdrawAddressRequest {
        <QueryDelegatorWithdrawAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorWithdrawAddressRequest {
    pub fn new() -> QueryDelegatorWithdrawAddressRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &QueryDelegatorWithdrawAddressRequest| { &m.delegator_address },
            |m: &mut QueryDelegatorWithdrawAddressRequest| { &mut m.delegator_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegatorWithdrawAddressRequest>(
            "QueryDelegatorWithdrawAddressRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegatorWithdrawAddressRequest {
    const NAME: &'static str = "QueryDelegatorWithdrawAddressRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegatorWithdrawAddressRequest {
        QueryDelegatorWithdrawAddressRequest::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegatorWithdrawAddressRequest {
        static instance: QueryDelegatorWithdrawAddressRequest = QueryDelegatorWithdrawAddressRequest {
            delegator_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegatorWithdrawAddressRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegatorWithdrawAddressRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegatorWithdrawAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorWithdrawAddressRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegatorWithdrawAddressResponse is the response type for the
///  Query/DelegatorWithdrawAddress RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse)
pub struct QueryDelegatorWithdrawAddressResponse {
    // message fields
    ///  withdraw_address defines the delegator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse.withdraw_address)
    pub withdraw_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorWithdrawAddressResponse {
    fn default() -> &'a QueryDelegatorWithdrawAddressResponse {
        <QueryDelegatorWithdrawAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorWithdrawAddressResponse {
    pub fn new() -> QueryDelegatorWithdrawAddressResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdraw_address",
            |m: &QueryDelegatorWithdrawAddressResponse| { &m.withdraw_address },
            |m: &mut QueryDelegatorWithdrawAddressResponse| { &mut m.withdraw_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDelegatorWithdrawAddressResponse>(
            "QueryDelegatorWithdrawAddressResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDelegatorWithdrawAddressResponse {
    const NAME: &'static str = "QueryDelegatorWithdrawAddressResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.withdraw_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.withdraw_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.withdraw_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.withdraw_address.is_empty() {
            os.write_string(1, &self.withdraw_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDelegatorWithdrawAddressResponse {
        QueryDelegatorWithdrawAddressResponse::new()
    }

    fn clear(&mut self) {
        self.withdraw_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDelegatorWithdrawAddressResponse {
        static instance: QueryDelegatorWithdrawAddressResponse = QueryDelegatorWithdrawAddressResponse {
            withdraw_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDelegatorWithdrawAddressResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDelegatorWithdrawAddressResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDelegatorWithdrawAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorWithdrawAddressResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryFoundationTaxRequest is the request type for the
///  Query/FoundationTax RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryFoundationTaxRequest)
pub struct QueryFoundationTaxRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryFoundationTaxRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryFoundationTaxRequest {
    fn default() -> &'a QueryFoundationTaxRequest {
        <QueryFoundationTaxRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryFoundationTaxRequest {
    pub fn new() -> QueryFoundationTaxRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryFoundationTaxRequest>(
            "QueryFoundationTaxRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryFoundationTaxRequest {
    const NAME: &'static str = "QueryFoundationTaxRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryFoundationTaxRequest {
        QueryFoundationTaxRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryFoundationTaxRequest {
        static instance: QueryFoundationTaxRequest = QueryFoundationTaxRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryFoundationTaxRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryFoundationTaxRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryFoundationTaxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFoundationTaxRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDelegatorWithdrawAddressResponse is the response type for the
///  Query/DelegatorWithdrawAddress RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryFoundationTaxResponse)
pub struct QueryFoundationTaxResponse {
    // message fields
    ///  withdraw_address defines the delegator address to query for.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryFoundationTaxResponse.tax)
    pub tax: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryFoundationTaxResponse.foundation_address)
    pub foundation_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryFoundationTaxResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryFoundationTaxResponse {
    fn default() -> &'a QueryFoundationTaxResponse {
        <QueryFoundationTaxResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryFoundationTaxResponse {
    pub fn new() -> QueryFoundationTaxResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tax",
            |m: &QueryFoundationTaxResponse| { &m.tax },
            |m: &mut QueryFoundationTaxResponse| { &mut m.tax },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "foundation_address",
            |m: &QueryFoundationTaxResponse| { &m.foundation_address },
            |m: &mut QueryFoundationTaxResponse| { &mut m.foundation_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryFoundationTaxResponse>(
            "QueryFoundationTaxResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryFoundationTaxResponse {
    const NAME: &'static str = "QueryFoundationTaxResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tax = is.read_string()?;
                },
                18 => {
                    self.foundation_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tax.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tax);
        }
        if !self.foundation_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.foundation_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tax.is_empty() {
            os.write_string(1, &self.tax)?;
        }
        if !self.foundation_address.is_empty() {
            os.write_string(2, &self.foundation_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryFoundationTaxResponse {
        QueryFoundationTaxResponse::new()
    }

    fn clear(&mut self) {
        self.tax.clear();
        self.foundation_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryFoundationTaxResponse {
        static instance: QueryFoundationTaxResponse = QueryFoundationTaxResponse {
            tax: ::std::string::String::new(),
            foundation_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryFoundationTaxResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryFoundationTaxResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryFoundationTaxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFoundationTaxResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryCommunityPoolRequest is the request type for the Query/CommunityPool RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryCommunityPoolRequest)
pub struct QueryCommunityPoolRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryCommunityPoolRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryCommunityPoolRequest {
    fn default() -> &'a QueryCommunityPoolRequest {
        <QueryCommunityPoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryCommunityPoolRequest {
    pub fn new() -> QueryCommunityPoolRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryCommunityPoolRequest>(
            "QueryCommunityPoolRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryCommunityPoolRequest {
    const NAME: &'static str = "QueryCommunityPoolRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryCommunityPoolRequest {
        QueryCommunityPoolRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryCommunityPoolRequest {
        static instance: QueryCommunityPoolRequest = QueryCommunityPoolRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryCommunityPoolRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryCommunityPoolRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryCommunityPoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCommunityPoolRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryCommunityPoolResponse is the response type for the Query/CommunityPool
///  RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.distribution.v1beta1.QueryCommunityPoolResponse)
pub struct QueryCommunityPoolResponse {
    // message fields
    ///  pool defines community pool's coins.
    // @@protoc_insertion_point(field:cosmos.distribution.v1beta1.QueryCommunityPoolResponse.pool)
    pub pool: ::std::vec::Vec<super::coin::DecCoin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.distribution.v1beta1.QueryCommunityPoolResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryCommunityPoolResponse {
    fn default() -> &'a QueryCommunityPoolResponse {
        <QueryCommunityPoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryCommunityPoolResponse {
    pub fn new() -> QueryCommunityPoolResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pool",
            |m: &QueryCommunityPoolResponse| { &m.pool },
            |m: &mut QueryCommunityPoolResponse| { &mut m.pool },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryCommunityPoolResponse>(
            "QueryCommunityPoolResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryCommunityPoolResponse {
    const NAME: &'static str = "QueryCommunityPoolResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pool.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pool {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pool {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryCommunityPoolResponse {
        QueryCommunityPoolResponse::new()
    }

    fn clear(&mut self) {
        self.pool.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryCommunityPoolResponse {
        static instance: QueryCommunityPoolResponse = QueryCommunityPoolResponse {
            pool: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryCommunityPoolResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryCommunityPoolResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryCommunityPoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCommunityPoolResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'cosmos/distribution/v1beta1/query.proto\x12\x1bcosmos.distribution.v1\
    beta1\x1a*cosmos/base/query/v1beta1/pagination.proto\x1a\x14gogoproto/go\
    go.proto\x1a\x1cgoogle/api/annotations.proto\x1a\x1ecosmos/base/v1beta1/\
    coin.proto\x1a.cosmos/distribution/v1beta1/distribution.proto\"\x14\n\
    \x12QueryParamsRequest\"X\n\x13QueryParamsResponse\x12A\n\x06params\x18\
    \x01\x20\x01(\x0b2#.cosmos.distribution.v1beta1.ParamsR\x06paramsB\x04\
    \xc8\xde\x1f\0\"V\n'QueryValidatorOutstandingRewardsRequest\x12+\n\x11va\
    lidator_address\x18\x01\x20\x01(\tR\x10validatorAddress\"\x84\x01\n(Quer\
    yValidatorOutstandingRewardsResponse\x12X\n\x07rewards\x18\x01\x20\x01(\
    \x0b28.cosmos.distribution.v1beta1.ValidatorOutstandingRewardsR\x07rewar\
    dsB\x04\xc8\xde\x1f\0\"N\n\x1fQueryValidatorCommissionRequest\x12+\n\x11\
    validator_address\x18\x01\x20\x01(\tR\x10validatorAddress\"\x85\x01\n\
    \x20QueryValidatorCommissionResponse\x12a\n\ncommission\x18\x01\x20\x01(\
    \x0b2;.cosmos.distribution.v1beta1.ValidatorAccumulatedCommissionR\ncomm\
    issionB\x04\xc8\xde\x1f\0\"\xeb\x01\n\x1cQueryValidatorSlashesRequest\
    \x12+\n\x11validator_address\x18\x01\x20\x01(\tR\x10validatorAddress\x12\
    '\n\x0fstarting_height\x18\x02\x20\x01(\x04R\x0estartingHeight\x12#\n\re\
    nding_height\x18\x03\x20\x01(\x04R\x0cendingHeight\x12F\n\npagination\
    \x18\x04\x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npaginati\
    on:\x08\x88\xa0\x1f\0\x98\xa0\x1f\x01\"\xba\x01\n\x1dQueryValidatorSlash\
    esResponse\x12P\n\x07slashes\x18\x01\x20\x03(\x0b20.cosmos.distribution.\
    v1beta1.ValidatorSlashEventR\x07slashesB\x04\xc8\xde\x1f\0\x12G\n\npagin\
    ation\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npa\
    gination\"\x83\x01\n\x1dQueryDelegationRewardsRequest\x12+\n\x11delegato\
    r_address\x18\x01\x20\x01(\tR\x10delegatorAddress\x12+\n\x11validator_ad\
    dress\x18\x02\x20\x01(\tR\x10validatorAddress:\x08\x88\xa0\x1f\0\xe8\xa0\
    \x1f\0\"\x8d\x01\n\x1eQueryDelegationRewardsResponse\x12k\n\x07rewards\
    \x18\x01\x20\x03(\x0b2\x1c.cosmos.base.v1beta1.DecCoinR\x07rewardsB3\xaa\
    \xdf\x1f+github.com/cosmos/cosmos-sdk/types.DecCoins\xc8\xde\x1f\0\"[\n\
    \"QueryDelegationTotalRewardsRequest\x12+\n\x11delegator_address\x18\x01\
    \x20\x01(\tR\x10delegatorAddress:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\xe6\
    \x01\n#QueryDelegationTotalRewardsResponse\x12V\n\x07rewards\x18\x01\x20\
    \x03(\x0b26.cosmos.distribution.v1beta1.DelegationDelegatorRewardR\x07re\
    wardsB\x04\xc8\xde\x1f\0\x12g\n\x05total\x18\x02\x20\x03(\x0b2\x1c.cosmo\
    s.base.v1beta1.DecCoinR\x05totalB3\xaa\xdf\x1f+github.com/cosmos/cosmos-\
    sdk/types.DecCoins\xc8\xde\x1f\0\"X\n\x1fQueryDelegatorValidatorsRequest\
    \x12+\n\x11delegator_address\x18\x01\x20\x01(\tR\x10delegatorAddress:\
    \x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"L\n\x20QueryDelegatorValidatorsRespons\
    e\x12\x1e\n\nvalidators\x18\x01\x20\x03(\tR\nvalidators:\x08\x88\xa0\x1f\
    \0\xe8\xa0\x1f\0\"]\n$QueryDelegatorWithdrawAddressRequest\x12+\n\x11del\
    egator_address\x18\x01\x20\x01(\tR\x10delegatorAddress:\x08\x88\xa0\x1f\
    \0\xe8\xa0\x1f\0\"\\\n%QueryDelegatorWithdrawAddressResponse\x12)\n\x10w\
    ithdraw_address\x18\x01\x20\x01(\tR\x0fwithdrawAddress:\x08\x88\xa0\x1f\
    \0\xe8\xa0\x1f\0\"\x1b\n\x19QueryFoundationTaxRequest\"g\n\x1aQueryFound\
    ationTaxResponse\x12\x10\n\x03tax\x18\x01\x20\x01(\tR\x03tax\x12-\n\x12f\
    oundation_address\x18\x02\x20\x01(\tR\x11foundationAddress:\x08\x88\xa0\
    \x1f\0\xe8\xa0\x1f\0\"\x1b\n\x19QueryCommunityPoolRequest\"\x83\x01\n\
    \x1aQueryCommunityPoolResponse\x12e\n\x04pool\x18\x01\x20\x03(\x0b2\x1c.\
    cosmos.base.v1beta1.DecCoinR\x04poolB3\xaa\xdf\x1f+github.com/cosmos/cos\
    mos-sdk/types.DecCoins\xc8\xde\x1f\02\x90\x11\n\x05Query\x12\x98\x01\n\
    \x06Params\x12/.cosmos.distribution.v1beta1.QueryParamsRequest\x1a0.cosm\
    os.distribution.v1beta1.QueryParamsResponse\"+\x82\xd3\xe4\x93\x02%\x12#\
    /cosmos/distribution/v1beta1/params\x12\x83\x02\n\x1bValidatorOutstandin\
    gRewards\x12D.cosmos.distribution.v1beta1.QueryValidatorOutstandingRewar\
    dsRequest\x1aE.cosmos.distribution.v1beta1.QueryValidatorOutstandingRewa\
    rdsResponse\"W\x82\xd3\xe4\x93\x02Q\x12O/cosmos/distribution/v1beta1/val\
    idators/{validator_address}/outstanding_rewards\x12\xe2\x01\n\x13Validat\
    orCommission\x12<.cosmos.distribution.v1beta1.QueryValidatorCommissionRe\
    quest\x1a=.cosmos.distribution.v1beta1.QueryValidatorCommissionResponse\
    \"N\x82\xd3\xe4\x93\x02H\x12F/cosmos/distribution/v1beta1/validators/{va\
    lidator_address}/commission\x12\xd6\x01\n\x10ValidatorSlashes\x129.cosmo\
    s.distribution.v1beta1.QueryValidatorSlashesRequest\x1a:.cosmos.distribu\
    tion.v1beta1.QueryValidatorSlashesResponse\"K\x82\xd3\xe4\x93\x02E\x12C/\
    cosmos/distribution/v1beta1/validators/{validator_address}/slashes\x12\
    \xed\x01\n\x11DelegationRewards\x12:.cosmos.distribution.v1beta1.QueryDe\
    legationRewardsRequest\x1a;.cosmos.distribution.v1beta1.QueryDelegationR\
    ewardsResponse\"_\x82\xd3\xe4\x93\x02Y\x12W/cosmos/distribution/v1beta1/\
    delegators/{delegator_address}/rewards/{validator_address}\x12\xe8\x01\n\
    \x16DelegationTotalRewards\x12?.cosmos.distribution.v1beta1.QueryDelegat\
    ionTotalRewardsRequest\x1a@.cosmos.distribution.v1beta1.QueryDelegationT\
    otalRewardsResponse\"K\x82\xd3\xe4\x93\x02E\x12C/cosmos/distribution/v1b\
    eta1/delegators/{delegator_address}/rewards\x12\xe2\x01\n\x13DelegatorVa\
    lidators\x12<.cosmos.distribution.v1beta1.QueryDelegatorValidatorsReques\
    t\x1a=.cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse\"N\
    \x82\xd3\xe4\x93\x02H\x12F/cosmos/distribution/v1beta1/delegators/{deleg\
    ator_address}/validators\x12\xf7\x01\n\x18DelegatorWithdrawAddress\x12A.\
    cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest\x1aB.co\
    smos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse\"T\x82\
    \xd3\xe4\x93\x02N\x12L/cosmos/distribution/v1beta1/delegators/{delegator\
    _address}/withdraw_address\x12\xb5\x01\n\rCommunityPool\x126.cosmos.dist\
    ribution.v1beta1.QueryCommunityPoolRequest\x1a7.cosmos.distribution.v1be\
    ta1.QueryCommunityPoolResponse\"3\x82\xd3\xe4\x93\x02-\x12+/cosmos/distr\
    ibution/v1beta1/community_pool\x12\xb5\x01\n\rFoundationTax\x126.cosmos.\
    distribution.v1beta1.QueryFoundationTaxRequest\x1a7.cosmos.distribution.\
    v1beta1.QueryFoundationTaxResponse\"3\x82\xd3\xe4\x93\x02-\x12+/cosmos/d\
    istribution/v1beta1/foundation_taxB3Z1github.com/cosmos/cosmos-sdk/x/dis\
    tribution/typesJ\xc6=\n\x07\x12\x05\0\0\xed\x01\x01\n\x08\n\x01\x0c\x12\
    \x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0$\n\t\n\x02\x03\0\x12\x03\x03\
    \04\n\t\n\x02\x03\x01\x12\x03\x04\0\x1e\n\t\n\x02\x03\x02\x12\x03\x05\0&\
    \n\t\n\x02\x03\x03\x12\x03\x06\0(\n\t\n\x02\x03\x04\x12\x03\x07\08\n\x08\
    \n\x01\x08\x12\x03\t\0H\n\t\n\x02\x08\x0b\x12\x03\t\0H\nM\n\x02\x06\0\
    \x12\x04\x0c\0E\x01\x1aA\x20Query\x20defines\x20the\x20gRPC\x20querier\
    \x20service\x20for\x20distribution\x20module.\n\n\n\n\x03\x06\0\x01\x12\
    \x03\x0c\x08\r\nA\n\x04\x06\0\x02\0\x12\x04\x0e\x02\x10\x03\x1a3\x20Para\
    ms\x20queries\x20params\x20of\x20the\x20distribution\x20module.\n\n\x0c\
    \n\x05\x06\0\x02\0\x01\x12\x03\x0e\x06\x0c\n\x0c\n\x05\x06\0\x02\0\x02\
    \x12\x03\x0e\r\x1f\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x0e*=\n\x0c\n\x05\
    \x06\0\x02\0\x04\x12\x03\x0f\x04I\n\x11\n\n\x06\0\x02\0\x04\xb0\xca\xbc\
    \"\x02\x12\x03\x0f\x04I\nS\n\x04\x06\0\x02\x01\x12\x04\x13\x02\x17\x03\
    \x1aE\x20ValidatorOutstandingRewards\x20queries\x20rewards\x20of\x20a\
    \x20validator\x20address.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x13\
    \x06!\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x13\"I\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03\x14\x0f7\n\r\n\x05\x06\0\x02\x01\x04\x12\x04\x15\x04\
    \x16M\n\x12\n\n\x06\0\x02\x01\x04\xb0\xca\xbc\"\x02\x12\x04\x15\x04\x16M\
    \nS\n\x04\x06\0\x02\x02\x12\x04\x1a\x02\x1d\x03\x1aE\x20ValidatorCommiss\
    ion\x20queries\x20accumulated\x20commission\x20for\x20a\x20validator.\n\
    \n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x1a\x06\x19\n\x0c\n\x05\x06\0\x02\
    \x02\x02\x12\x03\x1a\x1a9\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1aDd\n\
    \r\n\x05\x06\0\x02\x02\x04\x12\x04\x1b\x04\x1cD\n\x12\n\n\x06\0\x02\x02\
    \x04\xb0\xca\xbc\"\x02\x12\x04\x1b\x04\x1cD\nE\n\x04\x06\0\x02\x03\x12\
    \x04\x20\x02\"\x03\x1a7\x20ValidatorSlashes\x20queries\x20slash\x20event\
    s\x20of\x20a\x20validator.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x20\
    \x06\x16\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\x20\x173\n\x0c\n\x05\x06\
    \0\x02\x03\x03\x12\x03\x20>[\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03!\x04i\
    \n\x11\n\n\x06\0\x02\x03\x04\xb0\xca\xbc\"\x02\x12\x03!\x04i\nT\n\x04\
    \x06\0\x02\x04\x12\x04%\x02(\x03\x1aF\x20DelegationRewards\x20queries\
    \x20the\x20total\x20rewards\x20accrued\x20by\x20a\x20delegation.\n\n\x0c\
    \n\x05\x06\0\x02\x04\x01\x12\x03%\x06\x17\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03%\x185\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03%@^\n\r\n\x05\x06\0\
    \x02\x04\x04\x12\x04&\x04'9\n\x12\n\n\x06\0\x02\x04\x04\xb0\xca\xbc\"\
    \x02\x12\x04&\x04'9\n^\n\x04\x06\0\x02\x05\x12\x04,\x02.\x03\x1aP\x20Del\
    egationTotalRewards\x20queries\x20the\x20total\x20rewards\x20accrued\x20\
    by\x20a\x20each\n\x20validator.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03,\
    \x06\x1c\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03,\x1d?\n\x0c\n\x05\x06\0\
    \x02\x05\x03\x12\x03,Jm\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03-\x04i\n\
    \x11\n\n\x06\0\x02\x05\x04\xb0\xca\xbc\"\x02\x12\x03-\x04i\nJ\n\x04\x06\
    \0\x02\x06\x12\x041\x024\x03\x1a<\x20DelegatorValidators\x20queries\x20t\
    he\x20validators\x20of\x20a\x20delegator.\n\n\x0c\n\x05\x06\0\x02\x06\
    \x01\x12\x031\x06\x19\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x031\x1a9\n\x0c\
    \n\x05\x06\0\x02\x06\x03\x12\x031Dd\n\r\n\x05\x06\0\x02\x06\x04\x12\x042\
    \x043D\n\x12\n\n\x06\0\x02\x06\x04\xb0\xca\xbc\"\x02\x12\x042\x043D\nQ\n\
    \x04\x06\0\x02\x07\x12\x047\x02:\x03\x1aC\x20DelegatorWithdrawAddress\
    \x20queries\x20withdraw\x20address\x20of\x20a\x20delegator.\n\n\x0c\n\
    \x05\x06\0\x02\x07\x01\x12\x037\x06\x1e\n\x0c\n\x05\x06\0\x02\x07\x02\
    \x12\x037\x1fC\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x037Ns\n\r\n\x05\x06\0\
    \x02\x07\x04\x12\x048\x049J\n\x12\n\n\x06\0\x02\x07\x04\xb0\xca\xbc\"\
    \x02\x12\x048\x049J\n?\n\x04\x06\0\x02\x08\x12\x04=\x02?\x03\x1a1\x20Com\
    munityPool\x20queries\x20the\x20community\x20pool\x20coins.\n\n\x0c\n\
    \x05\x06\0\x02\x08\x01\x12\x03=\x06\x13\n\x0c\n\x05\x06\0\x02\x08\x02\
    \x12\x03=\x14-\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03=8R\n\x0c\n\x05\x06\
    \0\x02\x08\x04\x12\x03>\x04Q\n\x11\n\n\x06\0\x02\x08\x04\xb0\xca\xbc\"\
    \x02\x12\x03>\x04Q\nQ\n\x04\x06\0\x02\t\x12\x04B\x02D\x03\x1aC\x20Delega\
    torWithdrawAddress\x20queries\x20withdraw\x20address\x20of\x20a\x20deleg\
    ator.\n\n\x0c\n\x05\x06\0\x02\t\x01\x12\x03B\x06\x13\n\x0c\n\x05\x06\0\
    \x02\t\x02\x12\x03B\x14-\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03B8R\n\x0c\n\
    \x05\x06\0\x02\t\x04\x12\x03C\x04Q\n\x11\n\n\x06\0\x02\t\x04\xb0\xca\xbc\
    \"\x02\x12\x03C\x04Q\nT\n\x02\x04\0\x12\x03H\0\x1d\x1aI\x20QueryParamsRe\
    quest\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/Params\x20R\
    PC\x20method.\n\n\n\n\x03\x04\0\x01\x12\x03H\x08\x1a\nW\n\x02\x04\x01\
    \x12\x04K\0N\x01\x1aK\x20QueryParamsResponse\x20is\x20the\x20response\
    \x20type\x20for\x20the\x20Query/Params\x20RPC\x20method.\n\n\n\n\x03\x04\
    \x01\x01\x12\x03K\x08\x1b\n;\n\x04\x04\x01\x02\0\x12\x03M\x023\x1a.\x20p\
    arams\x20defines\x20the\x20parameters\x20of\x20the\x20module.\n\n\x0c\n\
    \x05\x04\x01\x02\0\x06\x12\x03M\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03M\t\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03M\x12\x13\n\x0c\n\
    \x05\x04\x01\x02\0\x08\x12\x03M\x142\n\x0f\n\x08\x04\x01\x02\0\x08\xe9\
    \xfb\x03\x12\x03M\x151\n\x80\x01\n\x02\x04\x02\x12\x04R\0U\x01\x1at\x20Q\
    ueryValidatorOutstandingRewardsRequest\x20is\x20the\x20request\x20type\
    \x20for\x20the\n\x20Query/ValidatorOutstandingRewards\x20RPC\x20method.\
    \n\n\n\n\x03\x04\x02\x01\x12\x03R\x08/\nL\n\x04\x04\x02\x02\0\x12\x03T\
    \x02\x1f\x1a?\x20validator_address\x20defines\x20the\x20validator\x20add\
    ress\x20to\x20query\x20for.\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03T\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03T\t\x1a\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03T\x1d\x1e\n\x82\x01\n\x02\x04\x03\x12\x04Y\0[\x01\x1av\
    \x20QueryValidatorOutstandingRewardsResponse\x20is\x20the\x20response\
    \x20type\x20for\x20the\n\x20Query/ValidatorOutstandingRewards\x20RPC\x20\
    method.\n\n\n\n\x03\x04\x03\x01\x12\x03Y\x080\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x03Z\x02I\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03Z\x02\x1d\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x03Z\x1e%\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x03Z()\n\x0c\n\x05\x04\x03\x02\0\x08\x12\x03Z*H\n\x0f\n\x08\x04\x03\x02\
    \0\x08\xe9\xfb\x03\x12\x03Z+G\no\n\x02\x04\x04\x12\x04_\0b\x01\x1ac\x20Q\
    ueryValidatorCommissionRequest\x20is\x20the\x20request\x20type\x20for\
    \x20the\n\x20Query/ValidatorCommission\x20RPC\x20method\n\n\n\n\x03\x04\
    \x04\x01\x12\x03_\x08'\nL\n\x04\x04\x04\x02\0\x12\x03a\x02\x1f\x1a?\x20v\
    alidator_address\x20defines\x20the\x20validator\x20address\x20to\x20quer\
    y\x20for.\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03a\x02\x08\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03a\t\x1a\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03a\
    \x1d\x1e\nq\n\x02\x04\x05\x12\x04f\0i\x01\x1ae\x20QueryValidatorCommissi\
    onResponse\x20is\x20the\x20response\x20type\x20for\x20the\n\x20Query/Val\
    idatorCommission\x20RPC\x20method\n\n\n\n\x03\x04\x05\x01\x12\x03f\x08(\
    \nG\n\x04\x04\x05\x02\0\x12\x03h\x02O\x1a:\x20commission\x20defines\x20t\
    he\x20commision\x20the\x20validator\x20received.\n\n\x0c\n\x05\x04\x05\
    \x02\0\x06\x12\x03h\x02\x20\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03h!+\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03h./\n\x0c\n\x05\x04\x05\x02\0\x08\
    \x12\x03h0N\n\x0f\n\x08\x04\x05\x02\0\x08\xe9\xfb\x03\x12\x03h1M\ni\n\
    \x02\x04\x06\x12\x04m\0y\x01\x1a]\x20QueryValidatorSlashesRequest\x20is\
    \x20the\x20request\x20type\x20for\x20the\n\x20Query/ValidatorSlashes\x20\
    RPC\x20method\n\n\n\n\x03\x04\x06\x01\x12\x03m\x08$\n\n\n\x03\x04\x06\
    \x07\x12\x03n\x02.\n\r\n\x06\x04\x06\x07\x81\xf4\x03\x12\x03n\x02.\n\n\n\
    \x03\x04\x06\x07\x12\x03o\x02-\n\r\n\x06\x04\x06\x07\x83\xf4\x03\x12\x03\
    o\x02-\nL\n\x04\x04\x06\x02\0\x12\x03r\x02\x1f\x1a?\x20validator_address\
    \x20defines\x20the\x20validator\x20address\x20to\x20query\x20for.\n\n\
    \x0c\n\x05\x04\x06\x02\0\x05\x12\x03r\x02\x08\n\x0c\n\x05\x04\x06\x02\0\
    \x01\x12\x03r\t\x1a\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03r\x1d\x1e\nY\n\
    \x04\x04\x06\x02\x01\x12\x03t\x02\x1d\x1aL\x20starting_height\x20defines\
    \x20the\x20optional\x20starting\x20height\x20to\x20query\x20the\x20slash\
    es.\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03t\t\x18\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03t\
    \x1b\x1c\nW\n\x04\x04\x06\x02\x02\x12\x03v\x02\x1b\x1aJ\x20starting_heig\
    ht\x20defines\x20the\x20optional\x20ending\x20height\x20to\x20query\x20t\
    he\x20slashes.\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03v\x02\x08\n\x0c\
    \n\x05\x04\x06\x02\x02\x01\x12\x03v\t\x16\n\x0c\n\x05\x04\x06\x02\x02\
    \x03\x12\x03v\x19\x1a\nI\n\x04\x04\x06\x02\x03\x12\x03x\x027\x1a<\x20pag\
    ination\x20defines\x20an\x20optional\x20pagination\x20for\x20the\x20requ\
    est.\n\n\x0c\n\x05\x04\x06\x02\x03\x06\x12\x03x\x02'\n\x0c\n\x05\x04\x06\
    \x02\x03\x01\x12\x03x(2\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03x56\nm\n\
    \x02\x04\x07\x12\x05}\0\x83\x01\x01\x1a`\x20QueryValidatorSlashesRespons\
    e\x20is\x20the\x20response\x20type\x20for\x20the\n\x20Query/ValidatorSla\
    shes\x20RPC\x20method.\n\n\n\n\x03\x04\x07\x01\x12\x03}\x08%\nB\n\x04\
    \x04\x07\x02\0\x12\x03\x7f\x02J\x1a5\x20slashes\x20defines\x20the\x20sla\
    shes\x20the\x20validator\x20received.\n\n\x0c\n\x05\x04\x07\x02\0\x04\
    \x12\x03\x7f\x02\n\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03\x7f\x0b\x1e\n\
    \x0c\n\x05\x04\x07\x02\0\x01\x12\x03\x7f\x1f&\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03\x7f)*\n\x0c\n\x05\x04\x07\x02\0\x08\x12\x03\x7f+I\n\x0f\n\
    \x08\x04\x07\x02\0\x08\xe9\xfb\x03\x12\x03\x7f,H\nB\n\x04\x04\x07\x02\
    \x01\x12\x04\x82\x01\x028\x1a4\x20pagination\x20defines\x20the\x20pagina\
    tion\x20in\x20the\x20response.\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\
    \x82\x01\x02(\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x82\x01)3\n\r\n\x05\
    \x04\x07\x02\x01\x03\x12\x04\x82\x0167\nn\n\x02\x04\x08\x12\x06\x87\x01\
    \0\x8f\x01\x01\x1a`\x20QueryDelegationRewardsRequest\x20is\x20the\x20req\
    uest\x20type\x20for\x20the\n\x20Query/DelegationRewards\x20RPC\x20method\
    .\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x87\x01\x08%\n\x0b\n\x03\x04\x08\x07\
    \x12\x04\x88\x01\x02-\n\x0e\n\x06\x04\x08\x07\x8d\xf4\x03\x12\x04\x88\
    \x01\x02-\n\x0b\n\x03\x04\x08\x07\x12\x04\x89\x01\x02-\n\x0e\n\x06\x04\
    \x08\x07\x81\xf4\x03\x12\x04\x89\x01\x02-\nM\n\x04\x04\x08\x02\0\x12\x04\
    \x8c\x01\x02\x1f\x1a?\x20delegator_address\x20defines\x20the\x20delegato\
    r\x20address\x20to\x20query\x20for.\n\n\r\n\x05\x04\x08\x02\0\x05\x12\
    \x04\x8c\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x8c\x01\t\x1a\n\
    \r\n\x05\x04\x08\x02\0\x03\x12\x04\x8c\x01\x1d\x1e\nM\n\x04\x04\x08\x02\
    \x01\x12\x04\x8e\x01\x02\x1f\x1a?\x20validator_address\x20defines\x20the\
    \x20validator\x20address\x20to\x20query\x20for.\n\n\r\n\x05\x04\x08\x02\
    \x01\x05\x12\x04\x8e\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\
    \x8e\x01\t\x1a\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x8e\x01\x1d\x1e\np\
    \n\x02\x04\t\x12\x06\x93\x01\0\x97\x01\x01\x1ab\x20QueryDelegationReward\
    sResponse\x20is\x20the\x20response\x20type\x20for\x20the\n\x20Query/Dele\
    gationRewards\x20RPC\x20method.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x93\x01\
    \x08&\nF\n\x04\x04\t\x02\0\x12\x06\x95\x01\x02\x96\x01o\x1a6\x20rewards\
    \x20defines\x20the\x20rewards\x20accrued\x20by\x20a\x20delegation.\n\n\r\
    \n\x05\x04\t\x02\0\x04\x12\x04\x95\x01\x02\n\n\r\n\x05\x04\t\x02\0\x06\
    \x12\x04\x95\x01\x0b&\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x95\x01'.\n\r\n\
    \x05\x04\t\x02\0\x03\x12\x04\x95\x0112\n\r\n\x05\x04\t\x02\0\x08\x12\x04\
    \x96\x01\x06n\n\x10\n\x08\x04\t\x02\0\x08\xe9\xfb\x03\x12\x04\x96\x01\
    \x07#\n\x10\n\x08\x04\t\x02\0\x08\xf5\xfb\x03\x12\x04\x96\x01%m\nx\n\x02\
    \x04\n\x12\x06\x9b\x01\0\xa0\x01\x01\x1aj\x20QueryDelegationTotalRewards\
    Request\x20is\x20the\x20request\x20type\x20for\x20the\n\x20Query/Delegat\
    ionTotalRewards\x20RPC\x20method.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x9b\
    \x01\x08*\n\x0b\n\x03\x04\n\x07\x12\x04\x9c\x01\x02-\n\x0e\n\x06\x04\n\
    \x07\x8d\xf4\x03\x12\x04\x9c\x01\x02-\n\x0b\n\x03\x04\n\x07\x12\x04\x9d\
    \x01\x02-\n\x0e\n\x06\x04\n\x07\x81\xf4\x03\x12\x04\x9d\x01\x02-\nM\n\
    \x04\x04\n\x02\0\x12\x04\x9f\x01\x02\x1f\x1a?\x20delegator_address\x20de\
    fines\x20the\x20delegator\x20address\x20to\x20query\x20for.\n\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\x9f\x01\t\x1a\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x9f\x01\x1d\x1e\nz\
    \n\x02\x04\x0b\x12\x06\xa4\x01\0\xaa\x01\x01\x1al\x20QueryDelegationTota\
    lRewardsResponse\x20is\x20the\x20response\x20type\x20for\x20the\n\x20Que\
    ry/DelegationTotalRewards\x20RPC\x20method.\n\n\x0b\n\x03\x04\x0b\x01\
    \x12\x04\xa4\x01\x08+\nG\n\x04\x04\x0b\x02\0\x12\x04\xa6\x01\x02P\x1a9\
    \x20rewards\x20defines\x20all\x20the\x20rewards\x20accrued\x20by\x20a\
    \x20delegator.\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xa6\x01\x02\n\n\r\n\
    \x05\x04\x0b\x02\0\x06\x12\x04\xa6\x01\x0b$\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\xa6\x01%,\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xa6\x01/0\n\r\n\
    \x05\x04\x0b\x02\0\x08\x12\x04\xa6\x011O\n\x10\n\x08\x04\x0b\x02\0\x08\
    \xe9\xfb\x03\x12\x04\xa6\x012N\n;\n\x04\x04\x0b\x02\x01\x12\x06\xa8\x01\
    \x02\xa9\x01o\x1a+\x20total\x20defines\x20the\x20sum\x20of\x20all\x20the\
    \x20rewards.\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xa8\x01\x02\n\n\r\n\
    \x05\x04\x0b\x02\x01\x06\x12\x04\xa8\x01\x0b&\n\r\n\x05\x04\x0b\x02\x01\
    \x01\x12\x04\xa8\x01',\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xa8\x01/0\n\
    \r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xa9\x01\x06n\n\x10\n\x08\x04\x0b\
    \x02\x01\x08\xe9\xfb\x03\x12\x04\xa9\x01\x07#\n\x10\n\x08\x04\x0b\x02\
    \x01\x08\xf5\xfb\x03\x12\x04\xa9\x01%m\nr\n\x02\x04\x0c\x12\x06\xae\x01\
    \0\xb4\x01\x01\x1ad\x20QueryDelegatorValidatorsRequest\x20is\x20the\x20r\
    equest\x20type\x20for\x20the\n\x20Query/DelegatorValidators\x20RPC\x20me\
    thod.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xae\x01\x08'\n\x0b\n\x03\x04\x0c\
    \x07\x12\x04\xaf\x01\x02-\n\x0e\n\x06\x04\x0c\x07\x8d\xf4\x03\x12\x04\
    \xaf\x01\x02-\n\x0b\n\x03\x04\x0c\x07\x12\x04\xb0\x01\x02-\n\x0e\n\x06\
    \x04\x0c\x07\x81\xf4\x03\x12\x04\xb0\x01\x02-\nM\n\x04\x04\x0c\x02\0\x12\
    \x04\xb3\x01\x02\x1f\x1a?\x20delegator_address\x20defines\x20the\x20dele\
    gator\x20address\x20to\x20query\x20for.\n\n\r\n\x05\x04\x0c\x02\0\x05\
    \x12\x04\xb3\x01\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xb3\x01\t\
    \x1a\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xb3\x01\x1d\x1e\nt\n\x02\x04\r\
    \x12\x06\xb8\x01\0\xbe\x01\x01\x1af\x20QueryDelegatorValidatorsResponse\
    \x20is\x20the\x20response\x20type\x20for\x20the\n\x20Query/DelegatorVali\
    dators\x20RPC\x20method.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xb8\x01\x08(\n\
    \x0b\n\x03\x04\r\x07\x12\x04\xb9\x01\x02-\n\x0e\n\x06\x04\r\x07\x8d\xf4\
    \x03\x12\x04\xb9\x01\x02-\n\x0b\n\x03\x04\r\x07\x12\x04\xba\x01\x02-\n\
    \x0e\n\x06\x04\r\x07\x81\xf4\x03\x12\x04\xba\x01\x02-\nP\n\x04\x04\r\x02\
    \0\x12\x04\xbd\x01\x02!\x1aB\x20validators\x20defines\x20the\x20validato\
    rs\x20a\x20delegator\x20is\x20delegating\x20for.\n\n\r\n\x05\x04\r\x02\0\
    \x04\x12\x04\xbd\x01\x02\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xbd\x01\x0b\
    \x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xbd\x01\x12\x1c\n\r\n\x05\x04\r\
    \x02\0\x03\x12\x04\xbd\x01\x1f\x20\n|\n\x02\x04\x0e\x12\x06\xc2\x01\0\
    \xc8\x01\x01\x1an\x20QueryDelegatorWithdrawAddressRequest\x20is\x20the\
    \x20request\x20type\x20for\x20the\n\x20Query/DelegatorWithdrawAddress\
    \x20RPC\x20method.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc2\x01\x08,\n\x0b\
    \n\x03\x04\x0e\x07\x12\x04\xc3\x01\x02-\n\x0e\n\x06\x04\x0e\x07\x8d\xf4\
    \x03\x12\x04\xc3\x01\x02-\n\x0b\n\x03\x04\x0e\x07\x12\x04\xc4\x01\x02-\n\
    \x0e\n\x06\x04\x0e\x07\x81\xf4\x03\x12\x04\xc4\x01\x02-\nM\n\x04\x04\x0e\
    \x02\0\x12\x04\xc7\x01\x02\x1f\x1a?\x20delegator_address\x20defines\x20t\
    he\x20delegator\x20address\x20to\x20query\x20for.\n\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\xc7\x01\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xc7\x01\t\x1a\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xc7\x01\x1d\x1e\n~\n\
    \x02\x04\x0f\x12\x06\xcc\x01\0\xd2\x01\x01\x1ap\x20QueryDelegatorWithdra\
    wAddressResponse\x20is\x20the\x20response\x20type\x20for\x20the\n\x20Que\
    ry/DelegatorWithdrawAddress\x20RPC\x20method.\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xcc\x01\x08-\n\x0b\n\x03\x04\x0f\x07\x12\x04\xcd\x01\x02-\n\x0e\
    \n\x06\x04\x0f\x07\x8d\xf4\x03\x12\x04\xcd\x01\x02-\n\x0b\n\x03\x04\x0f\
    \x07\x12\x04\xce\x01\x02-\n\x0e\n\x06\x04\x0f\x07\x81\xf4\x03\x12\x04\
    \xce\x01\x02-\nL\n\x04\x04\x0f\x02\0\x12\x04\xd1\x01\x02\x1e\x1a>\x20wit\
    hdraw_address\x20defines\x20the\x20delegator\x20address\x20to\x20query\
    \x20for.\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xd1\x01\x02\x08\n\r\n\x05\
    \x04\x0f\x02\0\x01\x12\x04\xd1\x01\t\x19\n\r\n\x05\x04\x0f\x02\0\x03\x12\
    \x04\xd1\x01\x1c\x1d\nd\n\x02\x04\x10\x12\x04\xd6\x01\0$\x1aX\x20QueryFo\
    undationTaxRequest\x20is\x20the\x20request\x20type\x20for\x20the\n\x20Qu\
    ery/FoundationTax\x20RPC\x20method.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \xd6\x01\x08!\n~\n\x02\x04\x11\x12\x06\xda\x01\0\xe1\x01\x01\x1ap\x20Que\
    ryDelegatorWithdrawAddressResponse\x20is\x20the\x20response\x20type\x20f\
    or\x20the\n\x20Query/DelegatorWithdrawAddress\x20RPC\x20method.\n\n\x0b\
    \n\x03\x04\x11\x01\x12\x04\xda\x01\x08\"\n\x0b\n\x03\x04\x11\x07\x12\x04\
    \xdb\x01\x02-\n\x0e\n\x06\x04\x11\x07\x8d\xf4\x03\x12\x04\xdb\x01\x02-\n\
    \x0b\n\x03\x04\x11\x07\x12\x04\xdc\x01\x02-\n\x0e\n\x06\x04\x11\x07\x81\
    \xf4\x03\x12\x04\xdc\x01\x02-\nL\n\x04\x04\x11\x02\0\x12\x04\xdf\x01\x02\
    \x11\x1a>\x20withdraw_address\x20defines\x20the\x20delegator\x20address\
    \x20to\x20query\x20for.\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xdf\x01\
    \x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xdf\x01\t\x0c\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xdf\x01\x0f\x10\n\x0c\n\x04\x04\x11\x02\x01\x12\
    \x04\xe0\x01\x02\x20\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xe0\x01\x02\
    \x08\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe0\x01\t\x1b\n\r\n\x05\x04\
    \x11\x02\x01\x03\x12\x04\xe0\x01\x1e\x1f\nd\n\x02\x04\x12\x12\x04\xe5\
    \x01\0$\x1aX\x20QueryCommunityPoolRequest\x20is\x20the\x20request\x20typ\
    e\x20for\x20the\x20Query/CommunityPool\x20RPC\n\x20method.\n\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\xe5\x01\x08!\nh\n\x02\x04\x13\x12\x06\xe9\x01\0\xed\
    \x01\x01\x1aZ\x20QueryCommunityPoolResponse\x20is\x20the\x20response\x20\
    type\x20for\x20the\x20Query/CommunityPool\n\x20RPC\x20method.\n\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xe9\x01\x08\"\n6\n\x04\x04\x13\x02\0\x12\x06\
    \xeb\x01\x02\xec\x01o\x1a&\x20pool\x20defines\x20community\x20pool's\x20\
    coins.\n\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xeb\x01\x02\n\n\r\n\x05\x04\
    \x13\x02\0\x06\x12\x04\xeb\x01\x0b&\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \xeb\x01'+\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xeb\x01./\n\r\n\x05\x04\
    \x13\x02\0\x08\x12\x04\xec\x01\x06n\n\x10\n\x08\x04\x13\x02\0\x08\xf5\
    \xfb\x03\x12\x04\xec\x01\x07O\n\x10\n\x08\x04\x13\x02\0\x08\xe9\xfb\x03\
    \x12\x04\xec\x01Qmb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::pagination::file_descriptor().clone());
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::coin::file_descriptor().clone());
            deps.push(super::distribution::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(20);
            messages.push(QueryParamsRequest::generated_message_descriptor_data());
            messages.push(QueryParamsResponse::generated_message_descriptor_data());
            messages.push(QueryValidatorOutstandingRewardsRequest::generated_message_descriptor_data());
            messages.push(QueryValidatorOutstandingRewardsResponse::generated_message_descriptor_data());
            messages.push(QueryValidatorCommissionRequest::generated_message_descriptor_data());
            messages.push(QueryValidatorCommissionResponse::generated_message_descriptor_data());
            messages.push(QueryValidatorSlashesRequest::generated_message_descriptor_data());
            messages.push(QueryValidatorSlashesResponse::generated_message_descriptor_data());
            messages.push(QueryDelegationRewardsRequest::generated_message_descriptor_data());
            messages.push(QueryDelegationRewardsResponse::generated_message_descriptor_data());
            messages.push(QueryDelegationTotalRewardsRequest::generated_message_descriptor_data());
            messages.push(QueryDelegationTotalRewardsResponse::generated_message_descriptor_data());
            messages.push(QueryDelegatorValidatorsRequest::generated_message_descriptor_data());
            messages.push(QueryDelegatorValidatorsResponse::generated_message_descriptor_data());
            messages.push(QueryDelegatorWithdrawAddressRequest::generated_message_descriptor_data());
            messages.push(QueryDelegatorWithdrawAddressResponse::generated_message_descriptor_data());
            messages.push(QueryFoundationTaxRequest::generated_message_descriptor_data());
            messages.push(QueryFoundationTaxResponse::generated_message_descriptor_data());
            messages.push(QueryCommunityPoolRequest::generated_message_descriptor_data());
            messages.push(QueryCommunityPoolResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
