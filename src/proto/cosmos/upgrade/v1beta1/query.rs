// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos/upgrade/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  QueryCurrentPlanRequest is the request type for the Query/CurrentPlan RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryCurrentPlanRequest)
pub struct QueryCurrentPlanRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryCurrentPlanRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryCurrentPlanRequest {
    fn default() -> &'a QueryCurrentPlanRequest {
        <QueryCurrentPlanRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryCurrentPlanRequest {
    pub fn new() -> QueryCurrentPlanRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryCurrentPlanRequest>(
            "QueryCurrentPlanRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryCurrentPlanRequest {
    const NAME: &'static str = "QueryCurrentPlanRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryCurrentPlanRequest {
        QueryCurrentPlanRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryCurrentPlanRequest {
        static instance: QueryCurrentPlanRequest = QueryCurrentPlanRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryCurrentPlanRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryCurrentPlanRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryCurrentPlanRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCurrentPlanRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryCurrentPlanResponse)
pub struct QueryCurrentPlanResponse {
    // message fields
    ///  plan is the current upgrade plan.
    // @@protoc_insertion_point(field:cosmos.upgrade.v1beta1.QueryCurrentPlanResponse.plan)
    pub plan: ::protobuf::MessageField<super::upgrade::Plan>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryCurrentPlanResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryCurrentPlanResponse {
    fn default() -> &'a QueryCurrentPlanResponse {
        <QueryCurrentPlanResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryCurrentPlanResponse {
    pub fn new() -> QueryCurrentPlanResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::upgrade::Plan>(
            "plan",
            |m: &QueryCurrentPlanResponse| { &m.plan },
            |m: &mut QueryCurrentPlanResponse| { &mut m.plan },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryCurrentPlanResponse>(
            "QueryCurrentPlanResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryCurrentPlanResponse {
    const NAME: &'static str = "QueryCurrentPlanResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.plan)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.plan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.plan.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryCurrentPlanResponse {
        QueryCurrentPlanResponse::new()
    }

    fn clear(&mut self) {
        self.plan.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryCurrentPlanResponse {
        static instance: QueryCurrentPlanResponse = QueryCurrentPlanResponse {
            plan: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryCurrentPlanResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryCurrentPlanResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryCurrentPlanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCurrentPlanResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryCurrentPlanRequest is the request type for the Query/AppliedPlan RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryAppliedPlanRequest)
pub struct QueryAppliedPlanRequest {
    // message fields
    ///  name is the name of the applied plan to query for.
    // @@protoc_insertion_point(field:cosmos.upgrade.v1beta1.QueryAppliedPlanRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryAppliedPlanRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryAppliedPlanRequest {
    fn default() -> &'a QueryAppliedPlanRequest {
        <QueryAppliedPlanRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAppliedPlanRequest {
    pub fn new() -> QueryAppliedPlanRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &QueryAppliedPlanRequest| { &m.name },
            |m: &mut QueryAppliedPlanRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryAppliedPlanRequest>(
            "QueryAppliedPlanRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryAppliedPlanRequest {
    const NAME: &'static str = "QueryAppliedPlanRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryAppliedPlanRequest {
        QueryAppliedPlanRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryAppliedPlanRequest {
        static instance: QueryAppliedPlanRequest = QueryAppliedPlanRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryAppliedPlanRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryAppliedPlanRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryAppliedPlanRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAppliedPlanRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC
///  method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryAppliedPlanResponse)
pub struct QueryAppliedPlanResponse {
    // message fields
    ///  height is the block height at which the plan was applied.
    // @@protoc_insertion_point(field:cosmos.upgrade.v1beta1.QueryAppliedPlanResponse.height)
    pub height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryAppliedPlanResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryAppliedPlanResponse {
    fn default() -> &'a QueryAppliedPlanResponse {
        <QueryAppliedPlanResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAppliedPlanResponse {
    pub fn new() -> QueryAppliedPlanResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &QueryAppliedPlanResponse| { &m.height },
            |m: &mut QueryAppliedPlanResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryAppliedPlanResponse>(
            "QueryAppliedPlanResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryAppliedPlanResponse {
    const NAME: &'static str = "QueryAppliedPlanResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryAppliedPlanResponse {
        QueryAppliedPlanResponse::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryAppliedPlanResponse {
        static instance: QueryAppliedPlanResponse = QueryAppliedPlanResponse {
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryAppliedPlanResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryAppliedPlanResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryAppliedPlanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAppliedPlanResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUpgradedConsensusStateRequest is the request type for the Query/UpgradedConsensusState
///  RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateRequest)
pub struct QueryUpgradedConsensusStateRequest {
    // message fields
    ///  last height of the current chain must be sent in request
    ///  as this is the height under which next consensus state is stored
    // @@protoc_insertion_point(field:cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateRequest.last_height)
    pub last_height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUpgradedConsensusStateRequest {
    fn default() -> &'a QueryUpgradedConsensusStateRequest {
        <QueryUpgradedConsensusStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryUpgradedConsensusStateRequest {
    pub fn new() -> QueryUpgradedConsensusStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_height",
            |m: &QueryUpgradedConsensusStateRequest| { &m.last_height },
            |m: &mut QueryUpgradedConsensusStateRequest| { &mut m.last_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUpgradedConsensusStateRequest>(
            "QueryUpgradedConsensusStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUpgradedConsensusStateRequest {
    const NAME: &'static str = "QueryUpgradedConsensusStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.last_height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.last_height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.last_height != 0 {
            os.write_int64(1, self.last_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUpgradedConsensusStateRequest {
        QueryUpgradedConsensusStateRequest::new()
    }

    fn clear(&mut self) {
        self.last_height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUpgradedConsensusStateRequest {
        static instance: QueryUpgradedConsensusStateRequest = QueryUpgradedConsensusStateRequest {
            last_height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUpgradedConsensusStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUpgradedConsensusStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUpgradedConsensusStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUpgradedConsensusStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState
///  RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse)
pub struct QueryUpgradedConsensusStateResponse {
    // message fields
    ///  Since: cosmos-sdk 0.43
    // @@protoc_insertion_point(field:cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse.upgraded_consensus_state)
    pub upgraded_consensus_state: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUpgradedConsensusStateResponse {
    fn default() -> &'a QueryUpgradedConsensusStateResponse {
        <QueryUpgradedConsensusStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryUpgradedConsensusStateResponse {
    pub fn new() -> QueryUpgradedConsensusStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upgraded_consensus_state",
            |m: &QueryUpgradedConsensusStateResponse| { &m.upgraded_consensus_state },
            |m: &mut QueryUpgradedConsensusStateResponse| { &mut m.upgraded_consensus_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUpgradedConsensusStateResponse>(
            "QueryUpgradedConsensusStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUpgradedConsensusStateResponse {
    const NAME: &'static str = "QueryUpgradedConsensusStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.upgraded_consensus_state = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upgraded_consensus_state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.upgraded_consensus_state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upgraded_consensus_state.is_empty() {
            os.write_bytes(2, &self.upgraded_consensus_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUpgradedConsensusStateResponse {
        QueryUpgradedConsensusStateResponse::new()
    }

    fn clear(&mut self) {
        self.upgraded_consensus_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUpgradedConsensusStateResponse {
        static instance: QueryUpgradedConsensusStateResponse = QueryUpgradedConsensusStateResponse {
            upgraded_consensus_state: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUpgradedConsensusStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUpgradedConsensusStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUpgradedConsensusStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUpgradedConsensusStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryModuleVersionsRequest is the request type for the Query/ModuleVersions
///  RPC method.
///
///  Since: cosmos-sdk 0.43
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryModuleVersionsRequest)
pub struct QueryModuleVersionsRequest {
    // message fields
    ///  module_name is a field to query a specific module
    ///  consensus version from state. Leaving this empty will
    ///  fetch the full list of module versions from state
    // @@protoc_insertion_point(field:cosmos.upgrade.v1beta1.QueryModuleVersionsRequest.module_name)
    pub module_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryModuleVersionsRequest {
    fn default() -> &'a QueryModuleVersionsRequest {
        <QueryModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryModuleVersionsRequest {
    pub fn new() -> QueryModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_name",
            |m: &QueryModuleVersionsRequest| { &m.module_name },
            |m: &mut QueryModuleVersionsRequest| { &mut m.module_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryModuleVersionsRequest>(
            "QueryModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryModuleVersionsRequest {
    const NAME: &'static str = "QueryModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.module_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.module_name.is_empty() {
            os.write_string(1, &self.module_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryModuleVersionsRequest {
        QueryModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.module_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryModuleVersionsRequest {
        static instance: QueryModuleVersionsRequest = QueryModuleVersionsRequest {
            module_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryModuleVersionsResponse is the response type for the Query/ModuleVersions
///  RPC method.
///
///  Since: cosmos-sdk 0.43
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.upgrade.v1beta1.QueryModuleVersionsResponse)
pub struct QueryModuleVersionsResponse {
    // message fields
    ///  module_versions is a list of module names with their consensus versions.
    // @@protoc_insertion_point(field:cosmos.upgrade.v1beta1.QueryModuleVersionsResponse.module_versions)
    pub module_versions: ::std::vec::Vec<super::upgrade::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.upgrade.v1beta1.QueryModuleVersionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryModuleVersionsResponse {
    fn default() -> &'a QueryModuleVersionsResponse {
        <QueryModuleVersionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryModuleVersionsResponse {
    pub fn new() -> QueryModuleVersionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &QueryModuleVersionsResponse| { &m.module_versions },
            |m: &mut QueryModuleVersionsResponse| { &mut m.module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryModuleVersionsResponse>(
            "QueryModuleVersionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryModuleVersionsResponse {
    const NAME: &'static str = "QueryModuleVersionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryModuleVersionsResponse {
        QueryModuleVersionsResponse::new()
    }

    fn clear(&mut self) {
        self.module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryModuleVersionsResponse {
        static instance: QueryModuleVersionsResponse = QueryModuleVersionsResponse {
            module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryModuleVersionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryModuleVersionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryModuleVersionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryModuleVersionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"cosmos/upgrade/v1beta1/query.proto\x12\x16cosmos.upgrade.v1beta1\x1a\
    \x19google/protobuf/any.proto\x1a\x1cgoogle/api/annotations.proto\x1a$co\
    smos/upgrade/v1beta1/upgrade.proto\"\x19\n\x17QueryCurrentPlanRequest\"L\
    \n\x18QueryCurrentPlanResponse\x120\n\x04plan\x18\x01\x20\x01(\x0b2\x1c.\
    cosmos.upgrade.v1beta1.PlanR\x04plan\"-\n\x17QueryAppliedPlanRequest\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"2\n\x18QueryAppliedPlanRespo\
    nse\x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06height\"I\n\"QueryUpgra\
    dedConsensusStateRequest\x12\x1f\n\x0blast_height\x18\x01\x20\x01(\x03R\
    \nlastHeight:\x02\x18\x01\"i\n#QueryUpgradedConsensusStateResponse\x128\
    \n\x18upgraded_consensus_state\x18\x02\x20\x01(\x0cR\x16upgradedConsensu\
    sState:\x02\x18\x01J\x04\x08\x01\x10\x02\"=\n\x1aQueryModuleVersionsRequ\
    est\x12\x1f\n\x0bmodule_name\x18\x01\x20\x01(\tR\nmoduleName\"m\n\x1bQue\
    ryModuleVersionsResponse\x12N\n\x0fmodule_versions\x18\x01\x20\x03(\x0b2\
    %.cosmos.upgrade.v1beta1.ModuleVersionR\x0emoduleVersions2\xdc\x05\n\x05\
    Query\x12\x9e\x01\n\x0bCurrentPlan\x12/.cosmos.upgrade.v1beta1.QueryCurr\
    entPlanRequest\x1a0.cosmos.upgrade.v1beta1.QueryCurrentPlanResponse\",\
    \x82\xd3\xe4\x93\x02&\x12$/cosmos/upgrade/v1beta1/current_plan\x12\xa5\
    \x01\n\x0bAppliedPlan\x12/.cosmos.upgrade.v1beta1.QueryAppliedPlanReques\
    t\x1a0.cosmos.upgrade.v1beta1.QueryAppliedPlanResponse\"3\x82\xd3\xe4\
    \x93\x02-\x12+/cosmos/upgrade/v1beta1/applied_plan/{name}\x12\xdc\x01\n\
    \x16UpgradedConsensusState\x12:.cosmos.upgrade.v1beta1.QueryUpgradedCons\
    ensusStateRequest\x1a;.cosmos.upgrade.v1beta1.QueryUpgradedConsensusStat\
    eResponse\"I\x88\x02\x01\x82\xd3\xe4\x93\x02@\x12>/cosmos/upgrade/v1beta\
    1/upgraded_consensus_state/{last_height}\x12\xaa\x01\n\x0eModuleVersions\
    \x122.cosmos.upgrade.v1beta1.QueryModuleVersionsRequest\x1a3.cosmos.upgr\
    ade.v1beta1.QueryModuleVersionsResponse\"/\x82\xd3\xe4\x93\x02)\x12'/cos\
    mos/upgrade/v1beta1/module_versionsB.Z,github.com/cosmos/cosmos-sdk/x/up\
    grade/typesJ\x97\x19\n\x06\x12\x04\0\0g\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x01\0\x1f\n\t\n\x02\x03\0\x12\x03\x03\0#\n\
    \t\n\x02\x03\x01\x12\x03\x04\0&\n\t\n\x02\x03\x02\x12\x03\x05\0.\n\x08\n\
    \x01\x08\x12\x03\x07\0C\n\t\n\x02\x08\x0b\x12\x03\x07\0C\n=\n\x02\x06\0\
    \x12\x04\n\0&\x01\x1a1\x20Query\x20defines\x20the\x20gRPC\x20upgrade\x20\
    querier\x20service.\n\n\n\n\x03\x06\0\x01\x12\x03\n\x08\r\n=\n\x04\x06\0\
    \x02\0\x12\x04\x0c\x02\x0e\x03\x1a/\x20CurrentPlan\x20queries\x20the\x20\
    current\x20upgrade\x20plan.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x0c\
    \x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x0c\x12)\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x03\x0c4L\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03\r\x04J\n\
    \x11\n\n\x06\0\x02\0\x04\xb0\xca\xbc\"\x02\x12\x03\r\x04J\nR\n\x04\x06\0\
    \x02\x01\x12\x04\x11\x02\x13\x03\x1aD\x20AppliedPlan\x20queries\x20a\x20\
    previously\x20applied\x20upgrade\x20plan\x20by\x20its\x20name.\n\n\x0c\n\
    \x05\x06\0\x02\x01\x01\x12\x03\x11\x06\x11\n\x0c\n\x05\x06\0\x02\x01\x02\
    \x12\x03\x11\x12)\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x114L\n\x0c\n\
    \x05\x06\0\x02\x01\x04\x12\x03\x12\x04Q\n\x11\n\n\x06\0\x02\x01\x04\xb0\
    \xca\xbc\"\x02\x12\x03\x12\x04Q\n\xbc\x03\n\x04\x06\0\x02\x02\x12\x04\
    \x1b\x02\x1e\x03\x1a\xad\x03\x20UpgradedConsensusState\x20queries\x20the\
    \x20consensus\x20state\x20that\x20will\x20serve\n\x20as\x20a\x20trusted\
    \x20kernel\x20for\x20the\x20next\x20version\x20of\x20this\x20chain.\x20I\
    t\x20will\x20only\x20be\n\x20stored\x20at\x20the\x20last\x20height\x20of\
    \x20this\x20chain.\n\x20UpgradedConsensusState\x20RPC\x20not\x20supporte\
    d\x20with\x20legacy\x20querier\n\x20This\x20rpc\x20is\x20deprecated\x20n\
    ow\x20that\x20IBC\x20has\x20its\x20own\x20replacement\n\x20(https://gith\
    ub.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto\
    /ibc/core/client/v1/query.proto#L54)\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\
    \x03\x1b\x06\x1c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x1b\x1d?\n\x0c\n\
    \x05\x06\0\x02\x02\x03\x12\x03\x1bJm\n\x0c\n\x05\x06\0\x02\x02\x04\x12\
    \x03\x1c\x04(\n\r\n\x06\x06\0\x02\x02\x04!\x12\x03\x1c\x04(\n\x0c\n\x05\
    \x06\0\x02\x02\x04\x12\x03\x1d\x04d\n\x11\n\n\x06\0\x02\x02\x04\xb0\xca\
    \xbc\"\x02\x12\x03\x1d\x04d\ng\n\x04\x06\0\x02\x03\x12\x04#\x02%\x03\x1a\
    Y\x20ModuleVersions\x20queries\x20the\x20list\x20of\x20module\x20version\
    s\x20from\x20state.\n\n\x20Since:\x20cosmos-sdk\x200.43\n\n\x0c\n\x05\
    \x06\0\x02\x03\x01\x12\x03#\x06\x14\n\x0c\n\x05\x06\0\x02\x03\x02\x12\
    \x03#\x15/\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03#:U\n\x0c\n\x05\x06\0\
    \x02\x03\x04\x12\x03$\x04M\n\x11\n\n\x06\0\x02\x03\x04\xb0\xca\xbc\"\x02\
    \x12\x03$\x04M\n_\n\x02\x04\0\x12\x03*\0\"\x1aT\x20QueryCurrentPlanReque\
    st\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/CurrentPlan\
    \x20RPC\n\x20method.\n\n\n\n\x03\x04\0\x01\x12\x03*\x08\x1f\nb\n\x02\x04\
    \x01\x12\x04.\01\x01\x1aV\x20QueryCurrentPlanResponse\x20is\x20the\x20re\
    sponse\x20type\x20for\x20the\x20Query/CurrentPlan\x20RPC\n\x20method.\n\
    \n\n\n\x03\x04\x01\x01\x12\x03.\x08\x20\n0\n\x04\x04\x01\x02\0\x12\x030\
    \x02\x10\x1a#\x20plan\x20is\x20the\x20current\x20upgrade\x20plan.\n\n\
    \x0c\n\x05\x04\x01\x02\0\x06\x12\x030\x02\x06\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x030\x07\x0b\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x030\x0e\x0f\n`\
    \n\x02\x04\x02\x12\x045\08\x01\x1aT\x20QueryCurrentPlanRequest\x20is\x20\
    the\x20request\x20type\x20for\x20the\x20Query/AppliedPlan\x20RPC\n\x20me\
    thod.\n\n\n\n\x03\x04\x02\x01\x12\x035\x08\x1f\nA\n\x04\x04\x02\x02\0\
    \x12\x037\x02\x12\x1a4\x20name\x20is\x20the\x20name\x20of\x20the\x20appl\
    ied\x20plan\x20to\x20query\x20for.\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\
    \x037\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x037\t\r\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x037\x10\x11\nb\n\x02\x04\x03\x12\x04<\0?\x01\x1aV\
    \x20QueryAppliedPlanResponse\x20is\x20the\x20response\x20type\x20for\x20\
    the\x20Query/AppliedPlan\x20RPC\n\x20method.\n\n\n\n\x03\x04\x03\x01\x12\
    \x03<\x08\x20\nH\n\x04\x04\x03\x02\0\x12\x03>\x02\x13\x1a;\x20height\x20\
    is\x20the\x20block\x20height\x20at\x20which\x20the\x20plan\x20was\x20app\
    lied.\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03>\x02\x07\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03>\x08\x0e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03>\
    \x11\x12\nv\n\x02\x04\x04\x12\x04C\0I\x01\x1aj\x20QueryUpgradedConsensus\
    StateRequest\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/Upgr\
    adedConsensusState\n\x20RPC\x20method.\n\n\n\n\x03\x04\x04\x01\x12\x03C\
    \x08*\n\n\n\x03\x04\x04\x07\x12\x03D\x02\x1b\n\x0b\n\x04\x04\x04\x07\x03\
    \x12\x03D\x02\x1b\n\x89\x01\n\x04\x04\x04\x02\0\x12\x03H\x02\x18\x1a|\
    \x20last\x20height\x20of\x20the\x20current\x20chain\x20must\x20be\x20sen\
    t\x20in\x20request\n\x20as\x20this\x20is\x20the\x20height\x20under\x20wh\
    ich\x20next\x20consensus\x20state\x20is\x20stored\n\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03H\x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03H\x08\
    \x13\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03H\x16\x17\nx\n\x02\x04\x05\x12\
    \x04M\0S\x01\x1al\x20QueryUpgradedConsensusStateResponse\x20is\x20the\
    \x20response\x20type\x20for\x20the\x20Query/UpgradedConsensusState\n\x20\
    RPC\x20method.\n\n\n\n\x03\x04\x05\x01\x12\x03M\x08+\n\n\n\x03\x04\x05\
    \x07\x12\x03N\x02\x1b\n\x0b\n\x04\x04\x05\x07\x03\x12\x03N\x02\x1b\n\n\n\
    \x03\x04\x05\t\x12\x03O\x02\r\n\x0b\n\x04\x04\x05\t\0\x12\x03O\x0b\x0c\n\
    \x0c\n\x05\x04\x05\t\0\x01\x12\x03O\x0b\x0c\n\x0c\n\x05\x04\x05\t\0\x02\
    \x12\x03O\x0b\x0c\n%\n\x04\x04\x05\x02\0\x12\x03R\x02%\x1a\x18\x20Since:\
    \x20cosmos-sdk\x200.43\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03R\x02\x07\
    \n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03R\x08\x20\n\x0c\n\x05\x04\x05\x02\
    \0\x03\x12\x03R#$\n\x7f\n\x02\x04\x06\x12\x04Y\0^\x01\x1as\x20QueryModul\
    eVersionsRequest\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/\
    ModuleVersions\n\x20RPC\x20method.\n\n\x20Since:\x20cosmos-sdk\x200.43\n\
    \n\n\n\x03\x04\x06\x01\x12\x03Y\x08\"\n\xab\x01\n\x04\x04\x06\x02\0\x12\
    \x03]\x02\x19\x1a\x9d\x01\x20module_name\x20is\x20a\x20field\x20to\x20qu\
    ery\x20a\x20specific\x20module\n\x20consensus\x20version\x20from\x20stat\
    e.\x20Leaving\x20this\x20empty\x20will\n\x20fetch\x20the\x20full\x20list\
    \x20of\x20module\x20versions\x20from\x20state\n\n\x0c\n\x05\x04\x06\x02\
    \0\x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03]\t\x14\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03]\x17\x18\n\x81\x01\n\x02\x04\x07\
    \x12\x04d\0g\x01\x1au\x20QueryModuleVersionsResponse\x20is\x20the\x20res\
    ponse\x20type\x20for\x20the\x20Query/ModuleVersions\n\x20RPC\x20method.\
    \n\n\x20Since:\x20cosmos-sdk\x200.43\n\n\n\n\x03\x04\x07\x01\x12\x03d\
    \x08#\nW\n\x04\x04\x07\x02\0\x12\x03f\x02-\x1aJ\x20module_versions\x20is\
    \x20a\x20list\x20of\x20module\x20names\x20with\x20their\x20consensus\x20\
    versions.\n\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03f\x02\n\n\x0c\n\x05\x04\
    \x07\x02\0\x06\x12\x03f\x0b\x18\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03f\
    \x19(\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03f+,b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::upgrade::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(QueryCurrentPlanRequest::generated_message_descriptor_data());
            messages.push(QueryCurrentPlanResponse::generated_message_descriptor_data());
            messages.push(QueryAppliedPlanRequest::generated_message_descriptor_data());
            messages.push(QueryAppliedPlanResponse::generated_message_descriptor_data());
            messages.push(QueryUpgradedConsensusStateRequest::generated_message_descriptor_data());
            messages.push(QueryUpgradedConsensusStateResponse::generated_message_descriptor_data());
            messages.push(QueryModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(QueryModuleVersionsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
