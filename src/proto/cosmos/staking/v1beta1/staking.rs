// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos/staking/v1beta1/staking.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  HistoricalInfo contains header and validator information for a given block.
///  It is stored as part of staking module's state, which persists the `n` most
///  recent HistoricalInfo
///  (`n` is set by the staking module's `historical_entries` parameter).
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.HistoricalInfo)
pub struct HistoricalInfo {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.HistoricalInfo.header)
    pub header: ::protobuf::MessageField<super::types::Header>,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.HistoricalInfo.valset)
    pub valset: ::std::vec::Vec<Validator>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.HistoricalInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistoricalInfo {
    fn default() -> &'a HistoricalInfo {
        <HistoricalInfo as ::protobuf::Message>::default_instance()
    }
}

impl HistoricalInfo {
    pub fn new() -> HistoricalInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Header>(
            "header",
            |m: &HistoricalInfo| { &m.header },
            |m: &mut HistoricalInfo| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "valset",
            |m: &HistoricalInfo| { &m.valset },
            |m: &mut HistoricalInfo| { &mut m.valset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistoricalInfo>(
            "HistoricalInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistoricalInfo {
    const NAME: &'static str = "HistoricalInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.valset.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.valset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.valset {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistoricalInfo {
        HistoricalInfo::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.valset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistoricalInfo {
        static instance: HistoricalInfo = HistoricalInfo {
            header: ::protobuf::MessageField::none(),
            valset: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistoricalInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistoricalInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistoricalInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistoricalInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CommissionRates defines the initial commission rates to be used for creating
///  a validator.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.CommissionRates)
pub struct CommissionRates {
    // message fields
    ///  rate is the commission rate charged to delegators, as a fraction.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.CommissionRates.rate)
    pub rate: ::std::string::String,
    ///  max_rate defines the maximum commission rate which validator can ever charge, as a fraction.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.CommissionRates.max_rate)
    pub max_rate: ::std::string::String,
    ///  max_change_rate defines the maximum daily increase of the validator commission, as a fraction.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
    pub max_change_rate: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.CommissionRates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommissionRates {
    fn default() -> &'a CommissionRates {
        <CommissionRates as ::protobuf::Message>::default_instance()
    }
}

impl CommissionRates {
    pub fn new() -> CommissionRates {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rate",
            |m: &CommissionRates| { &m.rate },
            |m: &mut CommissionRates| { &mut m.rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_rate",
            |m: &CommissionRates| { &m.max_rate },
            |m: &mut CommissionRates| { &mut m.max_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_change_rate",
            |m: &CommissionRates| { &m.max_change_rate },
            |m: &mut CommissionRates| { &mut m.max_change_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommissionRates>(
            "CommissionRates",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommissionRates {
    const NAME: &'static str = "CommissionRates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rate = is.read_string()?;
                },
                18 => {
                    self.max_rate = is.read_string()?;
                },
                26 => {
                    self.max_change_rate = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.rate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rate);
        }
        if !self.max_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.max_rate);
        }
        if !self.max_change_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.max_change_rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.rate.is_empty() {
            os.write_string(1, &self.rate)?;
        }
        if !self.max_rate.is_empty() {
            os.write_string(2, &self.max_rate)?;
        }
        if !self.max_change_rate.is_empty() {
            os.write_string(3, &self.max_change_rate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommissionRates {
        CommissionRates::new()
    }

    fn clear(&mut self) {
        self.rate.clear();
        self.max_rate.clear();
        self.max_change_rate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommissionRates {
        static instance: CommissionRates = CommissionRates {
            rate: ::std::string::String::new(),
            max_rate: ::std::string::String::new(),
            max_change_rate: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommissionRates {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommissionRates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommissionRates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommissionRates {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Commission defines commission parameters for a given validator.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.Commission)
pub struct Commission {
    // message fields
    ///  commission_rates defines the initial commission rates to be used for creating a validator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Commission.commission_rates)
    pub commission_rates: ::protobuf::MessageField<CommissionRates>,
    ///  update_time is the last time the commission rate was changed.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Commission.update_time)
    pub update_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.Commission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Commission {
    fn default() -> &'a Commission {
        <Commission as ::protobuf::Message>::default_instance()
    }
}

impl Commission {
    pub fn new() -> Commission {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CommissionRates>(
            "commission_rates",
            |m: &Commission| { &m.commission_rates },
            |m: &mut Commission| { &mut m.commission_rates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "update_time",
            |m: &Commission| { &m.update_time },
            |m: &mut Commission| { &mut m.update_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Commission>(
            "Commission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Commission {
    const NAME: &'static str = "Commission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commission_rates)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commission_rates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.commission_rates.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.update_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Commission {
        Commission::new()
    }

    fn clear(&mut self) {
        self.commission_rates.clear();
        self.update_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Commission {
        static instance: Commission = Commission {
            commission_rates: ::protobuf::MessageField::none(),
            update_time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Commission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Commission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Commission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Commission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Description defines a validator description.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.Description)
pub struct Description {
    // message fields
    ///  moniker defines a human-readable name for the validator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Description.moniker)
    pub moniker: ::std::string::String,
    ///  identity defines an optional identity signature (ex. UPort or Keybase).
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Description.identity)
    pub identity: ::std::string::String,
    ///  website defines an optional website link.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Description.website)
    pub website: ::std::string::String,
    ///  security_contact defines an optional email for security contact.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Description.security_contact)
    pub security_contact: ::std::string::String,
    ///  details define other optional details.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Description.details)
    pub details: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.Description.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Description {
    fn default() -> &'a Description {
        <Description as ::protobuf::Message>::default_instance()
    }
}

impl Description {
    pub fn new() -> Description {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "moniker",
            |m: &Description| { &m.moniker },
            |m: &mut Description| { &mut m.moniker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "identity",
            |m: &Description| { &m.identity },
            |m: &mut Description| { &mut m.identity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "website",
            |m: &Description| { &m.website },
            |m: &mut Description| { &mut m.website },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "security_contact",
            |m: &Description| { &m.security_contact },
            |m: &mut Description| { &mut m.security_contact },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "details",
            |m: &Description| { &m.details },
            |m: &mut Description| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Description>(
            "Description",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Description {
    const NAME: &'static str = "Description";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.moniker = is.read_string()?;
                },
                18 => {
                    self.identity = is.read_string()?;
                },
                26 => {
                    self.website = is.read_string()?;
                },
                34 => {
                    self.security_contact = is.read_string()?;
                },
                42 => {
                    self.details = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.moniker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.moniker);
        }
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity);
        }
        if !self.website.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.website);
        }
        if !self.security_contact.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.security_contact);
        }
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.moniker.is_empty() {
            os.write_string(1, &self.moniker)?;
        }
        if !self.identity.is_empty() {
            os.write_string(2, &self.identity)?;
        }
        if !self.website.is_empty() {
            os.write_string(3, &self.website)?;
        }
        if !self.security_contact.is_empty() {
            os.write_string(4, &self.security_contact)?;
        }
        if !self.details.is_empty() {
            os.write_string(5, &self.details)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Description {
        Description::new()
    }

    fn clear(&mut self) {
        self.moniker.clear();
        self.identity.clear();
        self.website.clear();
        self.security_contact.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Description {
        static instance: Description = Description {
            moniker: ::std::string::String::new(),
            identity: ::std::string::String::new(),
            website: ::std::string::String::new(),
            security_contact: ::std::string::String::new(),
            details: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Description {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Description").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Description {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Description {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Validator defines a validator, together with the total amount of the
///  Validator's bond shares and their exchange rate to coins. Slashing results in
///  a decrease in the exchange rate, allowing correct calculation of future
///  undelegations without iterating over delegators. When coins are delegated to
///  this validator, the validator is credited with a delegation whose number of
///  bond shares is based on the amount of coins delegated divided by the current
///  exchange rate. Voting power can be calculated as total bonded shares
///  multiplied by exchange rate.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.Validator)
pub struct Validator {
    // message fields
    ///  operator_address defines the address of the validator's operator; bech encoded in JSON.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.operator_address)
    pub operator_address: ::std::string::String,
    ///  consensus_pubkey is the consensus public key of the validator, as a Protobuf Any.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.consensus_pubkey)
    pub consensus_pubkey: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  jailed defined whether the validator has been jailed from bonded status or not.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.jailed)
    pub jailed: bool,
    ///  status is the validator status (bonded/unbonding/unbonded).
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.status)
    pub status: ::protobuf::EnumOrUnknown<BondStatus>,
    ///  tokens define the delegated tokens (incl. self-delegation).
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.tokens)
    pub tokens: ::std::string::String,
    ///  delegator_shares defines total shares issued to a validator's delegators.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.delegator_shares)
    pub delegator_shares: ::std::string::String,
    ///  description defines the description terms for the validator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.description)
    pub description: ::protobuf::MessageField<Description>,
    ///  unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.unbonding_height)
    pub unbonding_height: i64,
    ///  unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.unbonding_time)
    pub unbonding_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  commission defines the commission parameters.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.commission)
    pub commission: ::protobuf::MessageField<Commission>,
    ///  min_self_delegation is the validator's self declared minimum self delegation.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Validator.min_self_delegation)
    pub min_self_delegation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.Validator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "operator_address",
            |m: &Validator| { &m.operator_address },
            |m: &mut Validator| { &mut m.operator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "consensus_pubkey",
            |m: &Validator| { &m.consensus_pubkey },
            |m: &mut Validator| { &mut m.consensus_pubkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "jailed",
            |m: &Validator| { &m.jailed },
            |m: &mut Validator| { &mut m.jailed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &Validator| { &m.status },
            |m: &mut Validator| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tokens",
            |m: &Validator| { &m.tokens },
            |m: &mut Validator| { &mut m.tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_shares",
            |m: &Validator| { &m.delegator_shares },
            |m: &mut Validator| { &mut m.delegator_shares },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Description>(
            "description",
            |m: &Validator| { &m.description },
            |m: &mut Validator| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unbonding_height",
            |m: &Validator| { &m.unbonding_height },
            |m: &mut Validator| { &mut m.unbonding_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "unbonding_time",
            |m: &Validator| { &m.unbonding_time },
            |m: &mut Validator| { &mut m.unbonding_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Commission>(
            "commission",
            |m: &Validator| { &m.commission },
            |m: &mut Validator| { &mut m.commission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_self_delegation",
            |m: &Validator| { &m.min_self_delegation },
            |m: &mut Validator| { &mut m.min_self_delegation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Validator>(
            "Validator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Validator {
    const NAME: &'static str = "Validator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operator_address = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_pubkey)?;
                },
                24 => {
                    self.jailed = is.read_bool()?;
                },
                32 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.tokens = is.read_string()?;
                },
                50 => {
                    self.delegator_shares = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.description)?;
                },
                64 => {
                    self.unbonding_height = is.read_int64()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unbonding_time)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commission)?;
                },
                90 => {
                    self.min_self_delegation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.operator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operator_address);
        }
        if let Some(v) = self.consensus_pubkey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.jailed != false {
            my_size += 1 + 1;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(BondStatus::BOND_STATUS_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.status.value());
        }
        if !self.tokens.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tokens);
        }
        if !self.delegator_shares.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.delegator_shares);
        }
        if let Some(v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.unbonding_height != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.unbonding_height);
        }
        if let Some(v) = self.unbonding_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.commission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.min_self_delegation.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.min_self_delegation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.operator_address.is_empty() {
            os.write_string(1, &self.operator_address)?;
        }
        if let Some(v) = self.consensus_pubkey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.jailed != false {
            os.write_bool(3, self.jailed)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(BondStatus::BOND_STATUS_UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.tokens.is_empty() {
            os.write_string(5, &self.tokens)?;
        }
        if !self.delegator_shares.is_empty() {
            os.write_string(6, &self.delegator_shares)?;
        }
        if let Some(v) = self.description.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.unbonding_height != 0 {
            os.write_int64(8, self.unbonding_height)?;
        }
        if let Some(v) = self.unbonding_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.commission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if !self.min_self_delegation.is_empty() {
            os.write_string(11, &self.min_self_delegation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn clear(&mut self) {
        self.operator_address.clear();
        self.consensus_pubkey.clear();
        self.jailed = false;
        self.status = ::protobuf::EnumOrUnknown::new(BondStatus::BOND_STATUS_UNSPECIFIED);
        self.tokens.clear();
        self.delegator_shares.clear();
        self.description.clear();
        self.unbonding_height = 0;
        self.unbonding_time.clear();
        self.commission.clear();
        self.min_self_delegation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Validator {
        static instance: Validator = Validator {
            operator_address: ::std::string::String::new(),
            consensus_pubkey: ::protobuf::MessageField::none(),
            jailed: false,
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            tokens: ::std::string::String::new(),
            delegator_shares: ::std::string::String::new(),
            description: ::protobuf::MessageField::none(),
            unbonding_height: 0,
            unbonding_time: ::protobuf::MessageField::none(),
            commission: ::protobuf::MessageField::none(),
            min_self_delegation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Validator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Validator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValAddresses defines a repeated set of validator addresses.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.ValAddresses)
pub struct ValAddresses {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.ValAddresses.addresses)
    pub addresses: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.ValAddresses.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValAddresses {
    fn default() -> &'a ValAddresses {
        <ValAddresses as ::protobuf::Message>::default_instance()
    }
}

impl ValAddresses {
    pub fn new() -> ValAddresses {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &ValAddresses| { &m.addresses },
            |m: &mut ValAddresses| { &mut m.addresses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValAddresses>(
            "ValAddresses",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValAddresses {
    const NAME: &'static str = "ValAddresses";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addresses {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValAddresses {
        ValAddresses::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValAddresses {
        static instance: ValAddresses = ValAddresses {
            addresses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValAddresses {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValAddresses").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValAddresses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValAddresses {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DVPair is struct that just has a delegator-validator pair with no other data.
///  It is intended to be used as a marshalable pointer. For example, a DVPair can
///  be used to construct the key to getting an UnbondingDelegation from state.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.DVPair)
pub struct DVPair {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DVPair.delegator_address)
    pub delegator_address: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DVPair.validator_address)
    pub validator_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.DVPair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DVPair {
    fn default() -> &'a DVPair {
        <DVPair as ::protobuf::Message>::default_instance()
    }
}

impl DVPair {
    pub fn new() -> DVPair {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &DVPair| { &m.delegator_address },
            |m: &mut DVPair| { &mut m.delegator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &DVPair| { &m.validator_address },
            |m: &mut DVPair| { &mut m.validator_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DVPair>(
            "DVPair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DVPair {
    const NAME: &'static str = "DVPair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                18 => {
                    self.validator_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_address.is_empty() {
            os.write_string(2, &self.validator_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DVPair {
        DVPair::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DVPair {
        static instance: DVPair = DVPair {
            delegator_address: ::std::string::String::new(),
            validator_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DVPair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DVPair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DVPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVPair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DVPairs defines an array of DVPair objects.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.DVPairs)
pub struct DVPairs {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DVPairs.pairs)
    pub pairs: ::std::vec::Vec<DVPair>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.DVPairs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DVPairs {
    fn default() -> &'a DVPairs {
        <DVPairs as ::protobuf::Message>::default_instance()
    }
}

impl DVPairs {
    pub fn new() -> DVPairs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pairs",
            |m: &DVPairs| { &m.pairs },
            |m: &mut DVPairs| { &mut m.pairs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DVPairs>(
            "DVPairs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DVPairs {
    const NAME: &'static str = "DVPairs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pairs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pairs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DVPairs {
        DVPairs::new()
    }

    fn clear(&mut self) {
        self.pairs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DVPairs {
        static instance: DVPairs = DVPairs {
            pairs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DVPairs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DVPairs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DVPairs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVPairs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DVVTriplet is struct that just has a delegator-validator-validator triplet
///  with no other data. It is intended to be used as a marshalable pointer. For
///  example, a DVVTriplet can be used to construct the key to getting a
///  Redelegation from state.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.DVVTriplet)
pub struct DVVTriplet {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
    pub delegator_address: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
    pub validator_src_address: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
    pub validator_dst_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.DVVTriplet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DVVTriplet {
    fn default() -> &'a DVVTriplet {
        <DVVTriplet as ::protobuf::Message>::default_instance()
    }
}

impl DVVTriplet {
    pub fn new() -> DVVTriplet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &DVVTriplet| { &m.delegator_address },
            |m: &mut DVVTriplet| { &mut m.delegator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_src_address",
            |m: &DVVTriplet| { &m.validator_src_address },
            |m: &mut DVVTriplet| { &mut m.validator_src_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_dst_address",
            |m: &DVVTriplet| { &m.validator_dst_address },
            |m: &mut DVVTriplet| { &mut m.validator_dst_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DVVTriplet>(
            "DVVTriplet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DVVTriplet {
    const NAME: &'static str = "DVVTriplet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                18 => {
                    self.validator_src_address = is.read_string()?;
                },
                26 => {
                    self.validator_dst_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_src_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_src_address);
        }
        if !self.validator_dst_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.validator_dst_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_src_address.is_empty() {
            os.write_string(2, &self.validator_src_address)?;
        }
        if !self.validator_dst_address.is_empty() {
            os.write_string(3, &self.validator_dst_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DVVTriplet {
        DVVTriplet::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_src_address.clear();
        self.validator_dst_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DVVTriplet {
        static instance: DVVTriplet = DVVTriplet {
            delegator_address: ::std::string::String::new(),
            validator_src_address: ::std::string::String::new(),
            validator_dst_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DVVTriplet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DVVTriplet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DVVTriplet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVVTriplet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DVVTriplets defines an array of DVVTriplet objects.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.DVVTriplets)
pub struct DVVTriplets {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DVVTriplets.triplets)
    pub triplets: ::std::vec::Vec<DVVTriplet>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.DVVTriplets.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DVVTriplets {
    fn default() -> &'a DVVTriplets {
        <DVVTriplets as ::protobuf::Message>::default_instance()
    }
}

impl DVVTriplets {
    pub fn new() -> DVVTriplets {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "triplets",
            |m: &DVVTriplets| { &m.triplets },
            |m: &mut DVVTriplets| { &mut m.triplets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DVVTriplets>(
            "DVVTriplets",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DVVTriplets {
    const NAME: &'static str = "DVVTriplets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.triplets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.triplets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.triplets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DVVTriplets {
        DVVTriplets::new()
    }

    fn clear(&mut self) {
        self.triplets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DVVTriplets {
        static instance: DVVTriplets = DVVTriplets {
            triplets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DVVTriplets {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DVVTriplets").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DVVTriplets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DVVTriplets {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Delegation represents the bond with tokens held by an account. It is
///  owned by one delegator, and is associated with the voting power of one
///  validator.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.Delegation)
pub struct Delegation {
    // message fields
    ///  delegator_address is the bech32-encoded address of the delegator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Delegation.delegator_address)
    pub delegator_address: ::std::string::String,
    ///  validator_address is the bech32-encoded address of the validator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Delegation.validator_address)
    pub validator_address: ::std::string::String,
    ///  shares define the delegation shares received.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Delegation.shares)
    pub shares: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.Delegation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Delegation {
    fn default() -> &'a Delegation {
        <Delegation as ::protobuf::Message>::default_instance()
    }
}

impl Delegation {
    pub fn new() -> Delegation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &Delegation| { &m.delegator_address },
            |m: &mut Delegation| { &mut m.delegator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &Delegation| { &m.validator_address },
            |m: &mut Delegation| { &mut m.validator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shares",
            |m: &Delegation| { &m.shares },
            |m: &mut Delegation| { &mut m.shares },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Delegation>(
            "Delegation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Delegation {
    const NAME: &'static str = "Delegation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                18 => {
                    self.validator_address = is.read_string()?;
                },
                26 => {
                    self.shares = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_address);
        }
        if !self.shares.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.shares);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_address.is_empty() {
            os.write_string(2, &self.validator_address)?;
        }
        if !self.shares.is_empty() {
            os.write_string(3, &self.shares)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Delegation {
        Delegation::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_address.clear();
        self.shares.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Delegation {
        static instance: Delegation = Delegation {
            delegator_address: ::std::string::String::new(),
            validator_address: ::std::string::String::new(),
            shares: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Delegation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Delegation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Delegation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Delegation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  UnbondingDelegation stores all of a single delegator's unbonding bonds
///  for a single validator in an time-ordered list.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.UnbondingDelegation)
pub struct UnbondingDelegation {
    // message fields
    ///  delegator_address is the bech32-encoded address of the delegator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
    pub delegator_address: ::std::string::String,
    ///  validator_address is the bech32-encoded address of the validator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
    pub validator_address: ::std::string::String,
    ///  entries are the unbonding delegation entries.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.UnbondingDelegation.entries)
    pub entries: ::std::vec::Vec<UnbondingDelegationEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.UnbondingDelegation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnbondingDelegation {
    fn default() -> &'a UnbondingDelegation {
        <UnbondingDelegation as ::protobuf::Message>::default_instance()
    }
}

impl UnbondingDelegation {
    pub fn new() -> UnbondingDelegation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &UnbondingDelegation| { &m.delegator_address },
            |m: &mut UnbondingDelegation| { &mut m.delegator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &UnbondingDelegation| { &m.validator_address },
            |m: &mut UnbondingDelegation| { &mut m.validator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &UnbondingDelegation| { &m.entries },
            |m: &mut UnbondingDelegation| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnbondingDelegation>(
            "UnbondingDelegation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnbondingDelegation {
    const NAME: &'static str = "UnbondingDelegation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                18 => {
                    self.validator_address = is.read_string()?;
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_address);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_address.is_empty() {
            os.write_string(2, &self.validator_address)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnbondingDelegation {
        UnbondingDelegation::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_address.clear();
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnbondingDelegation {
        static instance: UnbondingDelegation = UnbondingDelegation {
            delegator_address: ::std::string::String::new(),
            validator_address: ::std::string::String::new(),
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnbondingDelegation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnbondingDelegation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnbondingDelegation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnbondingDelegation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  UnbondingDelegationEntry defines an unbonding object with relevant metadata.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.UnbondingDelegationEntry)
pub struct UnbondingDelegationEntry {
    // message fields
    ///  creation_height is the height which the unbonding took place.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.UnbondingDelegationEntry.creation_height)
    pub creation_height: i64,
    ///  completion_time is the unix time for unbonding completion.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
    pub completion_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  initial_balance defines the tokens initially scheduled to receive at completion.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
    pub initial_balance: ::std::string::String,
    ///  balance defines the tokens to receive at completion.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
    pub balance: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.UnbondingDelegationEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnbondingDelegationEntry {
    fn default() -> &'a UnbondingDelegationEntry {
        <UnbondingDelegationEntry as ::protobuf::Message>::default_instance()
    }
}

impl UnbondingDelegationEntry {
    pub fn new() -> UnbondingDelegationEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creation_height",
            |m: &UnbondingDelegationEntry| { &m.creation_height },
            |m: &mut UnbondingDelegationEntry| { &mut m.creation_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "completion_time",
            |m: &UnbondingDelegationEntry| { &m.completion_time },
            |m: &mut UnbondingDelegationEntry| { &mut m.completion_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "initial_balance",
            |m: &UnbondingDelegationEntry| { &m.initial_balance },
            |m: &mut UnbondingDelegationEntry| { &mut m.initial_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "balance",
            |m: &UnbondingDelegationEntry| { &m.balance },
            |m: &mut UnbondingDelegationEntry| { &mut m.balance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnbondingDelegationEntry>(
            "UnbondingDelegationEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnbondingDelegationEntry {
    const NAME: &'static str = "UnbondingDelegationEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.creation_height = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.completion_time)?;
                },
                26 => {
                    self.initial_balance = is.read_string()?;
                },
                34 => {
                    self.balance = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.creation_height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.creation_height);
        }
        if let Some(v) = self.completion_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.initial_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.initial_balance);
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.creation_height != 0 {
            os.write_int64(1, self.creation_height)?;
        }
        if let Some(v) = self.completion_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.initial_balance.is_empty() {
            os.write_string(3, &self.initial_balance)?;
        }
        if !self.balance.is_empty() {
            os.write_string(4, &self.balance)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnbondingDelegationEntry {
        UnbondingDelegationEntry::new()
    }

    fn clear(&mut self) {
        self.creation_height = 0;
        self.completion_time.clear();
        self.initial_balance.clear();
        self.balance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnbondingDelegationEntry {
        static instance: UnbondingDelegationEntry = UnbondingDelegationEntry {
            creation_height: 0,
            completion_time: ::protobuf::MessageField::none(),
            initial_balance: ::std::string::String::new(),
            balance: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnbondingDelegationEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnbondingDelegationEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnbondingDelegationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnbondingDelegationEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  RedelegationEntry defines a redelegation object with relevant metadata.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.RedelegationEntry)
pub struct RedelegationEntry {
    // message fields
    ///  creation_height  defines the height which the redelegation took place.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationEntry.creation_height)
    pub creation_height: i64,
    ///  completion_time defines the unix time for redelegation completion.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
    pub completion_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  initial_balance defines the initial balance when redelegation started.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
    pub initial_balance: ::std::string::String,
    ///  shares_dst is the amount of destination-validator shares created by redelegation.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
    pub shares_dst: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.RedelegationEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RedelegationEntry {
    fn default() -> &'a RedelegationEntry {
        <RedelegationEntry as ::protobuf::Message>::default_instance()
    }
}

impl RedelegationEntry {
    pub fn new() -> RedelegationEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creation_height",
            |m: &RedelegationEntry| { &m.creation_height },
            |m: &mut RedelegationEntry| { &mut m.creation_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "completion_time",
            |m: &RedelegationEntry| { &m.completion_time },
            |m: &mut RedelegationEntry| { &mut m.completion_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "initial_balance",
            |m: &RedelegationEntry| { &m.initial_balance },
            |m: &mut RedelegationEntry| { &mut m.initial_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shares_dst",
            |m: &RedelegationEntry| { &m.shares_dst },
            |m: &mut RedelegationEntry| { &mut m.shares_dst },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedelegationEntry>(
            "RedelegationEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RedelegationEntry {
    const NAME: &'static str = "RedelegationEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.creation_height = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.completion_time)?;
                },
                26 => {
                    self.initial_balance = is.read_string()?;
                },
                34 => {
                    self.shares_dst = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.creation_height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.creation_height);
        }
        if let Some(v) = self.completion_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.initial_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.initial_balance);
        }
        if !self.shares_dst.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.shares_dst);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.creation_height != 0 {
            os.write_int64(1, self.creation_height)?;
        }
        if let Some(v) = self.completion_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.initial_balance.is_empty() {
            os.write_string(3, &self.initial_balance)?;
        }
        if !self.shares_dst.is_empty() {
            os.write_string(4, &self.shares_dst)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RedelegationEntry {
        RedelegationEntry::new()
    }

    fn clear(&mut self) {
        self.creation_height = 0;
        self.completion_time.clear();
        self.initial_balance.clear();
        self.shares_dst.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RedelegationEntry {
        static instance: RedelegationEntry = RedelegationEntry {
            creation_height: 0,
            completion_time: ::protobuf::MessageField::none(),
            initial_balance: ::std::string::String::new(),
            shares_dst: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RedelegationEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RedelegationEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RedelegationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedelegationEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Redelegation contains the list of a particular delegator's redelegating bonds
///  from a particular source validator to a particular destination validator.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.Redelegation)
pub struct Redelegation {
    // message fields
    ///  delegator_address is the bech32-encoded address of the delegator.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Redelegation.delegator_address)
    pub delegator_address: ::std::string::String,
    ///  validator_src_address is the validator redelegation source operator address.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Redelegation.validator_src_address)
    pub validator_src_address: ::std::string::String,
    ///  validator_dst_address is the validator redelegation destination operator address.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
    pub validator_dst_address: ::std::string::String,
    ///  entries are the redelegation entries.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Redelegation.entries)
    pub entries: ::std::vec::Vec<RedelegationEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.Redelegation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Redelegation {
    fn default() -> &'a Redelegation {
        <Redelegation as ::protobuf::Message>::default_instance()
    }
}

impl Redelegation {
    pub fn new() -> Redelegation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delegator_address",
            |m: &Redelegation| { &m.delegator_address },
            |m: &mut Redelegation| { &mut m.delegator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_src_address",
            |m: &Redelegation| { &m.validator_src_address },
            |m: &mut Redelegation| { &mut m.validator_src_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_dst_address",
            |m: &Redelegation| { &m.validator_dst_address },
            |m: &mut Redelegation| { &mut m.validator_dst_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &Redelegation| { &m.entries },
            |m: &mut Redelegation| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Redelegation>(
            "Redelegation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Redelegation {
    const NAME: &'static str = "Redelegation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.delegator_address = is.read_string()?;
                },
                18 => {
                    self.validator_src_address = is.read_string()?;
                },
                26 => {
                    self.validator_dst_address = is.read_string()?;
                },
                34 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.delegator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_address);
        }
        if !self.validator_src_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_src_address);
        }
        if !self.validator_dst_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.validator_dst_address);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.delegator_address.is_empty() {
            os.write_string(1, &self.delegator_address)?;
        }
        if !self.validator_src_address.is_empty() {
            os.write_string(2, &self.validator_src_address)?;
        }
        if !self.validator_dst_address.is_empty() {
            os.write_string(3, &self.validator_dst_address)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Redelegation {
        Redelegation::new()
    }

    fn clear(&mut self) {
        self.delegator_address.clear();
        self.validator_src_address.clear();
        self.validator_dst_address.clear();
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Redelegation {
        static instance: Redelegation = Redelegation {
            delegator_address: ::std::string::String::new(),
            validator_src_address: ::std::string::String::new(),
            validator_dst_address: ::std::string::String::new(),
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Redelegation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Redelegation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Redelegation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Redelegation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Params defines the parameters for the staking module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.Params)
pub struct Params {
    // message fields
    ///  unbonding_time is the time duration of unbonding.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Params.unbonding_time)
    pub unbonding_time: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    ///  max_validators is the maximum number of validators.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Params.max_validators)
    pub max_validators: u32,
    ///  max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Params.max_entries)
    pub max_entries: u32,
    ///  historical_entries is the number of historical entries to persist.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Params.historical_entries)
    pub historical_entries: u32,
    ///  bond_denom defines the bondable coin denomination.
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Params.bond_denom)
    pub bond_denom: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.Params.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Params {
    fn default() -> &'a Params {
        <Params as ::protobuf::Message>::default_instance()
    }
}

impl Params {
    pub fn new() -> Params {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "unbonding_time",
            |m: &Params| { &m.unbonding_time },
            |m: &mut Params| { &mut m.unbonding_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_validators",
            |m: &Params| { &m.max_validators },
            |m: &mut Params| { &mut m.max_validators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_entries",
            |m: &Params| { &m.max_entries },
            |m: &mut Params| { &mut m.max_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "historical_entries",
            |m: &Params| { &m.historical_entries },
            |m: &mut Params| { &mut m.historical_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bond_denom",
            |m: &Params| { &m.bond_denom },
            |m: &mut Params| { &mut m.bond_denom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Params>(
            "Params",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Params {
    const NAME: &'static str = "Params";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unbonding_time)?;
                },
                16 => {
                    self.max_validators = is.read_uint32()?;
                },
                24 => {
                    self.max_entries = is.read_uint32()?;
                },
                32 => {
                    self.historical_entries = is.read_uint32()?;
                },
                42 => {
                    self.bond_denom = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unbonding_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.max_validators != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.max_validators);
        }
        if self.max_entries != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.max_entries);
        }
        if self.historical_entries != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.historical_entries);
        }
        if !self.bond_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bond_denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unbonding_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.max_validators != 0 {
            os.write_uint32(2, self.max_validators)?;
        }
        if self.max_entries != 0 {
            os.write_uint32(3, self.max_entries)?;
        }
        if self.historical_entries != 0 {
            os.write_uint32(4, self.historical_entries)?;
        }
        if !self.bond_denom.is_empty() {
            os.write_string(5, &self.bond_denom)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Params {
        Params::new()
    }

    fn clear(&mut self) {
        self.unbonding_time.clear();
        self.max_validators = 0;
        self.max_entries = 0;
        self.historical_entries = 0;
        self.bond_denom.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Params {
        static instance: Params = Params {
            unbonding_time: ::protobuf::MessageField::none(),
            max_validators: 0,
            max_entries: 0,
            historical_entries: 0,
            bond_denom: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Params {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Params").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Params {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DelegationResponse is equivalent to Delegation except that it contains a
///  balance in addition to shares which is more suitable for client responses.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.DelegationResponse)
pub struct DelegationResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DelegationResponse.delegation)
    pub delegation: ::protobuf::MessageField<Delegation>,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.DelegationResponse.balance)
    pub balance: ::protobuf::MessageField<super::coin::Coin>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.DelegationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DelegationResponse {
    fn default() -> &'a DelegationResponse {
        <DelegationResponse as ::protobuf::Message>::default_instance()
    }
}

impl DelegationResponse {
    pub fn new() -> DelegationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Delegation>(
            "delegation",
            |m: &DelegationResponse| { &m.delegation },
            |m: &mut DelegationResponse| { &mut m.delegation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "balance",
            |m: &DelegationResponse| { &m.balance },
            |m: &mut DelegationResponse| { &mut m.balance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelegationResponse>(
            "DelegationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DelegationResponse {
    const NAME: &'static str = "DelegationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.delegation)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.balance)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delegation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.delegation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.balance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DelegationResponse {
        DelegationResponse::new()
    }

    fn clear(&mut self) {
        self.delegation.clear();
        self.balance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DelegationResponse {
        static instance: DelegationResponse = DelegationResponse {
            delegation: ::protobuf::MessageField::none(),
            balance: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DelegationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DelegationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DelegationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
///  contains a balance in addition to shares which is more suitable for client
///  responses.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.RedelegationEntryResponse)
pub struct RedelegationEntryResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
    pub redelegation_entry: ::protobuf::MessageField<RedelegationEntry>,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
    pub balance: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.RedelegationEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RedelegationEntryResponse {
    fn default() -> &'a RedelegationEntryResponse {
        <RedelegationEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl RedelegationEntryResponse {
    pub fn new() -> RedelegationEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RedelegationEntry>(
            "redelegation_entry",
            |m: &RedelegationEntryResponse| { &m.redelegation_entry },
            |m: &mut RedelegationEntryResponse| { &mut m.redelegation_entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "balance",
            |m: &RedelegationEntryResponse| { &m.balance },
            |m: &mut RedelegationEntryResponse| { &mut m.balance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedelegationEntryResponse>(
            "RedelegationEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RedelegationEntryResponse {
    const NAME: &'static str = "RedelegationEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.redelegation_entry)?;
                },
                34 => {
                    self.balance = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.redelegation_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.redelegation_entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.balance.is_empty() {
            os.write_string(4, &self.balance)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RedelegationEntryResponse {
        RedelegationEntryResponse::new()
    }

    fn clear(&mut self) {
        self.redelegation_entry.clear();
        self.balance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RedelegationEntryResponse {
        static instance: RedelegationEntryResponse = RedelegationEntryResponse {
            redelegation_entry: ::protobuf::MessageField::none(),
            balance: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RedelegationEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RedelegationEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RedelegationEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedelegationEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  RedelegationResponse is equivalent to a Redelegation except that its entries
///  contain a balance in addition to shares which is more suitable for client
///  responses.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.RedelegationResponse)
pub struct RedelegationResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
    pub redelegation: ::protobuf::MessageField<Redelegation>,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.RedelegationResponse.entries)
    pub entries: ::std::vec::Vec<RedelegationEntryResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.RedelegationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RedelegationResponse {
    fn default() -> &'a RedelegationResponse {
        <RedelegationResponse as ::protobuf::Message>::default_instance()
    }
}

impl RedelegationResponse {
    pub fn new() -> RedelegationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Redelegation>(
            "redelegation",
            |m: &RedelegationResponse| { &m.redelegation },
            |m: &mut RedelegationResponse| { &mut m.redelegation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &RedelegationResponse| { &m.entries },
            |m: &mut RedelegationResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedelegationResponse>(
            "RedelegationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RedelegationResponse {
    const NAME: &'static str = "RedelegationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.redelegation)?;
                },
                18 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.redelegation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.redelegation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RedelegationResponse {
        RedelegationResponse::new()
    }

    fn clear(&mut self) {
        self.redelegation.clear();
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RedelegationResponse {
        static instance: RedelegationResponse = RedelegationResponse {
            redelegation: ::protobuf::MessageField::none(),
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RedelegationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RedelegationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RedelegationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedelegationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Pool is used for tracking bonded and not-bonded token supply of the bond
///  denomination.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.staking.v1beta1.Pool)
pub struct Pool {
    // message fields
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
    pub not_bonded_tokens: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.staking.v1beta1.Pool.bonded_tokens)
    pub bonded_tokens: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.staking.v1beta1.Pool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pool {
    fn default() -> &'a Pool {
        <Pool as ::protobuf::Message>::default_instance()
    }
}

impl Pool {
    pub fn new() -> Pool {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "not_bonded_tokens",
            |m: &Pool| { &m.not_bonded_tokens },
            |m: &mut Pool| { &mut m.not_bonded_tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bonded_tokens",
            |m: &Pool| { &m.bonded_tokens },
            |m: &mut Pool| { &mut m.bonded_tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pool>(
            "Pool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pool {
    const NAME: &'static str = "Pool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.not_bonded_tokens = is.read_string()?;
                },
                18 => {
                    self.bonded_tokens = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.not_bonded_tokens.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.not_bonded_tokens);
        }
        if !self.bonded_tokens.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bonded_tokens);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.not_bonded_tokens.is_empty() {
            os.write_string(1, &self.not_bonded_tokens)?;
        }
        if !self.bonded_tokens.is_empty() {
            os.write_string(2, &self.bonded_tokens)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pool {
        Pool::new()
    }

    fn clear(&mut self) {
        self.not_bonded_tokens.clear();
        self.bonded_tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pool {
        static instance: Pool = Pool {
            not_bonded_tokens: ::std::string::String::new(),
            bonded_tokens: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BondStatus is the status of a validator.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cosmos.staking.v1beta1.BondStatus)
pub enum BondStatus {
    // @@protoc_insertion_point(enum_value:cosmos.staking.v1beta1.BondStatus.BOND_STATUS_UNSPECIFIED)
    BOND_STATUS_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:cosmos.staking.v1beta1.BondStatus.BOND_STATUS_UNBONDED)
    BOND_STATUS_UNBONDED = 1,
    // @@protoc_insertion_point(enum_value:cosmos.staking.v1beta1.BondStatus.BOND_STATUS_UNBONDING)
    BOND_STATUS_UNBONDING = 2,
    // @@protoc_insertion_point(enum_value:cosmos.staking.v1beta1.BondStatus.BOND_STATUS_BONDED)
    BOND_STATUS_BONDED = 3,
}

impl ::protobuf::Enum for BondStatus {
    const NAME: &'static str = "BondStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BondStatus> {
        match value {
            0 => ::std::option::Option::Some(BondStatus::BOND_STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(BondStatus::BOND_STATUS_UNBONDED),
            2 => ::std::option::Option::Some(BondStatus::BOND_STATUS_UNBONDING),
            3 => ::std::option::Option::Some(BondStatus::BOND_STATUS_BONDED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BondStatus] = &[
        BondStatus::BOND_STATUS_UNSPECIFIED,
        BondStatus::BOND_STATUS_UNBONDED,
        BondStatus::BOND_STATUS_UNBONDING,
        BondStatus::BOND_STATUS_BONDED,
    ];
}

impl ::protobuf::EnumFull for BondStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BondStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BondStatus {
    fn default() -> Self {
        BondStatus::BOND_STATUS_UNSPECIFIED
    }
}

impl BondStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BondStatus>("BondStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$cosmos/staking/v1beta1/staking.proto\x12\x16cosmos.staking.v1beta1\
    \x1a\x14gogoproto/gogo.proto\x1a\x19google/protobuf/any.proto\x1a\x1egoo\
    gle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\
    \x19cosmos_proto/cosmos.proto\x1a\x1ecosmos/base/v1beta1/coin.proto\x1a\
    \x1ctendermint/types/types.proto\"\x89\x01\n\x0eHistoricalInfo\x126\n\
    \x06header\x18\x01\x20\x01(\x0b2\x18.tendermint.types.HeaderR\x06headerB\
    \x04\xc8\xde\x1f\0\x12?\n\x06valset\x18\x02\x20\x03(\x0b2!.cosmos.stakin\
    g.v1beta1.ValidatorR\x06valsetB\x04\xc8\xde\x1f\0\"\xaf\x02\n\x0fCommiss\
    ionRates\x12B\n\x04rate\x18\x01\x20\x01(\tR\x04rateB.\xda\xde\x1f&github\
    .com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\x12\\\n\x08max_rate\x18\
    \x02\x20\x01(\tR\x07maxRateBA\xf2\xde\x1f\x0fyaml:\"max_rate\"\xda\xde\
    \x1f&github.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\x12p\n\x0fmax_\
    change_rate\x18\x03\x20\x01(\tR\rmaxChangeRateBH\xf2\xde\x1f\x16yaml:\"m\
    ax_change_rate\"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Dec\xc8\
    \xde\x1f\0:\x08\xe8\xa0\x1f\x01\x98\xa0\x1f\0\"\xd1\x01\n\nCommission\
    \x12\\\n\x10commission_rates\x18\x01\x20\x01(\x0b2'.cosmos.staking.v1bet\
    a1.CommissionRatesR\x0fcommissionRatesB\x08\xc8\xde\x1f\0\xd0\xde\x1f\
    \x01\x12[\n\x0bupdate_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Tim\
    estampR\nupdateTimeB\x1e\xf2\xde\x1f\x12yaml:\"update_time\"\xc8\xde\x1f\
    \0\x90\xdf\x1f\x01:\x08\xe8\xa0\x1f\x01\x98\xa0\x1f\0\"\xc9\x01\n\x0bDes\
    cription\x12\x18\n\x07moniker\x18\x01\x20\x01(\tR\x07moniker\x12\x1a\n\
    \x08identity\x18\x02\x20\x01(\tR\x08identity\x12\x18\n\x07website\x18\
    \x03\x20\x01(\tR\x07website\x12F\n\x10security_contact\x18\x04\x20\x01(\
    \tR\x0fsecurityContactB\x1b\xf2\xde\x1f\x17yaml:\"security_contact\"\x12\
    \x18\n\x07details\x18\x05\x20\x01(\tR\x07details:\x08\xe8\xa0\x1f\x01\
    \x98\xa0\x1f\0\"\xac\x07\n\tValidator\x12F\n\x10operator_address\x18\x01\
    \x20\x01(\tR\x0foperatorAddressB\x1b\xf2\xde\x1f\x17yaml:\"operator_addr\
    ess\"\x12t\n\x10consensus_pubkey\x18\x02\x20\x01(\x0b2\x14.google.protob\
    uf.AnyR\x0fconsensusPubkeyB3\xf2\xde\x1f\x17yaml:\"consensus_pubkey\"\
    \xca\xb4-\x14cosmos.crypto.PubKey\x12\x16\n\x06jailed\x18\x03\x20\x01(\
    \x08R\x06jailed\x12:\n\x06status\x18\x04\x20\x01(\x0e2\".cosmos.staking.\
    v1beta1.BondStatusR\x06status\x12F\n\x06tokens\x18\x05\x20\x01(\tR\x06to\
    kensB.\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\xc8\xde\x1f\0\
    \x12t\n\x10delegator_shares\x18\x06\x20\x01(\tR\x0fdelegatorSharesBI\xf2\
    \xde\x1f\x17yaml:\"delegator_shares\"\xda\xde\x1f&github.com/cosmos/cosm\
    os-sdk/types.Dec\xc8\xde\x1f\0\x12K\n\x0bdescription\x18\x07\x20\x01(\
    \x0b2#.cosmos.staking.v1beta1.DescriptionR\x0bdescriptionB\x04\xc8\xde\
    \x1f\0\x12F\n\x10unbonding_height\x18\x08\x20\x01(\x03R\x0funbondingHeig\
    htB\x1b\xf2\xde\x1f\x17yaml:\"unbonding_height\"\x12d\n\x0eunbonding_tim\
    e\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\runbondingTimeB!\
    \xf2\xde\x1f\x15yaml:\"unbonding_time\"\xc8\xde\x1f\0\x90\xdf\x1f\x01\
    \x12H\n\ncommission\x18\n\x20\x01(\x0b2\".cosmos.staking.v1beta1.Commiss\
    ionR\ncommissionB\x04\xc8\xde\x1f\0\x12|\n\x13min_self_delegation\x18\
    \x0b\x20\x01(\tR\x11minSelfDelegationBL\xf2\xde\x1f\x1ayaml:\"min_self_d\
    elegation\"\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\xc8\xde\
    \x1f\0:\x0c\x88\xa0\x1f\0\xe8\xa0\x1f\0\x98\xa0\x1f\0\"6\n\x0cValAddress\
    es\x12\x1c\n\taddresses\x18\x01\x20\x03(\tR\taddresses:\x08\x80\xdc\x20\
    \x01\x98\xa0\x1f\0\"\xac\x01\n\x06DVPair\x12I\n\x11delegator_address\x18\
    \x01\x20\x01(\tR\x10delegatorAddressB\x1c\xf2\xde\x1f\x18yaml:\"delegato\
    r_address\"\x12I\n\x11validator_address\x18\x02\x20\x01(\tR\x10validator\
    AddressB\x1c\xf2\xde\x1f\x18yaml:\"validator_address\":\x0c\x88\xa0\x1f\
    \0\xe8\xa0\x1f\0\x98\xa0\x1f\0\"E\n\x07DVPairs\x12:\n\x05pairs\x18\x01\
    \x20\x03(\x0b2\x1e.cosmos.staking.v1beta1.DVPairR\x05pairsB\x04\xc8\xde\
    \x1f\0\"\x91\x02\n\nDVVTriplet\x12I\n\x11delegator_address\x18\x01\x20\
    \x01(\tR\x10delegatorAddressB\x1c\xf2\xde\x1f\x18yaml:\"delegator_addres\
    s\"\x12T\n\x15validator_src_address\x18\x02\x20\x01(\tR\x13validatorSrcA\
    ddressB\x20\xf2\xde\x1f\x1cyaml:\"validator_src_address\"\x12T\n\x15vali\
    dator_dst_address\x18\x03\x20\x01(\tR\x13validatorDstAddressB\x20\xf2\
    \xde\x1f\x1cyaml:\"validator_dst_address\":\x0c\x88\xa0\x1f\0\xe8\xa0\
    \x1f\0\x98\xa0\x1f\0\"S\n\x0bDVVTriplets\x12D\n\x08triplets\x18\x01\x20\
    \x03(\x0b2\".cosmos.staking.v1beta1.DVVTripletR\x08tripletsB\x04\xc8\xde\
    \x1f\0\"\xf8\x01\n\nDelegation\x12I\n\x11delegator_address\x18\x01\x20\
    \x01(\tR\x10delegatorAddressB\x1c\xf2\xde\x1f\x18yaml:\"delegator_addres\
    s\"\x12I\n\x11validator_address\x18\x02\x20\x01(\tR\x10validatorAddressB\
    \x1c\xf2\xde\x1f\x18yaml:\"validator_address\"\x12F\n\x06shares\x18\x03\
    \x20\x01(\tR\x06sharesB.\xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.\
    Dec\xc8\xde\x1f\0:\x0c\x88\xa0\x1f\0\xe8\xa0\x1f\0\x98\xa0\x1f\0\"\x8b\
    \x02\n\x13UnbondingDelegation\x12I\n\x11delegator_address\x18\x01\x20\
    \x01(\tR\x10delegatorAddressB\x1c\xf2\xde\x1f\x18yaml:\"delegator_addres\
    s\"\x12I\n\x11validator_address\x18\x02\x20\x01(\tR\x10validatorAddressB\
    \x1c\xf2\xde\x1f\x18yaml:\"validator_address\"\x12P\n\x07entries\x18\x03\
    \x20\x03(\x0b20.cosmos.staking.v1beta1.UnbondingDelegationEntryR\x07entr\
    iesB\x04\xc8\xde\x1f\0:\x0c\x88\xa0\x1f\0\xe8\xa0\x1f\0\x98\xa0\x1f\0\"\
    \x8f\x03\n\x18UnbondingDelegationEntry\x12C\n\x0fcreation_height\x18\x01\
    \x20\x01(\x03R\x0ecreationHeightB\x1a\xf2\xde\x1f\x16yaml:\"creation_hei\
    ght\"\x12g\n\x0fcompletion_time\x18\x02\x20\x01(\x0b2\x1a.google.protobu\
    f.TimestampR\x0ecompletionTimeB\"\xf2\xde\x1f\x16yaml:\"completion_time\
    \"\xc8\xde\x1f\0\x90\xdf\x1f\x01\x12q\n\x0finitial_balance\x18\x03\x20\
    \x01(\tR\x0einitialBalanceBH\xf2\xde\x1f\x16yaml:\"initial_balance\"\xda\
    \xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\xc8\xde\x1f\0\x12H\n\x07\
    balance\x18\x04\x20\x01(\tR\x07balanceB.\xda\xde\x1f&github.com/cosmos/c\
    osmos-sdk/types.Int\xc8\xde\x1f\0:\x08\xe8\xa0\x1f\x01\x98\xa0\x1f\0\"\
    \x8d\x03\n\x11RedelegationEntry\x12C\n\x0fcreation_height\x18\x01\x20\
    \x01(\x03R\x0ecreationHeightB\x1a\xf2\xde\x1f\x16yaml:\"creation_height\
    \"\x12g\n\x0fcompletion_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\x0ecompletionTimeB\"\xf2\xde\x1f\x16yaml:\"completion_time\"\
    \xc8\xde\x1f\0\x90\xdf\x1f\x01\x12q\n\x0finitial_balance\x18\x03\x20\x01\
    (\tR\x0einitialBalanceBH\xf2\xde\x1f\x16yaml:\"initial_balance\"\xda\xde\
    \x1f&github.com/cosmos/cosmos-sdk/types.Int\xc8\xde\x1f\0\x12M\n\nshares\
    _dst\x18\x04\x20\x01(\tR\tsharesDstB.\xda\xde\x1f&github.com/cosmos/cosm\
    os-sdk/types.Dec\xc8\xde\x1f\0:\x08\xe8\xa0\x1f\x01\x98\xa0\x1f\0\"\xde\
    \x02\n\x0cRedelegation\x12I\n\x11delegator_address\x18\x01\x20\x01(\tR\
    \x10delegatorAddressB\x1c\xf2\xde\x1f\x18yaml:\"delegator_address\"\x12T\
    \n\x15validator_src_address\x18\x02\x20\x01(\tR\x13validatorSrcAddressB\
    \x20\xf2\xde\x1f\x1cyaml:\"validator_src_address\"\x12T\n\x15validator_d\
    st_address\x18\x03\x20\x01(\tR\x13validatorDstAddressB\x20\xf2\xde\x1f\
    \x1cyaml:\"validator_dst_address\"\x12I\n\x07entries\x18\x04\x20\x03(\
    \x0b2).cosmos.staking.v1beta1.RedelegationEntryR\x07entriesB\x04\xc8\xde\
    \x1f\0:\x0c\x88\xa0\x1f\0\xe8\xa0\x1f\0\x98\xa0\x1f\0\"\xf6\x02\n\x06Par\
    ams\x12c\n\x0eunbonding_time\x18\x01\x20\x01(\x0b2\x19.google.protobuf.D\
    urationR\runbondingTimeB!\xf2\xde\x1f\x15yaml:\"unbonding_time\"\xc8\xde\
    \x1f\0\x98\xdf\x1f\x01\x12@\n\x0emax_validators\x18\x02\x20\x01(\rR\rmax\
    ValidatorsB\x19\xf2\xde\x1f\x15yaml:\"max_validators\"\x127\n\x0bmax_ent\
    ries\x18\x03\x20\x01(\rR\nmaxEntriesB\x16\xf2\xde\x1f\x12yaml:\"max_entr\
    ies\"\x12L\n\x12historical_entries\x18\x04\x20\x01(\rR\x11historicalEntr\
    iesB\x1d\xf2\xde\x1f\x19yaml:\"historical_entries\"\x124\n\nbond_denom\
    \x18\x05\x20\x01(\tR\tbondDenomB\x15\xf2\xde\x1f\x11yaml:\"bond_denom\":\
    \x08\xe8\xa0\x1f\x01\x98\xa0\x1f\0\"\xa3\x01\n\x12DelegationResponse\x12\
    H\n\ndelegation\x18\x01\x20\x01(\x0b2\".cosmos.staking.v1beta1.Delegatio\
    nR\ndelegationB\x04\xc8\xde\x1f\0\x129\n\x07balance\x18\x02\x20\x01(\x0b\
    2\x19.cosmos.base.v1beta1.CoinR\x07balanceB\x04\xc8\xde\x1f\0:\x08\xe8\
    \xa0\x1f\0\x98\xa0\x1f\0\"\xcb\x01\n\x19RedelegationEntryResponse\x12^\n\
    \x12redelegation_entry\x18\x01\x20\x01(\x0b2).cosmos.staking.v1beta1.Red\
    elegationEntryR\x11redelegationEntryB\x04\xc8\xde\x1f\0\x12H\n\x07balanc\
    e\x18\x04\x20\x01(\tR\x07balanceB.\xda\xde\x1f&github.com/cosmos/cosmos-\
    sdk/types.Int\xc8\xde\x1f\0:\x04\xe8\xa0\x1f\x01\"\xbf\x01\n\x14Redelega\
    tionResponse\x12N\n\x0credelegation\x18\x01\x20\x01(\x0b2$.cosmos.stakin\
    g.v1beta1.RedelegationR\x0credelegationB\x04\xc8\xde\x1f\0\x12Q\n\x07ent\
    ries\x18\x02\x20\x03(\x0b21.cosmos.staking.v1beta1.RedelegationEntryResp\
    onseR\x07entriesB\x04\xc8\xde\x1f\0:\x04\xe8\xa0\x1f\0\"\xff\x01\n\x04Po\
    ol\x12o\n\x11not_bonded_tokens\x18\x01\x20\x01(\tR\x0fnotBondedTokensBC\
    \xda\xde\x1f&github.com/cosmos/cosmos-sdk/types.Int\xea\xde\x1f\x11not_b\
    onded_tokens\xc8\xde\x1f\0\x12|\n\rbonded_tokens\x18\x02\x20\x01(\tR\x0c\
    bondedTokensBW\xf2\xde\x1f\x14yaml:\"bonded_tokens\"\xda\xde\x1f&github.\
    com/cosmos/cosmos-sdk/types.Int\xea\xde\x1f\rbonded_tokens\xc8\xde\x1f\0\
    :\x08\xf0\xa0\x1f\x01\xe8\xa0\x1f\x01*\xb6\x01\n\nBondStatus\x12,\n\x17B\
    OND_STATUS_UNSPECIFIED\x10\0\x1a\x0f\x8a\x9d\x20\x0bUnspecified\x12&\n\
    \x14BOND_STATUS_UNBONDED\x10\x01\x1a\x0c\x8a\x9d\x20\x08Unbonded\x12(\n\
    \x15BOND_STATUS_UNBONDING\x10\x02\x1a\r\x8a\x9d\x20\tUnbonding\x12\"\n\
    \x12BOND_STATUS_BONDED\x10\x03\x1a\n\x8a\x9d\x20\x06Bonded\x1a\x04\x88\
    \xa3\x1e\0B.Z,github.com/cosmos/cosmos-sdk/x/staking/typesJ\xb4q\n\x07\
    \x12\x05\0\0\xcd\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x01\0\x1f\n\t\n\x02\x03\0\x12\x03\x03\0\x1e\n\t\n\x02\x03\x01\
    \x12\x03\x04\0#\n\t\n\x02\x03\x02\x12\x03\x05\0(\n\t\n\x02\x03\x03\x12\
    \x03\x06\0)\n\t\n\x02\x03\x04\x12\x03\x08\0#\n\t\n\x02\x03\x05\x12\x03\t\
    \0(\n\t\n\x02\x03\x06\x12\x03\n\0&\n\x08\n\x01\x08\x12\x03\x0c\0C\n\t\n\
    \x02\x08\x0b\x12\x03\x0c\0C\n\x84\x02\n\x02\x04\0\x12\x04\x12\0\x15\x01\
    \x1a\xf7\x01\x20HistoricalInfo\x20contains\x20header\x20and\x20validator\
    \x20information\x20for\x20a\x20given\x20block.\n\x20It\x20is\x20stored\
    \x20as\x20part\x20of\x20staking\x20module's\x20state,\x20which\x20persis\
    ts\x20the\x20`n`\x20most\n\x20recent\x20HistoricalInfo\n\x20(`n`\x20is\
    \x20set\x20by\x20the\x20staking\x20module's\x20`historical_entries`\x20p\
    arameter).\n\n\n\n\x03\x04\0\x01\x12\x03\x12\x08\x16\n\x0b\n\x04\x04\0\
    \x02\0\x12\x03\x13\x02D\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x13\x02\x19\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x13\x1a\x20\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x13#$\n\x0c\n\x05\x04\0\x02\0\x08\x12\x03\x13%C\n\x0f\n\x08\
    \x04\0\x02\0\x08\xe9\xfb\x03\x12\x03\x13&B\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x14\x02D\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x14\x02\n\n\x0c\n\
    \x05\x04\0\x02\x01\x06\x12\x03\x14\x0b\x14\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x14\x1a\x20\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x14#$\n\x0c\n\
    \x05\x04\0\x02\x01\x08\x12\x03\x14%C\n\x0f\n\x08\x04\0\x02\x01\x08\xe9\
    \xfb\x03\x12\x03\x14&B\nh\n\x02\x04\x01\x12\x04\x19\0+\x01\x1a\\\x20Comm\
    issionRates\x20defines\x20the\x20initial\x20commission\x20rates\x20to\
    \x20be\x20used\x20for\x20creating\n\x20a\x20validator.\n\n\n\n\x03\x04\
    \x01\x01\x12\x03\x19\x08\x17\n\n\n\x03\x04\x01\x07\x12\x03\x1a\x02-\n\r\
    \n\x06\x04\x01\x07\x8d\xf4\x03\x12\x03\x1a\x02-\n\n\n\x03\x04\x01\x07\
    \x12\x03\x1b\x02.\n\r\n\x06\x04\x01\x07\x83\xf4\x03\x12\x03\x1b\x02.\nP\
    \n\x04\x04\x01\x02\0\x12\x03\x1e\x02t\x1aC\x20rate\x20is\x20the\x20commi\
    ssion\x20rate\x20charged\x20to\x20delegators,\x20as\x20a\x20fraction.\n\
    \n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1e\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03\x1e\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1e\x10\
    \x11\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03\x1e\x12s\n\x0f\n\x08\x04\x01\
    \x02\0\x08\xeb\xfb\x03\x12\x03\x1e\x13T\n\x0f\n\x08\x04\x01\x02\0\x08\
    \xe9\xfb\x03\x12\x03\x1eVr\nl\n\x04\x04\x01\x02\x01\x12\x04\x20\x02$\x04\
    \x1a^\x20max_rate\x20defines\x20the\x20maximum\x20commission\x20rate\x20\
    which\x20validator\x20can\x20ever\x20charge,\x20as\x20a\x20fraction.\n\n\
    \x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x20\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03\x20\t\x11\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\
    \x20\x14\x15\n\r\n\x05\x04\x01\x02\x01\x08\x12\x04\x20\x16$\x03\n\x0f\n\
    \x08\x04\x01\x02\x01\x08\xee\xfb\x03\x12\x03!\x040\n\x0f\n\x08\x04\x01\
    \x02\x01\x08\xeb\xfb\x03\x12\x03\"\x04E\n\x0f\n\x08\x04\x01\x02\x01\x08\
    \xe9\xfb\x03\x12\x03#\x04\"\nn\n\x04\x04\x01\x02\x02\x12\x04&\x02*\x04\
    \x1a`\x20max_change_rate\x20defines\x20the\x20maximum\x20daily\x20increa\
    se\x20of\x20the\x20validator\x20commission,\x20as\x20a\x20fraction.\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x05\x12\x03&\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x03&\t\x18\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03&\x1b\x1c\
    \n\r\n\x05\x04\x01\x02\x02\x08\x12\x04&\x1d*\x03\n\x0f\n\x08\x04\x01\x02\
    \x02\x08\xee\xfb\x03\x12\x03'\x047\n\x0f\n\x08\x04\x01\x02\x02\x08\xeb\
    \xfb\x03\x12\x03(\x04E\n\x0f\n\x08\x04\x01\x02\x02\x08\xe9\xfb\x03\x12\
    \x03)\x04\"\nM\n\x02\x04\x02\x12\x04.\07\x01\x1aA\x20Commission\x20defin\
    es\x20commission\x20parameters\x20for\x20a\x20given\x20validator.\n\n\n\
    \n\x03\x04\x02\x01\x12\x03.\x08\x12\n\n\n\x03\x04\x02\x07\x12\x03/\x02-\
    \n\r\n\x06\x04\x02\x07\x8d\xf4\x03\x12\x03/\x02-\n\n\n\x03\x04\x02\x07\
    \x12\x030\x02.\n\r\n\x06\x04\x02\x07\x83\xf4\x03\x12\x030\x02.\ni\n\x04\
    \x04\x02\x02\0\x12\x033\x02`\x1a\\\x20commission_rates\x20defines\x20the\
    \x20initial\x20commission\x20rates\x20to\x20be\x20used\x20for\x20creatin\
    g\x20a\x20validator.\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x033\x02\x11\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x033\x12\"\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x033%&\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x033'_\n\x0f\n\x08\x04\
    \x02\x02\0\x08\xea\xfb\x03\x12\x033(@\n\x0f\n\x08\x04\x02\x02\0\x08\xe9\
    \xfb\x03\x12\x033B^\nM\n\x04\x04\x02\x02\x01\x12\x045\x026p\x1a?\x20upda\
    te_time\x20is\x20the\x20last\x20time\x20the\x20commission\x20rate\x20was\
    \x20changed.\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x035\x02\x1b\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x035\x1c'\n\x0c\n\x05\x04\x02\x02\x01\x03\
    \x12\x035*+\n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x036\x06o\n\x0f\n\x08\
    \x04\x02\x02\x01\x08\xe9\xfb\x03\x12\x036\x07#\n\x0f\n\x08\x04\x02\x02\
    \x01\x08\xf2\xfb\x03\x12\x036%?\n\x0f\n\x08\x04\x02\x02\x01\x08\xee\xfb\
    \x03\x12\x036An\n:\n\x02\x04\x03\x12\x04:\0H\x01\x1a.\x20Description\x20\
    defines\x20a\x20validator\x20description.\n\n\n\n\x03\x04\x03\x01\x12\
    \x03:\x08\x13\n\n\n\x03\x04\x03\x07\x12\x03;\x02-\n\r\n\x06\x04\x03\x07\
    \x8d\xf4\x03\x12\x03;\x02-\n\n\n\x03\x04\x03\x07\x12\x03<\x02.\n\r\n\x06\
    \x04\x03\x07\x83\xf4\x03\x12\x03<\x02.\nG\n\x04\x04\x03\x02\0\x12\x03?\
    \x02\x15\x1a:\x20moniker\x20defines\x20a\x20human-readable\x20name\x20fo\
    r\x20the\x20validator.\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03?\x02\x08\
    \n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03?\t\x10\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03?\x13\x14\nV\n\x04\x04\x03\x02\x01\x12\x03A\x02\x16\x1aI\x20\
    identity\x20defines\x20an\x20optional\x20identity\x20signature\x20(ex.\
    \x20UPort\x20or\x20Keybase).\n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03A\
    \x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03A\t\x11\n\x0c\n\x05\x04\
    \x03\x02\x01\x03\x12\x03A\x14\x15\n8\n\x04\x04\x03\x02\x02\x12\x03C\x02\
    \x15\x1a+\x20website\x20defines\x20an\x20optional\x20website\x20link.\n\
    \n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\x03\
    \x02\x02\x01\x12\x03C\t\x10\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03C\x13\
    \x14\nO\n\x04\x04\x03\x02\x03\x12\x03E\x02S\x1aB\x20security_contact\x20\
    defines\x20an\x20optional\x20email\x20for\x20security\x20contact.\n\n\
    \x0c\n\x05\x04\x03\x02\x03\x05\x12\x03E\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03E\t\x19\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03E\x1c\x1d\
    \n\x0c\n\x05\x04\x03\x02\x03\x08\x12\x03E\x1eR\n\x0f\n\x08\x04\x03\x02\
    \x03\x08\xee\xfb\x03\x12\x03E\x1fQ\n5\n\x04\x04\x03\x02\x04\x12\x03G\x02\
    \x15\x1a(\x20details\x20define\x20other\x20optional\x20details.\n\n\x0c\
    \n\x05\x04\x03\x02\x04\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\x03\x02\x04\
    \x01\x12\x03G\t\x10\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03G\x13\x14\n\
    \xb8\x04\n\x02\x04\x04\x12\x04R\0w\x01\x1a\xab\x04\x20Validator\x20defin\
    es\x20a\x20validator,\x20together\x20with\x20the\x20total\x20amount\x20o\
    f\x20the\n\x20Validator's\x20bond\x20shares\x20and\x20their\x20exchange\
    \x20rate\x20to\x20coins.\x20Slashing\x20results\x20in\n\x20a\x20decrease\
    \x20in\x20the\x20exchange\x20rate,\x20allowing\x20correct\x20calculation\
    \x20of\x20future\n\x20undelegations\x20without\x20iterating\x20over\x20d\
    elegators.\x20When\x20coins\x20are\x20delegated\x20to\n\x20this\x20valid\
    ator,\x20the\x20validator\x20is\x20credited\x20with\x20a\x20delegation\
    \x20whose\x20number\x20of\n\x20bond\x20shares\x20is\x20based\x20on\x20th\
    e\x20amount\x20of\x20coins\x20delegated\x20divided\x20by\x20the\x20curre\
    nt\n\x20exchange\x20rate.\x20Voting\x20power\x20can\x20be\x20calculated\
    \x20as\x20total\x20bonded\x20shares\n\x20multiplied\x20by\x20exchange\
    \x20rate.\n\n\n\n\x03\x04\x04\x01\x12\x03R\x08\x11\n\n\n\x03\x04\x04\x07\
    \x12\x03S\x02.\n\r\n\x06\x04\x04\x07\x8d\xf4\x03\x12\x03S\x02.\n\n\n\x03\
    \x04\x04\x07\x12\x03T\x02.\n\r\n\x06\x04\x04\x07\x83\xf4\x03\x12\x03T\
    \x02.\n\n\n\x03\x04\x04\x07\x12\x03U\x02.\n\r\n\x06\x04\x04\x07\x81\xf4\
    \x03\x12\x03U\x02.\nf\n\x04\x04\x04\x02\0\x12\x03X\x02S\x1aY\x20operator\
    _address\x20defines\x20the\x20address\x20of\x20the\x20validator's\x20ope\
    rator;\x20bech\x20encoded\x20in\x20JSON.\n\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03X\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03X\t\x19\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03X\x1c\x1d\n\x0c\n\x05\x04\x04\x02\0\x08\
    \x12\x03X\x1eR\n\x0f\n\x08\x04\x04\x02\0\x08\xee\xfb\x03\x12\x03X\x1fQ\n\
    a\n\x04\x04\x04\x02\x01\x12\x04Z\x02[v\x1aS\x20consensus_pubkey\x20is\
    \x20the\x20consensus\x20public\x20key\x20of\x20the\x20validator,\x20as\
    \x20a\x20Protobuf\x20Any.\n\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03Z\x02\
    \x15\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03Z\x16&\n\x0c\n\x05\x04\x04\
    \x02\x01\x03\x12\x03Z)*\n\x0c\n\x05\x04\x04\x02\x01\x08\x12\x03[\x06u\n\
    \x0f\n\x08\x04\x04\x02\x01\x08\xc9\xd6\x05\x12\x03[\x07@\n\x0f\n\x08\x04\
    \x04\x02\x01\x08\xee\xfb\x03\x12\x03[Bt\n^\n\x04\x04\x04\x02\x02\x12\x03\
    ]\x02\x12\x1aQ\x20jailed\x20defined\x20whether\x20the\x20validator\x20ha\
    s\x20been\x20jailed\x20from\x20bonded\x20status\x20or\x20not.\n\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03]\x02\x06\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03]\x07\r\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03]\x10\x11\nJ\
    \n\x04\x04\x04\x02\x03\x12\x03_\x02\x18\x1a=\x20status\x20is\x20the\x20v\
    alidator\x20status\x20(bonded/unbonding/unbonded).\n\n\x0c\n\x05\x04\x04\
    \x02\x03\x06\x12\x03_\x02\x0c\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03_\r\
    \x13\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03_\x16\x17\nJ\n\x04\x04\x04\
    \x02\x04\x12\x03a\x02v\x1a=\x20tokens\x20define\x20the\x20delegated\x20t\
    okens\x20(incl.\x20self-delegation).\n\n\x0c\n\x05\x04\x04\x02\x04\x05\
    \x12\x03a\x02\x08\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03a\t\x0f\n\x0c\n\
    \x05\x04\x04\x02\x04\x03\x12\x03a\x12\x13\n\x0c\n\x05\x04\x04\x02\x04\
    \x08\x12\x03a\x14u\n\x0f\n\x08\x04\x04\x02\x04\x08\xeb\xfb\x03\x12\x03a\
    \x15V\n\x0f\n\x08\x04\x04\x02\x04\x08\xe9\xfb\x03\x12\x03aXt\nY\n\x04\
    \x04\x04\x02\x05\x12\x04c\x02g\x04\x1aK\x20delegator_shares\x20defines\
    \x20total\x20shares\x20issued\x20to\x20a\x20validator's\x20delegators.\n\
    \n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03c\x02\x08\n\x0c\n\x05\x04\x04\
    \x02\x05\x01\x12\x03c\t\x19\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03c\x1c\
    \x1d\n\r\n\x05\x04\x04\x02\x05\x08\x12\x04c\x1eg\x03\n\x0f\n\x08\x04\x04\
    \x02\x05\x08\xee\xfb\x03\x12\x03d\x048\n\x0f\n\x08\x04\x04\x02\x05\x08\
    \xeb\xfb\x03\x12\x03e\x04E\n\x0f\n\x08\x04\x04\x02\x05\x08\xe9\xfb\x03\
    \x12\x03f\x04\"\nK\n\x04\x04\x04\x02\x06\x12\x03i\x02=\x1a>\x20descripti\
    on\x20defines\x20the\x20description\x20terms\x20for\x20the\x20validator.\
    \n\n\x0c\n\x05\x04\x04\x02\x06\x06\x12\x03i\x02\r\n\x0c\n\x05\x04\x04\
    \x02\x06\x01\x12\x03i\x0e\x19\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03i\
    \x1c\x1d\n\x0c\n\x05\x04\x04\x02\x06\x08\x12\x03i\x1e<\n\x0f\n\x08\x04\
    \x04\x02\x06\x08\xe9\xfb\x03\x12\x03i\x1f;\nn\n\x04\x04\x04\x02\x07\x12\
    \x03k\x02R\x1aa\x20unbonding_height\x20defines,\x20if\x20unbonding,\x20t\
    he\x20height\x20at\x20which\x20this\x20validator\x20has\x20begun\x20unbo\
    nding.\n\n\x0c\n\x05\x04\x04\x02\x07\x05\x12\x03k\x02\x07\n\x0c\n\x05\
    \x04\x04\x02\x07\x01\x12\x03k\x08\x18\n\x0c\n\x05\x04\x04\x02\x07\x03\
    \x12\x03k\x1b\x1c\n\x0c\n\x05\x04\x04\x02\x07\x08\x12\x03k\x1dQ\n\x0f\n\
    \x08\x04\x04\x02\x07\x08\xee\xfb\x03\x12\x03k\x1eP\nk\n\x04\x04\x04\x02\
    \x08\x12\x04m\x02ns\x1a]\x20unbonding_time\x20defines,\x20if\x20unbondin\
    g,\x20the\x20min\x20time\x20for\x20the\x20validator\x20to\x20complete\
    \x20unbonding.\n\n\x0c\n\x05\x04\x04\x02\x08\x06\x12\x03m\x02\x1b\n\x0c\
    \n\x05\x04\x04\x02\x08\x01\x12\x03m\x1c*\n\x0c\n\x05\x04\x04\x02\x08\x03\
    \x12\x03m-.\n\x0c\n\x05\x04\x04\x02\x08\x08\x12\x03n\x06r\n\x0f\n\x08\
    \x04\x04\x02\x08\x08\xe9\xfb\x03\x12\x03n\x07#\n\x0f\n\x08\x04\x04\x02\
    \x08\x08\xf2\xfb\x03\x12\x03n%?\n\x0f\n\x08\x04\x04\x02\x08\x08\xee\xfb\
    \x03\x12\x03nAq\n<\n\x04\x04\x04\x02\t\x12\x03p\x02<\x1a/\x20commission\
    \x20defines\x20the\x20commission\x20parameters.\n\n\x0c\n\x05\x04\x04\
    \x02\t\x06\x12\x03p\x02\x0c\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03p\r\x17\
    \n\x0c\n\x05\x04\x04\x02\t\x03\x12\x03p\x1a\x1c\n\x0c\n\x05\x04\x04\x02\
    \t\x08\x12\x03p\x1d;\n\x0f\n\x08\x04\x04\x02\t\x08\xe9\xfb\x03\x12\x03p\
    \x1e:\n]\n\x04\x04\x04\x02\n\x12\x04r\x02v\x04\x1aO\x20min_self_delegati\
    on\x20is\x20the\x20validator's\x20self\x20declared\x20minimum\x20self\
    \x20delegation.\n\n\x0c\n\x05\x04\x04\x02\n\x05\x12\x03r\x02\x08\n\x0c\n\
    \x05\x04\x04\x02\n\x01\x12\x03r\t\x1c\n\x0c\n\x05\x04\x04\x02\n\x03\x12\
    \x03r\x1f!\n\r\n\x05\x04\x04\x02\n\x08\x12\x04r\"v\x03\n\x0f\n\x08\x04\
    \x04\x02\n\x08\xee\xfb\x03\x12\x03s\x04;\n\x0f\n\x08\x04\x04\x02\n\x08\
    \xeb\xfb\x03\x12\x03t\x04E\n\x0f\n\x08\x04\x04\x02\n\x08\xe9\xfb\x03\x12\
    \x03u\x04\"\n7\n\x02\x05\0\x12\x05z\0\x85\x01\x01\x1a*\x20BondStatus\x20\
    is\x20the\x20status\x20of\x20a\x20validator.\n\n\n\n\x03\x05\0\x01\x12\
    \x03z\x05\x0f\n\n\n\x03\x05\0\x03\x12\x03{\x021\n\r\n\x06\x05\0\x03\xb1\
    \xe4\x03\x12\x03{\x021\n?\n\x04\x05\0\x02\0\x12\x03~\x02Q\x1a2\x20UNSPEC\
    IFIED\x20defines\x20an\x20invalid\x20validator\x20status.\n\n\x0c\n\x05\
    \x05\0\x02\0\x01\x12\x03~\x02\x19\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03~\
    \x1c\x1d\n\x0c\n\x05\x05\0\x02\0\x03\x12\x03~\x1eP\n\x0f\n\x08\x05\0\x02\
    \0\x03\xd1\x83\x04\x12\x03~\x1fO\n@\n\x04\x05\0\x02\x01\x12\x04\x80\x01\
    \x02K\x1a2\x20UNBONDED\x20defines\x20a\x20validator\x20that\x20is\x20not\
    \x20bonded.\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\x80\x01\x02\x16\n\r\n\
    \x05\x05\0\x02\x01\x02\x12\x04\x80\x01\x19\x1a\n\r\n\x05\x05\0\x02\x01\
    \x03\x12\x04\x80\x01\x1bJ\n\x10\n\x08\x05\0\x02\x01\x03\xd1\x83\x04\x12\
    \x04\x80\x01\x1cI\n@\n\x04\x05\0\x02\x02\x12\x04\x82\x01\x02M\x1a2\x20UN\
    BONDING\x20defines\x20a\x20validator\x20that\x20is\x20unbonding.\n\n\r\n\
    \x05\x05\0\x02\x02\x01\x12\x04\x82\x01\x02\x17\n\r\n\x05\x05\0\x02\x02\
    \x02\x12\x04\x82\x01\x1a\x1b\n\r\n\x05\x05\0\x02\x02\x03\x12\x04\x82\x01\
    \x1cL\n\x10\n\x08\x05\0\x02\x02\x03\xd1\x83\x04\x12\x04\x82\x01\x1dK\n:\
    \n\x04\x05\0\x02\x03\x12\x04\x84\x01\x02G\x1a,\x20BONDED\x20defines\x20a\
    \x20validator\x20that\x20is\x20bonded.\n\n\r\n\x05\x05\0\x02\x03\x01\x12\
    \x04\x84\x01\x02\x14\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\x84\x01\x17\x18\
    \n\r\n\x05\x05\0\x02\x03\x03\x12\x04\x84\x01\x19F\n\x10\n\x08\x05\0\x02\
    \x03\x03\xd1\x83\x04\x12\x04\x84\x01\x1aE\nK\n\x02\x04\x05\x12\x06\x88\
    \x01\0\x8d\x01\x01\x1a=\x20ValAddresses\x20defines\x20a\x20repeated\x20s\
    et\x20of\x20validator\x20addresses.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\
    \x88\x01\x08\x14\n\x0b\n\x03\x04\x05\x07\x12\x04\x89\x01\x02.\n\x0e\n\
    \x06\x04\x05\x07\x83\xf4\x03\x12\x04\x89\x01\x02.\n\x0b\n\x03\x04\x05\
    \x07\x12\x04\x8a\x01\x02-\n\x0e\n\x06\x04\x05\x07\xc0\x8b\x04\x12\x04\
    \x8a\x01\x02-\n\x0c\n\x04\x04\x05\x02\0\x12\x04\x8c\x01\x02\x20\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\x8c\x01\x02\n\n\r\n\x05\x04\x05\x02\0\x05\
    \x12\x04\x8c\x01\x0b\x11\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x8c\x01\x12\
    \x1b\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x8c\x01\x1e\x1f\n\xf9\x01\n\x02\
    \x04\x06\x12\x06\x92\x01\0\x99\x01\x01\x1a\xea\x01\x20DVPair\x20is\x20st\
    ruct\x20that\x20just\x20has\x20a\x20delegator-validator\x20pair\x20with\
    \x20no\x20other\x20data.\n\x20It\x20is\x20intended\x20to\x20be\x20used\
    \x20as\x20a\x20marshalable\x20pointer.\x20For\x20example,\x20a\x20DVPair\
    \x20can\n\x20be\x20used\x20to\x20construct\x20the\x20key\x20to\x20gettin\
    g\x20an\x20UnbondingDelegation\x20from\x20state.\n\n\x0b\n\x03\x04\x06\
    \x01\x12\x04\x92\x01\x08\x0e\n\x0b\n\x03\x04\x06\x07\x12\x04\x93\x01\x02\
    .\n\x0e\n\x06\x04\x06\x07\x8d\xf4\x03\x12\x04\x93\x01\x02.\n\x0b\n\x03\
    \x04\x06\x07\x12\x04\x94\x01\x02.\n\x0e\n\x06\x04\x06\x07\x81\xf4\x03\
    \x12\x04\x94\x01\x02.\n\x0b\n\x03\x04\x06\x07\x12\x04\x95\x01\x02.\n\x0e\
    \n\x06\x04\x06\x07\x83\xf4\x03\x12\x04\x95\x01\x02.\n\x0c\n\x04\x04\x06\
    \x02\0\x12\x04\x97\x01\x02U\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x97\x01\
    \x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x97\x01\t\x1a\n\r\n\x05\x04\
    \x06\x02\0\x03\x12\x04\x97\x01\x1d\x1e\n\r\n\x05\x04\x06\x02\0\x08\x12\
    \x04\x97\x01\x1fT\n\x10\n\x08\x04\x06\x02\0\x08\xee\xfb\x03\x12\x04\x97\
    \x01\x20S\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\x98\x01\x02U\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\x98\x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\x98\x01\t\x1a\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x98\x01\x1d\
    \x1e\n\r\n\x05\x04\x06\x02\x01\x08\x12\x04\x98\x01\x1fT\n\x10\n\x08\x04\
    \x06\x02\x01\x08\xee\xfb\x03\x12\x04\x98\x01\x20S\n;\n\x02\x04\x07\x12\
    \x06\x9c\x01\0\x9e\x01\x01\x1a-\x20DVPairs\x20defines\x20an\x20array\x20\
    of\x20DVPair\x20objects.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x9c\x01\x08\
    \x0f\n\x0c\n\x04\x04\x07\x02\0\x12\x04\x9d\x01\x02;\n\r\n\x05\x04\x07\
    \x02\0\x04\x12\x04\x9d\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\x9d\
    \x01\x0b\x11\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x9d\x01\x12\x17\n\r\n\
    \x05\x04\x07\x02\0\x03\x12\x04\x9d\x01\x1a\x1b\n\r\n\x05\x04\x07\x02\0\
    \x08\x12\x04\x9d\x01\x1c:\n\x10\n\x08\x04\x07\x02\0\x08\xe9\xfb\x03\x12\
    \x04\x9d\x01\x1d9\n\x87\x02\n\x02\x04\x08\x12\x06\xa4\x01\0\xac\x01\x01\
    \x1a\xf8\x01\x20DVVTriplet\x20is\x20struct\x20that\x20just\x20has\x20a\
    \x20delegator-validator-validator\x20triplet\n\x20with\x20no\x20other\
    \x20data.\x20It\x20is\x20intended\x20to\x20be\x20used\x20as\x20a\x20mars\
    halable\x20pointer.\x20For\n\x20example,\x20a\x20DVVTriplet\x20can\x20be\
    \x20used\x20to\x20construct\x20the\x20key\x20to\x20getting\x20a\n\x20Red\
    elegation\x20from\x20state.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xa4\x01\
    \x08\x12\n\x0b\n\x03\x04\x08\x07\x12\x04\xa5\x01\x02.\n\x0e\n\x06\x04\
    \x08\x07\x8d\xf4\x03\x12\x04\xa5\x01\x02.\n\x0b\n\x03\x04\x08\x07\x12\
    \x04\xa6\x01\x02.\n\x0e\n\x06\x04\x08\x07\x81\xf4\x03\x12\x04\xa6\x01\
    \x02.\n\x0b\n\x03\x04\x08\x07\x12\x04\xa7\x01\x02.\n\x0e\n\x06\x04\x08\
    \x07\x83\xf4\x03\x12\x04\xa7\x01\x02.\n\x0c\n\x04\x04\x08\x02\0\x12\x04\
    \xa9\x01\x02Y\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xa9\x01\x02\x08\n\r\n\
    \x05\x04\x08\x02\0\x01\x12\x04\xa9\x01\t\x1a\n\r\n\x05\x04\x08\x02\0\x03\
    \x12\x04\xa9\x01!\"\n\r\n\x05\x04\x08\x02\0\x08\x12\x04\xa9\x01#X\n\x10\
    \n\x08\x04\x08\x02\0\x08\xee\xfb\x03\x12\x04\xa9\x01$W\n\x0c\n\x04\x04\
    \x08\x02\x01\x12\x04\xaa\x01\x02]\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\
    \xaa\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xaa\x01\t\x1e\n\r\
    \n\x05\x04\x08\x02\x01\x03\x12\x04\xaa\x01!\"\n\r\n\x05\x04\x08\x02\x01\
    \x08\x12\x04\xaa\x01#\\\n\x10\n\x08\x04\x08\x02\x01\x08\xee\xfb\x03\x12\
    \x04\xaa\x01$[\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\xab\x01\x02]\n\r\n\
    \x05\x04\x08\x02\x02\x05\x12\x04\xab\x01\x02\x08\n\r\n\x05\x04\x08\x02\
    \x02\x01\x12\x04\xab\x01\t\x1e\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xab\
    \x01!\"\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\xab\x01#\\\n\x10\n\x08\x04\
    \x08\x02\x02\x08\xee\xfb\x03\x12\x04\xab\x01$[\nC\n\x02\x04\t\x12\x06\
    \xaf\x01\0\xb1\x01\x01\x1a5\x20DVVTriplets\x20defines\x20an\x20array\x20\
    of\x20DVVTriplet\x20objects.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xaf\x01\x08\
    \x13\n\x0c\n\x04\x04\t\x02\0\x12\x04\xb0\x01\x02B\n\r\n\x05\x04\t\x02\0\
    \x04\x12\x04\xb0\x01\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xb0\x01\x0b\
    \x15\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xb0\x01\x16\x1e\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\xb0\x01!\"\n\r\n\x05\x04\t\x02\0\x08\x12\x04\xb0\x01#\
    A\n\x10\n\x08\x04\t\x02\0\x08\xe9\xfb\x03\x12\x04\xb0\x01$@\n\xa9\x01\n\
    \x02\x04\n\x12\x06\xb6\x01\0\xc1\x01\x01\x1a\x9a\x01\x20Delegation\x20re\
    presents\x20the\x20bond\x20with\x20tokens\x20held\x20by\x20an\x20account\
    .\x20It\x20is\n\x20owned\x20by\x20one\x20delegator,\x20and\x20is\x20asso\
    ciated\x20with\x20the\x20voting\x20power\x20of\x20one\n\x20validator.\n\
    \n\x0b\n\x03\x04\n\x01\x12\x04\xb6\x01\x08\x12\n\x0b\n\x03\x04\n\x07\x12\
    \x04\xb7\x01\x02.\n\x0e\n\x06\x04\n\x07\x8d\xf4\x03\x12\x04\xb7\x01\x02.\
    \n\x0b\n\x03\x04\n\x07\x12\x04\xb8\x01\x02.\n\x0e\n\x06\x04\n\x07\x81\
    \xf4\x03\x12\x04\xb8\x01\x02.\n\x0b\n\x03\x04\n\x07\x12\x04\xb9\x01\x02.\
    \n\x0e\n\x06\x04\n\x07\x83\xf4\x03\x12\x04\xb9\x01\x02.\nQ\n\x04\x04\n\
    \x02\0\x12\x04\xbc\x01\x02U\x1aC\x20delegator_address\x20is\x20the\x20be\
    ch32-encoded\x20address\x20of\x20the\x20delegator.\n\n\r\n\x05\x04\n\x02\
    \0\x05\x12\x04\xbc\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xbc\x01\
    \t\x1a\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xbc\x01\x1d\x1e\n\r\n\x05\x04\n\
    \x02\0\x08\x12\x04\xbc\x01\x1fT\n\x10\n\x08\x04\n\x02\0\x08\xee\xfb\x03\
    \x12\x04\xbc\x01\x20S\nQ\n\x04\x04\n\x02\x01\x12\x04\xbe\x01\x02U\x1aC\
    \x20validator_address\x20is\x20the\x20bech32-encoded\x20address\x20of\
    \x20the\x20validator.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xbe\x01\x02\
    \x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xbe\x01\t\x1a\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\xbe\x01\x1d\x1e\n\r\n\x05\x04\n\x02\x01\x08\x12\x04\
    \xbe\x01\x1fT\n\x10\n\x08\x04\n\x02\x01\x08\xee\xfb\x03\x12\x04\xbe\x01\
    \x20S\n=\n\x04\x04\n\x02\x02\x12\x04\xc0\x01\x02v\x1a/\x20shares\x20defi\
    ne\x20the\x20delegation\x20shares\x20received.\n\n\r\n\x05\x04\n\x02\x02\
    \x05\x12\x04\xc0\x01\x02\x08\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xc0\x01\
    \t\x0f\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xc0\x01\x12\x13\n\r\n\x05\x04\
    \n\x02\x02\x08\x12\x04\xc0\x01\x14u\n\x10\n\x08\x04\n\x02\x02\x08\xeb\
    \xfb\x03\x12\x04\xc0\x01\x15V\n\x10\n\x08\x04\n\x02\x02\x08\xe9\xfb\x03\
    \x12\x04\xc0\x01Xt\n\x87\x01\n\x02\x04\x0b\x12\x06\xc5\x01\0\xd0\x01\x01\
    \x1ay\x20UnbondingDelegation\x20stores\x20all\x20of\x20a\x20single\x20de\
    legator's\x20unbonding\x20bonds\n\x20for\x20a\x20single\x20validator\x20\
    in\x20an\x20time-ordered\x20list.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xc5\
    \x01\x08\x1b\n\x0b\n\x03\x04\x0b\x07\x12\x04\xc6\x01\x02.\n\x0e\n\x06\
    \x04\x0b\x07\x8d\xf4\x03\x12\x04\xc6\x01\x02.\n\x0b\n\x03\x04\x0b\x07\
    \x12\x04\xc7\x01\x02.\n\x0e\n\x06\x04\x0b\x07\x81\xf4\x03\x12\x04\xc7\
    \x01\x02.\n\x0b\n\x03\x04\x0b\x07\x12\x04\xc8\x01\x02.\n\x0e\n\x06\x04\
    \x0b\x07\x83\xf4\x03\x12\x04\xc8\x01\x02.\nQ\n\x04\x04\x0b\x02\0\x12\x04\
    \xcb\x01\x02U\x1aC\x20delegator_address\x20is\x20the\x20bech32-encoded\
    \x20address\x20of\x20the\x20delegator.\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\
    \x04\xcb\x01\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xcb\x01\t\x1a\n\
    \r\n\x05\x04\x0b\x02\0\x03\x12\x04\xcb\x01\x1d\x1e\n\r\n\x05\x04\x0b\x02\
    \0\x08\x12\x04\xcb\x01\x1fT\n\x10\n\x08\x04\x0b\x02\0\x08\xee\xfb\x03\
    \x12\x04\xcb\x01\x20S\nQ\n\x04\x04\x0b\x02\x01\x12\x04\xcd\x01\x02U\x1aC\
    \x20validator_address\x20is\x20the\x20bech32-encoded\x20address\x20of\
    \x20the\x20validator.\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xcd\x01\
    \x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xcd\x01\t\x1a\n\r\n\x05\
    \x04\x0b\x02\x01\x03\x12\x04\xcd\x01\x1d\x1e\n\r\n\x05\x04\x0b\x02\x01\
    \x08\x12\x04\xcd\x01\x1fT\n\x10\n\x08\x04\x0b\x02\x01\x08\xee\xfb\x03\
    \x12\x04\xcd\x01\x20S\n]\n\x04\x04\x0b\x02\x02\x12\x04\xcf\x01\x02O\x1a/\
    \x20entries\x20are\x20the\x20unbonding\x20delegation\x20entries.\n\"\x1e\
    \x20unbonding\x20delegation\x20entries\n\n\r\n\x05\x04\x0b\x02\x02\x04\
    \x12\x04\xcf\x01\x02\n\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xcf\x01\x0b\
    #\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xcf\x01$+\n\r\n\x05\x04\x0b\x02\
    \x02\x03\x12\x04\xcf\x01./\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\xcf\x01\
    0N\n\x10\n\x08\x04\x0b\x02\x02\x08\xe9\xfb\x03\x12\x04\xcf\x011M\n\\\n\
    \x02\x04\x0c\x12\x06\xd3\x01\0\xe4\x01\x01\x1aN\x20UnbondingDelegationEn\
    try\x20defines\x20an\x20unbonding\x20object\x20with\x20relevant\x20metad\
    ata.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xd3\x01\x08\x20\n\x0b\n\x03\x04\
    \x0c\x07\x12\x04\xd4\x01\x02-\n\x0e\n\x06\x04\x0c\x07\x8d\xf4\x03\x12\
    \x04\xd4\x01\x02-\n\x0b\n\x03\x04\x0c\x07\x12\x04\xd5\x01\x02.\n\x0e\n\
    \x06\x04\x0c\x07\x83\xf4\x03\x12\x04\xd5\x01\x02.\nM\n\x04\x04\x0c\x02\0\
    \x12\x04\xd8\x01\x02P\x1a?\x20creation_height\x20is\x20the\x20height\x20\
    which\x20the\x20unbonding\x20took\x20place.\n\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xd8\x01\x02\x07\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xd8\x01\
    \x08\x17\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xd8\x01\x1a\x1b\n\r\n\x05\
    \x04\x0c\x02\0\x08\x12\x04\xd8\x01\x1cO\n\x10\n\x08\x04\x0c\x02\0\x08\
    \xee\xfb\x03\x12\x04\xd8\x01\x1dN\nL\n\x04\x04\x0c\x02\x01\x12\x06\xda\
    \x01\x02\xdb\x01t\x1a<\x20completion_time\x20is\x20the\x20unix\x20time\
    \x20for\x20unbonding\x20completion.\n\n\r\n\x05\x04\x0c\x02\x01\x06\x12\
    \x04\xda\x01\x02\x1b\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xda\x01\x1c+\
    \n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xda\x01./\n\r\n\x05\x04\x0c\x02\
    \x01\x08\x12\x04\xdb\x01\x06s\n\x10\n\x08\x04\x0c\x02\x01\x08\xe9\xfb\
    \x03\x12\x04\xdb\x01\x07#\n\x10\n\x08\x04\x0c\x02\x01\x08\xf2\xfb\x03\
    \x12\x04\xdb\x01%?\n\x10\n\x08\x04\x0c\x02\x01\x08\xee\xfb\x03\x12\x04\
    \xdb\x01Ar\nb\n\x04\x04\x0c\x02\x02\x12\x06\xdd\x01\x02\xe1\x01\x04\x1aR\
    \x20initial_balance\x20defines\x20the\x20tokens\x20initially\x20schedule\
    d\x20to\x20receive\x20at\x20completion.\n\n\r\n\x05\x04\x0c\x02\x02\x05\
    \x12\x04\xdd\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xdd\x01\t\
    \x18\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xdd\x01\x1b\x1c\n\x0f\n\x05\
    \x04\x0c\x02\x02\x08\x12\x06\xdd\x01\x1d\xe1\x01\x03\n\x10\n\x08\x04\x0c\
    \x02\x02\x08\xeb\xfb\x03\x12\x04\xde\x01\x04E\n\x10\n\x08\x04\x0c\x02\
    \x02\x08\xe9\xfb\x03\x12\x04\xdf\x01\x04\"\n\x10\n\x08\x04\x0c\x02\x02\
    \x08\xee\xfb\x03\x12\x04\xe0\x01\x047\nD\n\x04\x04\x0c\x02\x03\x12\x04\
    \xe3\x01\x02w\x1a6\x20balance\x20defines\x20the\x20tokens\x20to\x20recei\
    ve\x20at\x20completion.\n\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xe3\x01\
    \x02\x08\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xe3\x01\t\x10\n\r\n\x05\
    \x04\x0c\x02\x03\x03\x12\x04\xe3\x01\x13\x14\n\r\n\x05\x04\x0c\x02\x03\
    \x08\x12\x04\xe3\x01\x15v\n\x10\n\x08\x04\x0c\x02\x03\x08\xeb\xfb\x03\
    \x12\x04\xe3\x01\x16W\n\x10\n\x08\x04\x0c\x02\x03\x08\xe9\xfb\x03\x12\
    \x04\xe3\x01Yu\nW\n\x02\x04\r\x12\x06\xe7\x01\0\xf9\x01\x01\x1aI\x20Rede\
    legationEntry\x20defines\x20a\x20redelegation\x20object\x20with\x20relev\
    ant\x20metadata.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xe7\x01\x08\x19\n\x0b\n\
    \x03\x04\r\x07\x12\x04\xe8\x01\x02-\n\x0e\n\x06\x04\r\x07\x8d\xf4\x03\
    \x12\x04\xe8\x01\x02-\n\x0b\n\x03\x04\r\x07\x12\x04\xe9\x01\x02.\n\x0e\n\
    \x06\x04\r\x07\x83\xf4\x03\x12\x04\xe9\x01\x02.\nV\n\x04\x04\r\x02\0\x12\
    \x04\xec\x01\x02P\x1aH\x20creation_height\x20\x20defines\x20the\x20heigh\
    t\x20which\x20the\x20redelegation\x20took\x20place.\n\n\r\n\x05\x04\r\
    \x02\0\x05\x12\x04\xec\x01\x02\x07\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xec\
    \x01\x08\x17\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xec\x01\x1a\x1b\n\r\n\x05\
    \x04\r\x02\0\x08\x12\x04\xec\x01\x1cO\n\x10\n\x08\x04\r\x02\0\x08\xee\
    \xfb\x03\x12\x04\xec\x01\x1dN\nT\n\x04\x04\r\x02\x01\x12\x06\xee\x01\x02\
    \xef\x01t\x1aD\x20completion_time\x20defines\x20the\x20unix\x20time\x20f\
    or\x20redelegation\x20completion.\n\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\
    \xee\x01\x02\x1b\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xee\x01\x1c+\n\r\n\
    \x05\x04\r\x02\x01\x03\x12\x04\xee\x01./\n\r\n\x05\x04\r\x02\x01\x08\x12\
    \x04\xef\x01\x06s\n\x10\n\x08\x04\r\x02\x01\x08\xe9\xfb\x03\x12\x04\xef\
    \x01\x07#\n\x10\n\x08\x04\r\x02\x01\x08\xf2\xfb\x03\x12\x04\xef\x01%?\n\
    \x10\n\x08\x04\r\x02\x01\x08\xee\xfb\x03\x12\x04\xef\x01Ar\nX\n\x04\x04\
    \r\x02\x02\x12\x06\xf1\x01\x02\xf5\x01\x04\x1aH\x20initial_balance\x20de\
    fines\x20the\x20initial\x20balance\x20when\x20redelegation\x20started.\n\
    \n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xf1\x01\x02\x08\n\r\n\x05\x04\r\x02\
    \x02\x01\x12\x04\xf1\x01\t\x18\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xf1\
    \x01\x1b\x1c\n\x0f\n\x05\x04\r\x02\x02\x08\x12\x06\xf1\x01\x1d\xf5\x01\
    \x03\n\x10\n\x08\x04\r\x02\x02\x08\xeb\xfb\x03\x12\x04\xf2\x01\x04E\n\
    \x10\n\x08\x04\r\x02\x02\x08\xe9\xfb\x03\x12\x04\xf3\x01\x04\"\n\x10\n\
    \x08\x04\r\x02\x02\x08\xee\xfb\x03\x12\x04\xf4\x01\x047\nc\n\x04\x04\r\
    \x02\x03\x12\x06\xf7\x01\x02\xf8\x01h\x1aS\x20shares_dst\x20is\x20the\
    \x20amount\x20of\x20destination-validator\x20shares\x20created\x20by\x20\
    redelegation.\n\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xf7\x01\x02\x08\n\r\
    \n\x05\x04\r\x02\x03\x01\x12\x04\xf7\x01\t\x13\n\r\n\x05\x04\r\x02\x03\
    \x03\x12\x04\xf7\x01\x16\x17\n\r\n\x05\x04\r\x02\x03\x08\x12\x04\xf8\x01\
    \x06g\n\x10\n\x08\x04\r\x02\x03\x08\xeb\xfb\x03\x12\x04\xf8\x01\x07H\n\
    \x10\n\x08\x04\r\x02\x03\x08\xe9\xfb\x03\x12\x04\xf8\x01Jf\n\xa9\x01\n\
    \x02\x04\x0e\x12\x06\xfd\x01\0\x8a\x02\x01\x1a\x9a\x01\x20Redelegation\
    \x20contains\x20the\x20list\x20of\x20a\x20particular\x20delegator's\x20r\
    edelegating\x20bonds\n\x20from\x20a\x20particular\x20source\x20validator\
    \x20to\x20a\x20particular\x20destination\x20validator.\n\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xfd\x01\x08\x14\n\x0b\n\x03\x04\x0e\x07\x12\x04\xfe\x01\
    \x02.\n\x0e\n\x06\x04\x0e\x07\x8d\xf4\x03\x12\x04\xfe\x01\x02.\n\x0b\n\
    \x03\x04\x0e\x07\x12\x04\xff\x01\x02.\n\x0e\n\x06\x04\x0e\x07\x81\xf4\
    \x03\x12\x04\xff\x01\x02.\n\x0b\n\x03\x04\x0e\x07\x12\x04\x80\x02\x02.\n\
    \x0e\n\x06\x04\x0e\x07\x83\xf4\x03\x12\x04\x80\x02\x02.\nQ\n\x04\x04\x0e\
    \x02\0\x12\x04\x83\x02\x02U\x1aC\x20delegator_address\x20is\x20the\x20be\
    ch32-encoded\x20address\x20of\x20the\x20delegator.\n\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\x83\x02\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \x83\x02\t\x1a\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x83\x02\x1d\x1e\n\r\n\
    \x05\x04\x0e\x02\0\x08\x12\x04\x83\x02\x1fT\n\x10\n\x08\x04\x0e\x02\0\
    \x08\xee\xfb\x03\x12\x04\x83\x02\x20S\n\\\n\x04\x04\x0e\x02\x01\x12\x04\
    \x85\x02\x02]\x1aN\x20validator_src_address\x20is\x20the\x20validator\
    \x20redelegation\x20source\x20operator\x20address.\n\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\x85\x02\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\x85\x02\t\x1e\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x85\x02!\"\n\r\
    \n\x05\x04\x0e\x02\x01\x08\x12\x04\x85\x02#\\\n\x10\n\x08\x04\x0e\x02\
    \x01\x08\xee\xfb\x03\x12\x04\x85\x02$[\na\n\x04\x04\x0e\x02\x02\x12\x04\
    \x87\x02\x02]\x1aS\x20validator_dst_address\x20is\x20the\x20validator\
    \x20redelegation\x20destination\x20operator\x20address.\n\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\x87\x02\x02\x08\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\x87\x02\t\x1e\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x87\x02!\"\
    \n\r\n\x05\x04\x0e\x02\x02\x08\x12\x04\x87\x02#\\\n\x10\n\x08\x04\x0e\
    \x02\x02\x08\xee\xfb\x03\x12\x04\x87\x02$[\nM\n\x04\x04\x0e\x02\x03\x12\
    \x04\x89\x02\x02H\x1a'\x20entries\x20are\x20the\x20redelegation\x20entri\
    es.\n\"\x16\x20redelegation\x20entries\n\n\r\n\x05\x04\x0e\x02\x03\x04\
    \x12\x04\x89\x02\x02\n\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\x89\x02\x0b\
    \x1c\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x89\x02\x1d$\n\r\n\x05\x04\
    \x0e\x02\x03\x03\x12\x04\x89\x02'(\n\r\n\x05\x04\x0e\x02\x03\x08\x12\x04\
    \x89\x02)G\n\x10\n\x08\x04\x0e\x02\x03\x08\xe9\xfb\x03\x12\x04\x89\x02*F\
    \nE\n\x02\x04\x0f\x12\x06\x8d\x02\0\x9c\x02\x01\x1a7\x20Params\x20define\
    s\x20the\x20parameters\x20for\x20the\x20staking\x20module.\n\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\x8d\x02\x08\x0e\n\x0b\n\x03\x04\x0f\x07\x12\x04\x8e\
    \x02\x02-\n\x0e\n\x06\x04\x0f\x07\x8d\xf4\x03\x12\x04\x8e\x02\x02-\n\x0b\
    \n\x03\x04\x0f\x07\x12\x04\x8f\x02\x02.\n\x0e\n\x06\x04\x0f\x07\x83\xf4\
    \x03\x12\x04\x8f\x02\x02.\nC\n\x04\x04\x0f\x02\0\x12\x06\x92\x02\x02\x93\
    \x02w\x1a3\x20unbonding_time\x20is\x20the\x20time\x20duration\x20of\x20u\
    nbonding.\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x92\x02\x02\x1a\n\r\n\
    \x05\x04\x0f\x02\0\x01\x12\x04\x92\x02\x1b)\n\r\n\x05\x04\x0f\x02\0\x03\
    \x12\x04\x92\x02,-\n\r\n\x05\x04\x0f\x02\0\x08\x12\x04\x93\x02\x06v\n\
    \x10\n\x08\x04\x0f\x02\0\x08\xe9\xfb\x03\x12\x04\x93\x02\x07#\n\x10\n\
    \x08\x04\x0f\x02\0\x08\xf3\xfb\x03\x12\x04\x93\x02%C\n\x10\n\x08\x04\x0f\
    \x02\0\x08\xee\xfb\x03\x12\x04\x93\x02Eu\nC\n\x04\x04\x0f\x02\x01\x12\
    \x04\x95\x02\x02O\x1a5\x20max_validators\x20is\x20the\x20maximum\x20numb\
    er\x20of\x20validators.\n\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x95\x02\
    \x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x95\x02\t\x17\n\r\n\x05\
    \x04\x0f\x02\x01\x03\x12\x04\x95\x02\x1a\x1b\n\r\n\x05\x04\x0f\x02\x01\
    \x08\x12\x04\x95\x02\x1cN\n\x10\n\x08\x04\x0f\x02\x01\x08\xee\xfb\x03\
    \x12\x04\x95\x02\x1dM\no\n\x04\x04\x0f\x02\x02\x12\x04\x97\x02\x02I\x1aa\
    \x20max_entries\x20is\x20the\x20max\x20entries\x20for\x20either\x20unbon\
    ding\x20delegation\x20or\x20redelegation\x20(per\x20pair/trio).\n\n\r\n\
    \x05\x04\x0f\x02\x02\x05\x12\x04\x97\x02\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x02\x01\x12\x04\x97\x02\t\x14\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x97\
    \x02\x17\x18\n\r\n\x05\x04\x0f\x02\x02\x08\x12\x04\x97\x02\x19H\n\x10\n\
    \x08\x04\x0f\x02\x02\x08\xee\xfb\x03\x12\x04\x97\x02\x1aG\nR\n\x04\x04\
    \x0f\x02\x03\x12\x04\x99\x02\x02W\x1aD\x20historical_entries\x20is\x20th\
    e\x20number\x20of\x20historical\x20entries\x20to\x20persist.\n\n\r\n\x05\
    \x04\x0f\x02\x03\x05\x12\x04\x99\x02\x02\x08\n\r\n\x05\x04\x0f\x02\x03\
    \x01\x12\x04\x99\x02\t\x1b\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\x99\x02\
    \x1e\x1f\n\r\n\x05\x04\x0f\x02\x03\x08\x12\x04\x99\x02\x20V\n\x10\n\x08\
    \x04\x0f\x02\x03\x08\xee\xfb\x03\x12\x04\x99\x02!U\nB\n\x04\x04\x0f\x02\
    \x04\x12\x04\x9b\x02\x02G\x1a4\x20bond_denom\x20defines\x20the\x20bondab\
    le\x20coin\x20denomination.\n\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\x9b\
    \x02\x02\x08\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\x9b\x02\t\x13\n\r\n\
    \x05\x04\x0f\x02\x04\x03\x12\x04\x9b\x02\x16\x17\n\r\n\x05\x04\x0f\x02\
    \x04\x08\x12\x04\x9b\x02\x18F\n\x10\n\x08\x04\x0f\x02\x04\x08\xee\xfb\
    \x03\x12\x04\x9b\x02\x19E\n\xa5\x01\n\x02\x04\x10\x12\x06\xa0\x02\0\xa7\
    \x02\x01\x1a\x96\x01\x20DelegationResponse\x20is\x20equivalent\x20to\x20\
    Delegation\x20except\x20that\x20it\x20contains\x20a\n\x20balance\x20in\
    \x20addition\x20to\x20shares\x20which\x20is\x20more\x20suitable\x20for\
    \x20client\x20responses.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xa0\x02\x08\
    \x1a\n\x0b\n\x03\x04\x10\x07\x12\x04\xa1\x02\x02.\n\x0e\n\x06\x04\x10\
    \x07\x8d\xf4\x03\x12\x04\xa1\x02\x02.\n\x0b\n\x03\x04\x10\x07\x12\x04\
    \xa2\x02\x02.\n\x0e\n\x06\x04\x10\x07\x83\xf4\x03\x12\x04\xa2\x02\x02.\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\xa4\x02\x02;\n\r\n\x05\x04\x10\x02\0\
    \x06\x12\x04\xa4\x02\x02\x0c\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa4\x02\
    \r\x17\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa4\x02\x1a\x1b\n\r\n\x05\x04\
    \x10\x02\0\x08\x12\x04\xa4\x02\x1c:\n\x10\n\x08\x04\x10\x02\0\x08\xe9\
    \xfb\x03\x12\x04\xa4\x02\x1d9\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xa6\
    \x02\x02F\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xa6\x02\x02\x1a\n\r\n\
    \x05\x04\x10\x02\x01\x01\x12\x04\xa6\x02\x1b\"\n\r\n\x05\x04\x10\x02\x01\
    \x03\x12\x04\xa6\x02%&\n\r\n\x05\x04\x10\x02\x01\x08\x12\x04\xa6\x02'E\n\
    \x10\n\x08\x04\x10\x02\x01\x08\xe9\xfb\x03\x12\x04\xa6\x02(D\n\xb6\x01\n\
    \x02\x04\x11\x12\x06\xac\x02\0\xb1\x02\x01\x1a\xa7\x01\x20RedelegationEn\
    tryResponse\x20is\x20equivalent\x20to\x20a\x20RedelegationEntry\x20excep\
    t\x20that\x20it\n\x20contains\x20a\x20balance\x20in\x20addition\x20to\
    \x20shares\x20which\x20is\x20more\x20suitable\x20for\x20client\n\x20resp\
    onses.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xac\x02\x08!\n\x0b\n\x03\x04\
    \x11\x07\x12\x04\xad\x02\x02\"\n\x0e\n\x06\x04\x11\x07\x8d\xf4\x03\x12\
    \x04\xad\x02\x02\"\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xaf\x02\x02J\n\r\n\
    \x05\x04\x11\x02\0\x06\x12\x04\xaf\x02\x02\x13\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xaf\x02\x14&\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xaf\x02)*\
    \n\r\n\x05\x04\x11\x02\0\x08\x12\x04\xaf\x02+I\n\x10\n\x08\x04\x11\x02\0\
    \x08\xe9\xfb\x03\x12\x04\xaf\x02,H\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\
    \xb0\x02\x02w\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xb0\x02\x02\x08\n\r\
    \n\x05\x04\x11\x02\x01\x01\x12\x04\xb0\x02\t\x10\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xb0\x02\x13\x14\n\r\n\x05\x04\x11\x02\x01\x08\x12\x04\
    \xb0\x02\x15v\n\x10\n\x08\x04\x11\x02\x01\x08\xeb\xfb\x03\x12\x04\xb0\
    \x02\x16W\n\x10\n\x08\x04\x11\x02\x01\x08\xe9\xfb\x03\x12\x04\xb0\x02Yu\
    \n\xb4\x01\n\x02\x04\x12\x12\x06\xb6\x02\0\xbb\x02\x01\x1a\xa5\x01\x20Re\
    delegationResponse\x20is\x20equivalent\x20to\x20a\x20Redelegation\x20exc\
    ept\x20that\x20its\x20entries\n\x20contain\x20a\x20balance\x20in\x20addi\
    tion\x20to\x20shares\x20which\x20is\x20more\x20suitable\x20for\x20client\
    \n\x20responses.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xb6\x02\x08\x1c\n\x0b\
    \n\x03\x04\x12\x07\x12\x04\xb7\x02\x02#\n\x0e\n\x06\x04\x12\x07\x8d\xf4\
    \x03\x12\x04\xb7\x02\x02#\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xb9\x02\x02U\
    \n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xb9\x02\x02\x0e\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\xb9\x02%1\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb9\x02\
    45\n\r\n\x05\x04\x12\x02\0\x08\x12\x04\xb9\x026T\n\x10\n\x08\x04\x12\x02\
    \0\x08\xe9\xfb\x03\x12\x04\xb9\x027S\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\
    \xba\x02\x02U\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xba\x02\x02\n\n\r\n\
    \x05\x04\x12\x02\x01\x06\x12\x04\xba\x02\x0b$\n\r\n\x05\x04\x12\x02\x01\
    \x01\x12\x04\xba\x02%,\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xba\x0245\n\
    \r\n\x05\x04\x12\x02\x01\x08\x12\x04\xba\x026T\n\x10\n\x08\x04\x12\x02\
    \x01\x08\xe9\xfb\x03\x12\x04\xba\x027S\ng\n\x02\x04\x13\x12\x06\xbf\x02\
    \0\xcd\x02\x01\x1aY\x20Pool\x20is\x20used\x20for\x20tracking\x20bonded\
    \x20and\x20not-bonded\x20token\x20supply\x20of\x20the\x20bond\n\x20denom\
    ination.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xbf\x02\x08\x0c\n\x0b\n\x03\
    \x04\x13\x07\x12\x04\xc0\x02\x02(\n\x0e\n\x06\x04\x13\x07\x8e\xf4\x03\
    \x12\x04\xc0\x02\x02(\n\x0b\n\x03\x04\x13\x07\x12\x04\xc1\x02\x02(\n\x0e\
    \n\x06\x04\x13\x07\x8d\xf4\x03\x12\x04\xc1\x02\x02(\n\x0e\n\x04\x04\x13\
    \x02\0\x12\x06\xc2\x02\x02\xc6\x02\x04\n\r\n\x05\x04\x13\x02\0\x05\x12\
    \x04\xc2\x02\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xc2\x02\t\x1a\n\
    \r\n\x05\x04\x13\x02\0\x03\x12\x04\xc2\x02#$\n\x0f\n\x05\x04\x13\x02\0\
    \x08\x12\x06\xc2\x02%\xc6\x02\x03\n\x10\n\x08\x04\x13\x02\0\x08\xeb\xfb\
    \x03\x12\x04\xc3\x02\x04E\n\x10\n\x08\x04\x13\x02\0\x08\xed\xfb\x03\x12\
    \x04\xc4\x02\x040\n\x10\n\x08\x04\x13\x02\0\x08\xe9\xfb\x03\x12\x04\xc5\
    \x02\x04\"\n\x0e\n\x04\x04\x13\x02\x01\x12\x06\xc7\x02\x02\xcc\x02\x04\n\
    \r\n\x05\x04\x13\x02\x01\x05\x12\x04\xc7\x02\x02\x08\n\r\n\x05\x04\x13\
    \x02\x01\x01\x12\x04\xc7\x02\t\x16\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\
    \xc7\x02\x19\x1a\n\x0f\n\x05\x04\x13\x02\x01\x08\x12\x06\xc7\x02\x1b\xcc\
    \x02\x03\n\x10\n\x08\x04\x13\x02\x01\x08\xed\xfb\x03\x12\x04\xc8\x02\x04\
    ,\n\x10\n\x08\x04\x13\x02\x01\x08\xeb\xfb\x03\x12\x04\xc9\x02\x04E\n\x10\
    \n\x08\x04\x13\x02\x01\x08\xe9\xfb\x03\x12\x04\xca\x02\x04\"\n\x10\n\x08\
    \x04\x13\x02\x01\x08\xee\xfb\x03\x12\x04\xcb\x02\x045b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(7);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::cosmos::file_descriptor().clone());
            deps.push(super::coin::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(20);
            messages.push(HistoricalInfo::generated_message_descriptor_data());
            messages.push(CommissionRates::generated_message_descriptor_data());
            messages.push(Commission::generated_message_descriptor_data());
            messages.push(Description::generated_message_descriptor_data());
            messages.push(Validator::generated_message_descriptor_data());
            messages.push(ValAddresses::generated_message_descriptor_data());
            messages.push(DVPair::generated_message_descriptor_data());
            messages.push(DVPairs::generated_message_descriptor_data());
            messages.push(DVVTriplet::generated_message_descriptor_data());
            messages.push(DVVTriplets::generated_message_descriptor_data());
            messages.push(Delegation::generated_message_descriptor_data());
            messages.push(UnbondingDelegation::generated_message_descriptor_data());
            messages.push(UnbondingDelegationEntry::generated_message_descriptor_data());
            messages.push(RedelegationEntry::generated_message_descriptor_data());
            messages.push(Redelegation::generated_message_descriptor_data());
            messages.push(Params::generated_message_descriptor_data());
            messages.push(DelegationResponse::generated_message_descriptor_data());
            messages.push(RedelegationEntryResponse::generated_message_descriptor_data());
            messages.push(RedelegationResponse::generated_message_descriptor_data());
            messages.push(Pool::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(BondStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
