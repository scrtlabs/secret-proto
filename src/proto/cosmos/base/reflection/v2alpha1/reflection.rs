// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos/base/reflection/v2alpha1/reflection.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  AppDescriptor describes a cosmos-sdk based application
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.AppDescriptor)
pub struct AppDescriptor {
    // message fields
    ///  AuthnDescriptor provides information on how to authenticate transactions on the application
    ///  NOTE: experimental and subject to change in future releases.
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.AppDescriptor.authn)
    pub authn: ::protobuf::MessageField<AuthnDescriptor>,
    ///  chain provides the chain descriptor
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.AppDescriptor.chain)
    pub chain: ::protobuf::MessageField<ChainDescriptor>,
    ///  codec provides metadata information regarding codec related types
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.AppDescriptor.codec)
    pub codec: ::protobuf::MessageField<CodecDescriptor>,
    ///  configuration provides metadata information regarding the sdk.Config type
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.AppDescriptor.configuration)
    pub configuration: ::protobuf::MessageField<ConfigurationDescriptor>,
    ///  query_services provides metadata information regarding the available queriable endpoints
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.AppDescriptor.query_services)
    pub query_services: ::protobuf::MessageField<QueryServicesDescriptor>,
    ///  tx provides metadata information regarding how to send transactions to the given application
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.AppDescriptor.tx)
    pub tx: ::protobuf::MessageField<TxDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.AppDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppDescriptor {
    fn default() -> &'a AppDescriptor {
        <AppDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl AppDescriptor {
    pub fn new() -> AppDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AuthnDescriptor>(
            "authn",
            |m: &AppDescriptor| { &m.authn },
            |m: &mut AppDescriptor| { &mut m.authn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ChainDescriptor>(
            "chain",
            |m: &AppDescriptor| { &m.chain },
            |m: &mut AppDescriptor| { &mut m.chain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CodecDescriptor>(
            "codec",
            |m: &AppDescriptor| { &m.codec },
            |m: &mut AppDescriptor| { &mut m.codec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigurationDescriptor>(
            "configuration",
            |m: &AppDescriptor| { &m.configuration },
            |m: &mut AppDescriptor| { &mut m.configuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QueryServicesDescriptor>(
            "query_services",
            |m: &AppDescriptor| { &m.query_services },
            |m: &mut AppDescriptor| { &mut m.query_services },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TxDescriptor>(
            "tx",
            |m: &AppDescriptor| { &m.tx },
            |m: &mut AppDescriptor| { &mut m.tx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppDescriptor>(
            "AppDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppDescriptor {
    const NAME: &'static str = "AppDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authn)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chain)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.codec)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configuration)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query_services)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tx)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.authn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.codec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.query_services.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.authn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.chain.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.codec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.configuration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.query_services.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.tx.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppDescriptor {
        AppDescriptor::new()
    }

    fn clear(&mut self) {
        self.authn.clear();
        self.chain.clear();
        self.codec.clear();
        self.configuration.clear();
        self.query_services.clear();
        self.tx.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppDescriptor {
        static instance: AppDescriptor = AppDescriptor {
            authn: ::protobuf::MessageField::none(),
            chain: ::protobuf::MessageField::none(),
            codec: ::protobuf::MessageField::none(),
            configuration: ::protobuf::MessageField::none(),
            query_services: ::protobuf::MessageField::none(),
            tx: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TxDescriptor describes the accepted transaction type
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.TxDescriptor)
pub struct TxDescriptor {
    // message fields
    ///  fullname is the protobuf fullname of the raw transaction type (for instance the tx.Tx type)
    ///  it is not meant to support polymorphism of transaction types, it is supposed to be used by
    ///  reflection clients to understand if they can handle a specific transaction type in an application.
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.TxDescriptor.fullname)
    pub fullname: ::std::string::String,
    ///  msgs lists the accepted application messages (sdk.Msg)
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.TxDescriptor.msgs)
    pub msgs: ::std::vec::Vec<MsgDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.TxDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TxDescriptor {
    fn default() -> &'a TxDescriptor {
        <TxDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl TxDescriptor {
    pub fn new() -> TxDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fullname",
            |m: &TxDescriptor| { &m.fullname },
            |m: &mut TxDescriptor| { &mut m.fullname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "msgs",
            |m: &TxDescriptor| { &m.msgs },
            |m: &mut TxDescriptor| { &mut m.msgs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TxDescriptor>(
            "TxDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TxDescriptor {
    const NAME: &'static str = "TxDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fullname = is.read_string()?;
                },
                18 => {
                    self.msgs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        for v in &self.msgs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TxDescriptor {
        TxDescriptor::new()
    }

    fn clear(&mut self) {
        self.fullname.clear();
        self.msgs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TxDescriptor {
        static instance: TxDescriptor = TxDescriptor {
            fullname: ::std::string::String::new(),
            msgs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TxDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TxDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TxDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  AuthnDescriptor provides information on how to sign transactions without relying
///  on the online RPCs GetTxMetadata and CombineUnsignedTxAndSignatures
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.AuthnDescriptor)
pub struct AuthnDescriptor {
    // message fields
    ///  sign_modes defines the supported signature algorithm
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.AuthnDescriptor.sign_modes)
    pub sign_modes: ::std::vec::Vec<SigningModeDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.AuthnDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthnDescriptor {
    fn default() -> &'a AuthnDescriptor {
        <AuthnDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl AuthnDescriptor {
    pub fn new() -> AuthnDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sign_modes",
            |m: &AuthnDescriptor| { &m.sign_modes },
            |m: &mut AuthnDescriptor| { &mut m.sign_modes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthnDescriptor>(
            "AuthnDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthnDescriptor {
    const NAME: &'static str = "AuthnDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sign_modes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sign_modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sign_modes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthnDescriptor {
        AuthnDescriptor::new()
    }

    fn clear(&mut self) {
        self.sign_modes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthnDescriptor {
        static instance: AuthnDescriptor = AuthnDescriptor {
            sign_modes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthnDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthnDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthnDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthnDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SigningModeDescriptor provides information on a signing flow of the application
///  NOTE(fdymylja): here we could go as far as providing an entire flow on how
///  to sign a message given a SigningModeDescriptor, but it's better to think about
///  this another time
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.SigningModeDescriptor)
pub struct SigningModeDescriptor {
    // message fields
    ///  name defines the unique name of the signing mode
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.SigningModeDescriptor.name)
    pub name: ::std::string::String,
    ///  number is the unique int32 identifier for the sign_mode enum
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.SigningModeDescriptor.number)
    pub number: i32,
    ///  authn_info_provider_method_fullname defines the fullname of the method to call to get
    ///  the metadata required to authenticate using the provided sign_modes
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.SigningModeDescriptor.authn_info_provider_method_fullname)
    pub authn_info_provider_method_fullname: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.SigningModeDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SigningModeDescriptor {
    fn default() -> &'a SigningModeDescriptor {
        <SigningModeDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl SigningModeDescriptor {
    pub fn new() -> SigningModeDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SigningModeDescriptor| { &m.name },
            |m: &mut SigningModeDescriptor| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &SigningModeDescriptor| { &m.number },
            |m: &mut SigningModeDescriptor| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "authn_info_provider_method_fullname",
            |m: &SigningModeDescriptor| { &m.authn_info_provider_method_fullname },
            |m: &mut SigningModeDescriptor| { &mut m.authn_info_provider_method_fullname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SigningModeDescriptor>(
            "SigningModeDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SigningModeDescriptor {
    const NAME: &'static str = "SigningModeDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.number = is.read_int32()?;
                },
                26 => {
                    self.authn_info_provider_method_fullname = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.number);
        }
        if !self.authn_info_provider_method_fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.authn_info_provider_method_fullname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.number != 0 {
            os.write_int32(2, self.number)?;
        }
        if !self.authn_info_provider_method_fullname.is_empty() {
            os.write_string(3, &self.authn_info_provider_method_fullname)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SigningModeDescriptor {
        SigningModeDescriptor::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.number = 0;
        self.authn_info_provider_method_fullname.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SigningModeDescriptor {
        static instance: SigningModeDescriptor = SigningModeDescriptor {
            name: ::std::string::String::new(),
            number: 0,
            authn_info_provider_method_fullname: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SigningModeDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SigningModeDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SigningModeDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SigningModeDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ChainDescriptor describes chain information of the application
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.ChainDescriptor)
pub struct ChainDescriptor {
    // message fields
    ///  id is the chain id
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.ChainDescriptor.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.ChainDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChainDescriptor {
    fn default() -> &'a ChainDescriptor {
        <ChainDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl ChainDescriptor {
    pub fn new() -> ChainDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ChainDescriptor| { &m.id },
            |m: &mut ChainDescriptor| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChainDescriptor>(
            "ChainDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChainDescriptor {
    const NAME: &'static str = "ChainDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChainDescriptor {
        ChainDescriptor::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChainDescriptor {
        static instance: ChainDescriptor = ChainDescriptor {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChainDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChainDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChainDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CodecDescriptor describes the registered interfaces and provides metadata information on the types
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.CodecDescriptor)
pub struct CodecDescriptor {
    // message fields
    ///  interfaces is a list of the registerted interfaces descriptors
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.CodecDescriptor.interfaces)
    pub interfaces: ::std::vec::Vec<InterfaceDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.CodecDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodecDescriptor {
    fn default() -> &'a CodecDescriptor {
        <CodecDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl CodecDescriptor {
    pub fn new() -> CodecDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interfaces",
            |m: &CodecDescriptor| { &m.interfaces },
            |m: &mut CodecDescriptor| { &mut m.interfaces },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodecDescriptor>(
            "CodecDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodecDescriptor {
    const NAME: &'static str = "CodecDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.interfaces.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.interfaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.interfaces {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodecDescriptor {
        CodecDescriptor::new()
    }

    fn clear(&mut self) {
        self.interfaces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodecDescriptor {
        static instance: CodecDescriptor = CodecDescriptor {
            interfaces: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodecDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodecDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodecDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodecDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  InterfaceDescriptor describes the implementation of an interface
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.InterfaceDescriptor)
pub struct InterfaceDescriptor {
    // message fields
    ///  fullname is the name of the interface
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.InterfaceDescriptor.fullname)
    pub fullname: ::std::string::String,
    ///  interface_accepting_messages contains information regarding the proto messages which contain the interface as
    ///  google.protobuf.Any field
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.InterfaceDescriptor.interface_accepting_messages)
    pub interface_accepting_messages: ::std::vec::Vec<InterfaceAcceptingMessageDescriptor>,
    ///  interface_implementers is a list of the descriptors of the interface implementers
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.InterfaceDescriptor.interface_implementers)
    pub interface_implementers: ::std::vec::Vec<InterfaceImplementerDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.InterfaceDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InterfaceDescriptor {
    fn default() -> &'a InterfaceDescriptor {
        <InterfaceDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceDescriptor {
    pub fn new() -> InterfaceDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fullname",
            |m: &InterfaceDescriptor| { &m.fullname },
            |m: &mut InterfaceDescriptor| { &mut m.fullname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interface_accepting_messages",
            |m: &InterfaceDescriptor| { &m.interface_accepting_messages },
            |m: &mut InterfaceDescriptor| { &mut m.interface_accepting_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interface_implementers",
            |m: &InterfaceDescriptor| { &m.interface_implementers },
            |m: &mut InterfaceDescriptor| { &mut m.interface_implementers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InterfaceDescriptor>(
            "InterfaceDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InterfaceDescriptor {
    const NAME: &'static str = "InterfaceDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fullname = is.read_string()?;
                },
                18 => {
                    self.interface_accepting_messages.push(is.read_message()?);
                },
                26 => {
                    self.interface_implementers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        for value in &self.interface_accepting_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.interface_implementers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        for v in &self.interface_accepting_messages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.interface_implementers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InterfaceDescriptor {
        InterfaceDescriptor::new()
    }

    fn clear(&mut self) {
        self.fullname.clear();
        self.interface_accepting_messages.clear();
        self.interface_implementers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InterfaceDescriptor {
        static instance: InterfaceDescriptor = InterfaceDescriptor {
            fullname: ::std::string::String::new(),
            interface_accepting_messages: ::std::vec::Vec::new(),
            interface_implementers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InterfaceDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InterfaceDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InterfaceDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  InterfaceImplementerDescriptor describes an interface implementer
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor)
pub struct InterfaceImplementerDescriptor {
    // message fields
    ///  fullname is the protobuf queryable name of the interface implementer
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor.fullname)
    pub fullname: ::std::string::String,
    ///  type_url defines the type URL used when marshalling the type as any
    ///  this is required so we can provide type safe google.protobuf.Any marshalling and
    ///  unmarshalling, making sure that we don't accept just 'any' type
    ///  in our interface fields
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor.type_url)
    pub type_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InterfaceImplementerDescriptor {
    fn default() -> &'a InterfaceImplementerDescriptor {
        <InterfaceImplementerDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceImplementerDescriptor {
    pub fn new() -> InterfaceImplementerDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fullname",
            |m: &InterfaceImplementerDescriptor| { &m.fullname },
            |m: &mut InterfaceImplementerDescriptor| { &mut m.fullname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_url",
            |m: &InterfaceImplementerDescriptor| { &m.type_url },
            |m: &mut InterfaceImplementerDescriptor| { &mut m.type_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InterfaceImplementerDescriptor>(
            "InterfaceImplementerDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InterfaceImplementerDescriptor {
    const NAME: &'static str = "InterfaceImplementerDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fullname = is.read_string()?;
                },
                18 => {
                    self.type_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        if !self.type_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        if !self.type_url.is_empty() {
            os.write_string(2, &self.type_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InterfaceImplementerDescriptor {
        InterfaceImplementerDescriptor::new()
    }

    fn clear(&mut self) {
        self.fullname.clear();
        self.type_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InterfaceImplementerDescriptor {
        static instance: InterfaceImplementerDescriptor = InterfaceImplementerDescriptor {
            fullname: ::std::string::String::new(),
            type_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InterfaceImplementerDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InterfaceImplementerDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InterfaceImplementerDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceImplementerDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  InterfaceAcceptingMessageDescriptor describes a protobuf message which contains
///  an interface represented as a google.protobuf.Any
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor)
pub struct InterfaceAcceptingMessageDescriptor {
    // message fields
    ///  fullname is the protobuf fullname of the type containing the interface
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor.fullname)
    pub fullname: ::std::string::String,
    ///  field_descriptor_names is a list of the protobuf name (not fullname) of the field
    ///  which contains the interface as google.protobuf.Any (the interface is the same, but
    ///  it can be in multiple fields of the same proto message)
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor.field_descriptor_names)
    pub field_descriptor_names: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InterfaceAcceptingMessageDescriptor {
    fn default() -> &'a InterfaceAcceptingMessageDescriptor {
        <InterfaceAcceptingMessageDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceAcceptingMessageDescriptor {
    pub fn new() -> InterfaceAcceptingMessageDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fullname",
            |m: &InterfaceAcceptingMessageDescriptor| { &m.fullname },
            |m: &mut InterfaceAcceptingMessageDescriptor| { &mut m.fullname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "field_descriptor_names",
            |m: &InterfaceAcceptingMessageDescriptor| { &m.field_descriptor_names },
            |m: &mut InterfaceAcceptingMessageDescriptor| { &mut m.field_descriptor_names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InterfaceAcceptingMessageDescriptor>(
            "InterfaceAcceptingMessageDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InterfaceAcceptingMessageDescriptor {
    const NAME: &'static str = "InterfaceAcceptingMessageDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fullname = is.read_string()?;
                },
                18 => {
                    self.field_descriptor_names.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        for value in &self.field_descriptor_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        for v in &self.field_descriptor_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InterfaceAcceptingMessageDescriptor {
        InterfaceAcceptingMessageDescriptor::new()
    }

    fn clear(&mut self) {
        self.fullname.clear();
        self.field_descriptor_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InterfaceAcceptingMessageDescriptor {
        static instance: InterfaceAcceptingMessageDescriptor = InterfaceAcceptingMessageDescriptor {
            fullname: ::std::string::String::new(),
            field_descriptor_names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InterfaceAcceptingMessageDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InterfaceAcceptingMessageDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InterfaceAcceptingMessageDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceAcceptingMessageDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConfigurationDescriptor contains metadata information on the sdk.Config
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.ConfigurationDescriptor)
pub struct ConfigurationDescriptor {
    // message fields
    ///  bech32_account_address_prefix is the account address prefix
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.ConfigurationDescriptor.bech32_account_address_prefix)
    pub bech32_account_address_prefix: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.ConfigurationDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigurationDescriptor {
    fn default() -> &'a ConfigurationDescriptor {
        <ConfigurationDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl ConfigurationDescriptor {
    pub fn new() -> ConfigurationDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bech32_account_address_prefix",
            |m: &ConfigurationDescriptor| { &m.bech32_account_address_prefix },
            |m: &mut ConfigurationDescriptor| { &mut m.bech32_account_address_prefix },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigurationDescriptor>(
            "ConfigurationDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigurationDescriptor {
    const NAME: &'static str = "ConfigurationDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bech32_account_address_prefix = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.bech32_account_address_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bech32_account_address_prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.bech32_account_address_prefix.is_empty() {
            os.write_string(1, &self.bech32_account_address_prefix)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigurationDescriptor {
        ConfigurationDescriptor::new()
    }

    fn clear(&mut self) {
        self.bech32_account_address_prefix.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigurationDescriptor {
        static instance: ConfigurationDescriptor = ConfigurationDescriptor {
            bech32_account_address_prefix: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigurationDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigurationDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigurationDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigurationDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.MsgDescriptor)
pub struct MsgDescriptor {
    // message fields
    ///  msg_type_url contains the TypeURL of a sdk.Msg.
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.MsgDescriptor.msg_type_url)
    pub msg_type_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.MsgDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgDescriptor {
    fn default() -> &'a MsgDescriptor {
        <MsgDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl MsgDescriptor {
    pub fn new() -> MsgDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_type_url",
            |m: &MsgDescriptor| { &m.msg_type_url },
            |m: &mut MsgDescriptor| { &mut m.msg_type_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgDescriptor>(
            "MsgDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgDescriptor {
    const NAME: &'static str = "MsgDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.msg_type_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.msg_type_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.msg_type_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.msg_type_url.is_empty() {
            os.write_string(1, &self.msg_type_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgDescriptor {
        MsgDescriptor::new()
    }

    fn clear(&mut self) {
        self.msg_type_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgDescriptor {
        static instance: MsgDescriptor = MsgDescriptor {
            msg_type_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAuthnDescriptorRequest is the request used for the GetAuthnDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest)
pub struct GetAuthnDescriptorRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthnDescriptorRequest {
    fn default() -> &'a GetAuthnDescriptorRequest {
        <GetAuthnDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthnDescriptorRequest {
    pub fn new() -> GetAuthnDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAuthnDescriptorRequest>(
            "GetAuthnDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAuthnDescriptorRequest {
    const NAME: &'static str = "GetAuthnDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthnDescriptorRequest {
        GetAuthnDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthnDescriptorRequest {
        static instance: GetAuthnDescriptorRequest = GetAuthnDescriptorRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAuthnDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAuthnDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAuthnDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthnDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAuthnDescriptorResponse is the response returned by the GetAuthnDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse)
pub struct GetAuthnDescriptorResponse {
    // message fields
    ///  authn describes how to authenticate to the application when sending transactions
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse.authn)
    pub authn: ::protobuf::MessageField<AuthnDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthnDescriptorResponse {
    fn default() -> &'a GetAuthnDescriptorResponse {
        <GetAuthnDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthnDescriptorResponse {
    pub fn new() -> GetAuthnDescriptorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AuthnDescriptor>(
            "authn",
            |m: &GetAuthnDescriptorResponse| { &m.authn },
            |m: &mut GetAuthnDescriptorResponse| { &mut m.authn },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAuthnDescriptorResponse>(
            "GetAuthnDescriptorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAuthnDescriptorResponse {
    const NAME: &'static str = "GetAuthnDescriptorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.authn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.authn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthnDescriptorResponse {
        GetAuthnDescriptorResponse::new()
    }

    fn clear(&mut self) {
        self.authn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthnDescriptorResponse {
        static instance: GetAuthnDescriptorResponse = GetAuthnDescriptorResponse {
            authn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAuthnDescriptorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAuthnDescriptorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAuthnDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthnDescriptorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetChainDescriptorRequest is the request used for the GetChainDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest)
pub struct GetChainDescriptorRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetChainDescriptorRequest {
    fn default() -> &'a GetChainDescriptorRequest {
        <GetChainDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetChainDescriptorRequest {
    pub fn new() -> GetChainDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetChainDescriptorRequest>(
            "GetChainDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetChainDescriptorRequest {
    const NAME: &'static str = "GetChainDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetChainDescriptorRequest {
        GetChainDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetChainDescriptorRequest {
        static instance: GetChainDescriptorRequest = GetChainDescriptorRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetChainDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetChainDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetChainDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetChainDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetChainDescriptorResponse is the response returned by the GetChainDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse)
pub struct GetChainDescriptorResponse {
    // message fields
    ///  chain describes application chain information
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse.chain)
    pub chain: ::protobuf::MessageField<ChainDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetChainDescriptorResponse {
    fn default() -> &'a GetChainDescriptorResponse {
        <GetChainDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetChainDescriptorResponse {
    pub fn new() -> GetChainDescriptorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ChainDescriptor>(
            "chain",
            |m: &GetChainDescriptorResponse| { &m.chain },
            |m: &mut GetChainDescriptorResponse| { &mut m.chain },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetChainDescriptorResponse>(
            "GetChainDescriptorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetChainDescriptorResponse {
    const NAME: &'static str = "GetChainDescriptorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chain)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chain.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetChainDescriptorResponse {
        GetChainDescriptorResponse::new()
    }

    fn clear(&mut self) {
        self.chain.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetChainDescriptorResponse {
        static instance: GetChainDescriptorResponse = GetChainDescriptorResponse {
            chain: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetChainDescriptorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetChainDescriptorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetChainDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetChainDescriptorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetCodecDescriptorRequest is the request used for the GetCodecDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest)
pub struct GetCodecDescriptorRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCodecDescriptorRequest {
    fn default() -> &'a GetCodecDescriptorRequest {
        <GetCodecDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCodecDescriptorRequest {
    pub fn new() -> GetCodecDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCodecDescriptorRequest>(
            "GetCodecDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCodecDescriptorRequest {
    const NAME: &'static str = "GetCodecDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCodecDescriptorRequest {
        GetCodecDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCodecDescriptorRequest {
        static instance: GetCodecDescriptorRequest = GetCodecDescriptorRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCodecDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCodecDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCodecDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCodecDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetCodecDescriptorResponse is the response returned by the GetCodecDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse)
pub struct GetCodecDescriptorResponse {
    // message fields
    ///  codec describes the application codec such as registered interfaces and implementations
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse.codec)
    pub codec: ::protobuf::MessageField<CodecDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCodecDescriptorResponse {
    fn default() -> &'a GetCodecDescriptorResponse {
        <GetCodecDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCodecDescriptorResponse {
    pub fn new() -> GetCodecDescriptorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CodecDescriptor>(
            "codec",
            |m: &GetCodecDescriptorResponse| { &m.codec },
            |m: &mut GetCodecDescriptorResponse| { &mut m.codec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCodecDescriptorResponse>(
            "GetCodecDescriptorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCodecDescriptorResponse {
    const NAME: &'static str = "GetCodecDescriptorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.codec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.codec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.codec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCodecDescriptorResponse {
        GetCodecDescriptorResponse::new()
    }

    fn clear(&mut self) {
        self.codec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCodecDescriptorResponse {
        static instance: GetCodecDescriptorResponse = GetCodecDescriptorResponse {
            codec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCodecDescriptorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCodecDescriptorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCodecDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCodecDescriptorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConfigurationDescriptorRequest is the request used for the GetConfigurationDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest)
pub struct GetConfigurationDescriptorRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConfigurationDescriptorRequest {
    fn default() -> &'a GetConfigurationDescriptorRequest {
        <GetConfigurationDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConfigurationDescriptorRequest {
    pub fn new() -> GetConfigurationDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConfigurationDescriptorRequest>(
            "GetConfigurationDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConfigurationDescriptorRequest {
    const NAME: &'static str = "GetConfigurationDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConfigurationDescriptorRequest {
        GetConfigurationDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConfigurationDescriptorRequest {
        static instance: GetConfigurationDescriptorRequest = GetConfigurationDescriptorRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConfigurationDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConfigurationDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConfigurationDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConfigurationDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConfigurationDescriptorResponse is the response returned by the GetConfigurationDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse)
pub struct GetConfigurationDescriptorResponse {
    // message fields
    ///  config describes the application's sdk.Config
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse.config)
    pub config: ::protobuf::MessageField<ConfigurationDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConfigurationDescriptorResponse {
    fn default() -> &'a GetConfigurationDescriptorResponse {
        <GetConfigurationDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetConfigurationDescriptorResponse {
    pub fn new() -> GetConfigurationDescriptorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigurationDescriptor>(
            "config",
            |m: &GetConfigurationDescriptorResponse| { &m.config },
            |m: &mut GetConfigurationDescriptorResponse| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConfigurationDescriptorResponse>(
            "GetConfigurationDescriptorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConfigurationDescriptorResponse {
    const NAME: &'static str = "GetConfigurationDescriptorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConfigurationDescriptorResponse {
        GetConfigurationDescriptorResponse::new()
    }

    fn clear(&mut self) {
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConfigurationDescriptorResponse {
        static instance: GetConfigurationDescriptorResponse = GetConfigurationDescriptorResponse {
            config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConfigurationDescriptorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConfigurationDescriptorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConfigurationDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConfigurationDescriptorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetQueryServicesDescriptorRequest is the request used for the GetQueryServicesDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest)
pub struct GetQueryServicesDescriptorRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetQueryServicesDescriptorRequest {
    fn default() -> &'a GetQueryServicesDescriptorRequest {
        <GetQueryServicesDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetQueryServicesDescriptorRequest {
    pub fn new() -> GetQueryServicesDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetQueryServicesDescriptorRequest>(
            "GetQueryServicesDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetQueryServicesDescriptorRequest {
    const NAME: &'static str = "GetQueryServicesDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetQueryServicesDescriptorRequest {
        GetQueryServicesDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetQueryServicesDescriptorRequest {
        static instance: GetQueryServicesDescriptorRequest = GetQueryServicesDescriptorRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetQueryServicesDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetQueryServicesDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetQueryServicesDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQueryServicesDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetQueryServicesDescriptorResponse is the response returned by the GetQueryServicesDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse)
pub struct GetQueryServicesDescriptorResponse {
    // message fields
    ///  queries provides information on the available queryable services
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse.queries)
    pub queries: ::protobuf::MessageField<QueryServicesDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetQueryServicesDescriptorResponse {
    fn default() -> &'a GetQueryServicesDescriptorResponse {
        <GetQueryServicesDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetQueryServicesDescriptorResponse {
    pub fn new() -> GetQueryServicesDescriptorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QueryServicesDescriptor>(
            "queries",
            |m: &GetQueryServicesDescriptorResponse| { &m.queries },
            |m: &mut GetQueryServicesDescriptorResponse| { &mut m.queries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetQueryServicesDescriptorResponse>(
            "GetQueryServicesDescriptorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetQueryServicesDescriptorResponse {
    const NAME: &'static str = "GetQueryServicesDescriptorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.queries)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queries.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.queries.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetQueryServicesDescriptorResponse {
        GetQueryServicesDescriptorResponse::new()
    }

    fn clear(&mut self) {
        self.queries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetQueryServicesDescriptorResponse {
        static instance: GetQueryServicesDescriptorResponse = GetQueryServicesDescriptorResponse {
            queries: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetQueryServicesDescriptorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetQueryServicesDescriptorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetQueryServicesDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQueryServicesDescriptorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetTxDescriptorRequest is the request used for the GetTxDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest)
pub struct GetTxDescriptorRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTxDescriptorRequest {
    fn default() -> &'a GetTxDescriptorRequest {
        <GetTxDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTxDescriptorRequest {
    pub fn new() -> GetTxDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTxDescriptorRequest>(
            "GetTxDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTxDescriptorRequest {
    const NAME: &'static str = "GetTxDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTxDescriptorRequest {
        GetTxDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTxDescriptorRequest {
        static instance: GetTxDescriptorRequest = GetTxDescriptorRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTxDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTxDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTxDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetTxDescriptorResponse is the response returned by the GetTxDescriptor RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse)
pub struct GetTxDescriptorResponse {
    // message fields
    ///  tx provides information on msgs that can be forwarded to the application
    ///  alongside the accepted transaction protobuf type
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse.tx)
    pub tx: ::protobuf::MessageField<TxDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTxDescriptorResponse {
    fn default() -> &'a GetTxDescriptorResponse {
        <GetTxDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTxDescriptorResponse {
    pub fn new() -> GetTxDescriptorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TxDescriptor>(
            "tx",
            |m: &GetTxDescriptorResponse| { &m.tx },
            |m: &mut GetTxDescriptorResponse| { &mut m.tx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTxDescriptorResponse>(
            "GetTxDescriptorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTxDescriptorResponse {
    const NAME: &'static str = "GetTxDescriptorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tx)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tx.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTxDescriptorResponse {
        GetTxDescriptorResponse::new()
    }

    fn clear(&mut self) {
        self.tx.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTxDescriptorResponse {
        static instance: GetTxDescriptorResponse = GetTxDescriptorResponse {
            tx: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTxDescriptorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTxDescriptorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTxDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxDescriptorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryServicesDescriptor contains the list of cosmos-sdk queriable services
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.QueryServicesDescriptor)
pub struct QueryServicesDescriptor {
    // message fields
    ///  query_services is a list of cosmos-sdk QueryServiceDescriptor
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.QueryServicesDescriptor.query_services)
    pub query_services: ::std::vec::Vec<QueryServiceDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.QueryServicesDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryServicesDescriptor {
    fn default() -> &'a QueryServicesDescriptor {
        <QueryServicesDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl QueryServicesDescriptor {
    pub fn new() -> QueryServicesDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "query_services",
            |m: &QueryServicesDescriptor| { &m.query_services },
            |m: &mut QueryServicesDescriptor| { &mut m.query_services },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryServicesDescriptor>(
            "QueryServicesDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryServicesDescriptor {
    const NAME: &'static str = "QueryServicesDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.query_services.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.query_services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.query_services {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryServicesDescriptor {
        QueryServicesDescriptor::new()
    }

    fn clear(&mut self) {
        self.query_services.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryServicesDescriptor {
        static instance: QueryServicesDescriptor = QueryServicesDescriptor {
            query_services: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryServicesDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryServicesDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryServicesDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryServicesDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryServiceDescriptor describes a cosmos-sdk queryable service
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.QueryServiceDescriptor)
pub struct QueryServiceDescriptor {
    // message fields
    ///  fullname is the protobuf fullname of the service descriptor
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.QueryServiceDescriptor.fullname)
    pub fullname: ::std::string::String,
    ///  is_module describes if this service is actually exposed by an application's module
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.QueryServiceDescriptor.is_module)
    pub is_module: bool,
    ///  methods provides a list of query service methods
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.QueryServiceDescriptor.methods)
    pub methods: ::std::vec::Vec<QueryMethodDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.QueryServiceDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryServiceDescriptor {
    fn default() -> &'a QueryServiceDescriptor {
        <QueryServiceDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl QueryServiceDescriptor {
    pub fn new() -> QueryServiceDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fullname",
            |m: &QueryServiceDescriptor| { &m.fullname },
            |m: &mut QueryServiceDescriptor| { &mut m.fullname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_module",
            |m: &QueryServiceDescriptor| { &m.is_module },
            |m: &mut QueryServiceDescriptor| { &mut m.is_module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "methods",
            |m: &QueryServiceDescriptor| { &m.methods },
            |m: &mut QueryServiceDescriptor| { &mut m.methods },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryServiceDescriptor>(
            "QueryServiceDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryServiceDescriptor {
    const NAME: &'static str = "QueryServiceDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fullname = is.read_string()?;
                },
                16 => {
                    self.is_module = is.read_bool()?;
                },
                26 => {
                    self.methods.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        if self.is_module != false {
            my_size += 1 + 1;
        }
        for value in &self.methods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        if self.is_module != false {
            os.write_bool(2, self.is_module)?;
        }
        for v in &self.methods {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryServiceDescriptor {
        QueryServiceDescriptor::new()
    }

    fn clear(&mut self) {
        self.fullname.clear();
        self.is_module = false;
        self.methods.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryServiceDescriptor {
        static instance: QueryServiceDescriptor = QueryServiceDescriptor {
            fullname: ::std::string::String::new(),
            is_module: false,
            methods: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryServiceDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryServiceDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryServiceDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryServiceDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryMethodDescriptor describes a queryable method of a query service
///  no other info is provided beside method name and tendermint queryable path
///  because it would be redundant with the grpc reflection service
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.reflection.v2alpha1.QueryMethodDescriptor)
pub struct QueryMethodDescriptor {
    // message fields
    ///  name is the protobuf name (not fullname) of the method
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.QueryMethodDescriptor.name)
    pub name: ::std::string::String,
    ///  full_query_path is the path that can be used to query
    ///  this method via tendermint abci.Query
    // @@protoc_insertion_point(field:cosmos.base.reflection.v2alpha1.QueryMethodDescriptor.full_query_path)
    pub full_query_path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.reflection.v2alpha1.QueryMethodDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryMethodDescriptor {
    fn default() -> &'a QueryMethodDescriptor {
        <QueryMethodDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl QueryMethodDescriptor {
    pub fn new() -> QueryMethodDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &QueryMethodDescriptor| { &m.name },
            |m: &mut QueryMethodDescriptor| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "full_query_path",
            |m: &QueryMethodDescriptor| { &m.full_query_path },
            |m: &mut QueryMethodDescriptor| { &mut m.full_query_path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryMethodDescriptor>(
            "QueryMethodDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryMethodDescriptor {
    const NAME: &'static str = "QueryMethodDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.full_query_path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.full_query_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.full_query_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.full_query_path.is_empty() {
            os.write_string(2, &self.full_query_path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryMethodDescriptor {
        QueryMethodDescriptor::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.full_query_path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryMethodDescriptor {
        static instance: QueryMethodDescriptor = QueryMethodDescriptor {
            name: ::std::string::String::new(),
            full_query_path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryMethodDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryMethodDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryMethodDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMethodDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n0cosmos/base/reflection/v2alpha1/reflection.proto\x12\x1fcosmos.base.r\
    eflection.v2alpha1\x1a\x1cgoogle/api/annotations.proto\"\xe7\x03\n\rAppD\
    escriptor\x12F\n\x05authn\x18\x01\x20\x01(\x0b20.cosmos.base.reflection.\
    v2alpha1.AuthnDescriptorR\x05authn\x12F\n\x05chain\x18\x02\x20\x01(\x0b2\
    0.cosmos.base.reflection.v2alpha1.ChainDescriptorR\x05chain\x12F\n\x05co\
    dec\x18\x03\x20\x01(\x0b20.cosmos.base.reflection.v2alpha1.CodecDescript\
    orR\x05codec\x12^\n\rconfiguration\x18\x04\x20\x01(\x0b28.cosmos.base.re\
    flection.v2alpha1.ConfigurationDescriptorR\rconfiguration\x12_\n\x0equer\
    y_services\x18\x05\x20\x01(\x0b28.cosmos.base.reflection.v2alpha1.QueryS\
    ervicesDescriptorR\rqueryServices\x12=\n\x02tx\x18\x06\x20\x01(\x0b2-.co\
    smos.base.reflection.v2alpha1.TxDescriptorR\x02tx\"n\n\x0cTxDescriptor\
    \x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\x12B\n\x04msgs\
    \x18\x02\x20\x03(\x0b2..cosmos.base.reflection.v2alpha1.MsgDescriptorR\
    \x04msgs\"h\n\x0fAuthnDescriptor\x12U\n\nsign_modes\x18\x01\x20\x03(\x0b\
    26.cosmos.base.reflection.v2alpha1.SigningModeDescriptorR\tsignModes\"\
    \x91\x01\n\x15SigningModeDescriptor\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x16\n\x06number\x18\x02\x20\x01(\x05R\x06number\x12L\n#aut\
    hn_info_provider_method_fullname\x18\x03\x20\x01(\tR\x1fauthnInfoProvide\
    rMethodFullname\"!\n\x0fChainDescriptor\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\"g\n\x0fCodecDescriptor\x12T\n\ninterfaces\x18\x01\x20\x03(\
    \x0b24.cosmos.base.reflection.v2alpha1.InterfaceDescriptorR\ninterfaces\
    \"\xb2\x02\n\x13InterfaceDescriptor\x12\x1a\n\x08fullname\x18\x01\x20\
    \x01(\tR\x08fullname\x12\x86\x01\n\x1cinterface_accepting_messages\x18\
    \x02\x20\x03(\x0b2D.cosmos.base.reflection.v2alpha1.InterfaceAcceptingMe\
    ssageDescriptorR\x1ainterfaceAcceptingMessages\x12v\n\x16interface_imple\
    menters\x18\x03\x20\x03(\x0b2?.cosmos.base.reflection.v2alpha1.Interface\
    ImplementerDescriptorR\x15interfaceImplementers\"W\n\x1eInterfaceImpleme\
    nterDescriptor\x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\x12\
    \x19\n\x08type_url\x18\x02\x20\x01(\tR\x07typeUrl\"w\n#InterfaceAcceptin\
    gMessageDescriptor\x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\
    \x124\n\x16field_descriptor_names\x18\x02\x20\x03(\tR\x14fieldDescriptor\
    Names\"\\\n\x17ConfigurationDescriptor\x12A\n\x1dbech32_account_address_\
    prefix\x18\x01\x20\x01(\tR\x1abech32AccountAddressPrefix\"1\n\rMsgDescri\
    ptor\x12\x20\n\x0cmsg_type_url\x18\x01\x20\x01(\tR\nmsgTypeUrl\"\x1b\n\
    \x19GetAuthnDescriptorRequest\"d\n\x1aGetAuthnDescriptorResponse\x12F\n\
    \x05authn\x18\x01\x20\x01(\x0b20.cosmos.base.reflection.v2alpha1.AuthnDe\
    scriptorR\x05authn\"\x1b\n\x19GetChainDescriptorRequest\"d\n\x1aGetChain\
    DescriptorResponse\x12F\n\x05chain\x18\x01\x20\x01(\x0b20.cosmos.base.re\
    flection.v2alpha1.ChainDescriptorR\x05chain\"\x1b\n\x19GetCodecDescripto\
    rRequest\"d\n\x1aGetCodecDescriptorResponse\x12F\n\x05codec\x18\x01\x20\
    \x01(\x0b20.cosmos.base.reflection.v2alpha1.CodecDescriptorR\x05codec\"#\
    \n!GetConfigurationDescriptorRequest\"v\n\"GetConfigurationDescriptorRes\
    ponse\x12P\n\x06config\x18\x01\x20\x01(\x0b28.cosmos.base.reflection.v2a\
    lpha1.ConfigurationDescriptorR\x06config\"#\n!GetQueryServicesDescriptor\
    Request\"x\n\"GetQueryServicesDescriptorResponse\x12R\n\x07queries\x18\
    \x01\x20\x01(\x0b28.cosmos.base.reflection.v2alpha1.QueryServicesDescrip\
    torR\x07queries\"\x18\n\x16GetTxDescriptorRequest\"X\n\x17GetTxDescripto\
    rResponse\x12=\n\x02tx\x18\x01\x20\x01(\x0b2-.cosmos.base.reflection.v2a\
    lpha1.TxDescriptorR\x02tx\"y\n\x17QueryServicesDescriptor\x12^\n\x0equer\
    y_services\x18\x01\x20\x03(\x0b27.cosmos.base.reflection.v2alpha1.QueryS\
    erviceDescriptorR\rqueryServices\"\xa3\x01\n\x16QueryServiceDescriptor\
    \x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\x12\x1b\n\tis_mod\
    ule\x18\x02\x20\x01(\x08R\x08isModule\x12P\n\x07methods\x18\x03\x20\x03(\
    \x0b26.cosmos.base.reflection.v2alpha1.QueryMethodDescriptorR\x07methods\
    \"S\n\x15QueryMethodDescriptor\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12&\n\x0ffull_query_path\x18\x02\x20\x01(\tR\rfullQueryPath2\xa7\n\
    \n\x11ReflectionService\x12\xcb\x01\n\x12GetAuthnDescriptor\x12:.cosmos.\
    base.reflection.v2alpha1.GetAuthnDescriptorRequest\x1a;.cosmos.base.refl\
    ection.v2alpha1.GetAuthnDescriptorResponse\"<\x82\xd3\xe4\x93\x026\x124/\
    cosmos/base/reflection/v1beta1/app_descriptor/authn\x12\xcb\x01\n\x12Get\
    ChainDescriptor\x12:.cosmos.base.reflection.v2alpha1.GetChainDescriptorR\
    equest\x1a;.cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse\"\
    <\x82\xd3\xe4\x93\x026\x124/cosmos/base/reflection/v1beta1/app_descripto\
    r/chain\x12\xcb\x01\n\x12GetCodecDescriptor\x12:.cosmos.base.reflection.\
    v2alpha1.GetCodecDescriptorRequest\x1a;.cosmos.base.reflection.v2alpha1.\
    GetCodecDescriptorResponse\"<\x82\xd3\xe4\x93\x026\x124/cosmos/base/refl\
    ection/v1beta1/app_descriptor/codec\x12\xeb\x01\n\x1aGetConfigurationDes\
    criptor\x12B.cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorR\
    equest\x1aC.cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRe\
    sponse\"D\x82\xd3\xe4\x93\x02>\x12</cosmos/base/reflection/v1beta1/app_d\
    escriptor/configuration\x12\xec\x01\n\x1aGetQueryServicesDescriptor\x12B\
    .cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest\x1aC.\
    cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse\"E\
    \x82\xd3\xe4\x93\x02?\x12=/cosmos/base/reflection/v1beta1/app_descriptor\
    /query_services\x12\xca\x01\n\x0fGetTxDescriptor\x127.cosmos.base.reflec\
    tion.v2alpha1.GetTxDescriptorRequest\x1a8.cosmos.base.reflection.v2alpha\
    1.GetTxDescriptorResponse\"D\x82\xd3\xe4\x93\x02>\x12</cosmos/base/refle\
    ction/v1beta1/app_descriptor/tx_descriptorB>Z<github.com/cosmos/cosmos-s\
    dk/server/grpc/reflection/v2alpha1J\x85M\n\x07\x12\x05\x01\0\xd9\x01\x01\
    \n\"\n\x01\x0c\x12\x03\x01\0\x12\x1a\x18\x20Since:\x20cosmos-sdk\x200.43\
    \n\n\x08\n\x01\x02\x12\x03\x02\0(\n\t\n\x02\x03\0\x12\x03\x04\0&\n\x08\n\
    \x01\x08\x12\x03\x06\0S\n\t\n\x02\x08\x0b\x12\x03\x06\0S\nD\n\x02\x04\0\
    \x12\x04\t\0\x17\x01\x1a8\x20AppDescriptor\x20describes\x20a\x20cosmos-s\
    dk\x20based\x20application\n\n\n\n\x03\x04\0\x01\x12\x03\t\x08\x15\n\xa9\
    \x01\n\x04\x04\0\x02\0\x12\x03\x0c\x02\x1c\x1a\x9b\x01\x20AuthnDescripto\
    r\x20provides\x20information\x20on\x20how\x20to\x20authenticate\x20trans\
    actions\x20on\x20the\x20application\n\x20NOTE:\x20experimental\x20and\
    \x20subject\x20to\x20change\x20in\x20future\x20releases.\n\n\x0c\n\x05\
    \x04\0\x02\0\x06\x12\x03\x0c\x02\x11\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x0c\x12\x17\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0c\x1a\x1b\n2\n\x04\
    \x04\0\x02\x01\x12\x03\x0e\x02\x1c\x1a%\x20chain\x20provides\x20the\x20c\
    hain\x20descriptor\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x0e\x02\x11\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0e\x12\x17\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x03\x0e\x1a\x1b\nP\n\x04\x04\0\x02\x02\x12\x03\x10\x02\x1c\
    \x1aC\x20codec\x20provides\x20metadata\x20information\x20regarding\x20co\
    dec\x20related\x20types\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x10\x02\
    \x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x10\x12\x17\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03\x10\x1a\x1b\nX\n\x04\x04\0\x02\x03\x12\x03\x12\x02,\
    \x1aK\x20configuration\x20provides\x20metadata\x20information\x20regardi\
    ng\x20the\x20sdk.Config\x20type\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\
    \x12\x02\x19\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x12\x1a'\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03\x12*+\ng\n\x04\x04\0\x02\x04\x12\x03\x14\x02-\
    \x1aZ\x20query_services\x20provides\x20metadata\x20information\x20regard\
    ing\x20the\x20available\x20queriable\x20endpoints\n\n\x0c\n\x05\x04\0\
    \x02\x04\x06\x12\x03\x14\x02\x19\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\
    \x14\x1a(\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x14+,\nk\n\x04\x04\0\x02\
    \x05\x12\x03\x16\x02\x16\x1a^\x20tx\x20provides\x20metadata\x20informati\
    on\x20regarding\x20how\x20to\x20send\x20transactions\x20to\x20the\x20giv\
    en\x20application\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\x16\x02\x0e\n\
    \x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x16\x0f\x11\n\x0c\n\x05\x04\0\x02\
    \x05\x03\x12\x03\x16\x14\x15\nB\n\x02\x04\x01\x12\x04\x1a\0!\x01\x1a6\
    \x20TxDescriptor\x20describes\x20the\x20accepted\x20transaction\x20type\
    \n\n\n\n\x03\x04\x01\x01\x12\x03\x1a\x08\x14\n\xab\x02\n\x04\x04\x01\x02\
    \0\x12\x03\x1e\x02\x16\x1a\x9d\x02\x20fullname\x20is\x20the\x20protobuf\
    \x20fullname\x20of\x20the\x20raw\x20transaction\x20type\x20(for\x20insta\
    nce\x20the\x20tx.Tx\x20type)\n\x20it\x20is\x20not\x20meant\x20to\x20supp\
    ort\x20polymorphism\x20of\x20transaction\x20types,\x20it\x20is\x20suppos\
    ed\x20to\x20be\x20used\x20by\n\x20reflection\x20clients\x20to\x20underst\
    and\x20if\x20they\x20can\x20handle\x20a\x20specific\x20transaction\x20ty\
    pe\x20in\x20an\x20application.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\
    \x1e\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1e\t\x11\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03\x1e\x14\x15\nE\n\x04\x04\x01\x02\x01\x12\x03\
    \x20\x02\"\x1a8\x20msgs\x20lists\x20the\x20accepted\x20application\x20me\
    ssages\x20(sdk.Msg)\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x20\x02\n\
    \n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x20\x0b\x18\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03\x20\x19\x1d\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\
    \x20\x20!\n\xa4\x01\n\x02\x04\x02\x12\x04%\0(\x01\x1a\x97\x01\x20AuthnDe\
    scriptor\x20provides\x20information\x20on\x20how\x20to\x20sign\x20transa\
    ctions\x20without\x20relying\n\x20on\x20the\x20online\x20RPCs\x20GetTxMe\
    tadata\x20and\x20CombineUnsignedTxAndSignatures\n\n\n\n\x03\x04\x02\x01\
    \x12\x03%\x08\x17\nC\n\x04\x04\x02\x02\0\x12\x03'\x020\x1a6\x20sign_mode\
    s\x20defines\x20the\x20supported\x20signature\x20algorithm\n\n\x0c\n\x05\
    \x04\x02\x02\0\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03'\
    \x0b\x20\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03'!+\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03'./\n\x8e\x02\n\x02\x04\x03\x12\x04.\06\x01\x1a\x81\
    \x02\x20SigningModeDescriptor\x20provides\x20information\x20on\x20a\x20s\
    igning\x20flow\x20of\x20the\x20application\n\x20NOTE(fdymylja):\x20here\
    \x20we\x20could\x20go\x20as\x20far\x20as\x20providing\x20an\x20entire\
    \x20flow\x20on\x20how\n\x20to\x20sign\x20a\x20message\x20given\x20a\x20S\
    igningModeDescriptor,\x20but\x20it's\x20better\x20to\x20think\x20about\n\
    \x20this\x20another\x20time\n\n\n\n\x03\x04\x03\x01\x12\x03.\x08\x1d\n?\
    \n\x04\x04\x03\x02\0\x12\x030\x02\x12\x1a2\x20name\x20defines\x20the\x20\
    unique\x20name\x20of\x20the\x20signing\x20mode\n\n\x0c\n\x05\x04\x03\x02\
    \0\x05\x12\x030\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x030\t\r\n\x0c\
    \n\x05\x04\x03\x02\0\x03\x12\x030\x10\x11\nK\n\x04\x04\x03\x02\x01\x12\
    \x032\x02\x13\x1a>\x20number\x20is\x20the\x20unique\x20int32\x20identifi\
    er\x20for\x20the\x20sign_mode\x20enum\n\n\x0c\n\x05\x04\x03\x02\x01\x05\
    \x12\x032\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x032\x08\x0e\n\x0c\
    \n\x05\x04\x03\x02\x01\x03\x12\x032\x11\x12\n\xaa\x01\n\x04\x04\x03\x02\
    \x02\x12\x035\x021\x1a\x9c\x01\x20authn_info_provider_method_fullname\
    \x20defines\x20the\x20fullname\x20of\x20the\x20method\x20to\x20call\x20t\
    o\x20get\n\x20the\x20metadata\x20required\x20to\x20authenticate\x20using\
    \x20the\x20provided\x20sign_modes\n\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x035\x02\x08\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x035\t,\n\x0c\n\x05\
    \x04\x03\x02\x02\x03\x12\x035/0\nL\n\x02\x04\x04\x12\x049\0<\x01\x1a@\
    \x20ChainDescriptor\x20describes\x20chain\x20information\x20of\x20the\
    \x20application\n\n\n\n\x03\x04\x04\x01\x12\x039\x08\x17\n!\n\x04\x04\
    \x04\x02\0\x12\x03;\x02\x10\x1a\x14\x20id\x20is\x20the\x20chain\x20id\n\
    \n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03;\x02\x08\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03;\t\x0b\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03;\x0e\x0f\np\
    \n\x02\x04\x05\x12\x04?\0B\x01\x1ad\x20CodecDescriptor\x20describes\x20t\
    he\x20registered\x20interfaces\x20and\x20provides\x20metadata\x20informa\
    tion\x20on\x20the\x20types\n\n\n\n\x03\x04\x05\x01\x12\x03?\x08\x17\nM\n\
    \x04\x04\x05\x02\0\x12\x03A\x02.\x1a@\x20interfaces\x20is\x20a\x20list\
    \x20of\x20the\x20registerted\x20interfaces\x20descriptors\n\n\x0c\n\x05\
    \x04\x05\x02\0\x04\x12\x03A\x02\n\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03A\
    \x0b\x1e\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03A\x1f)\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03A,-\nN\n\x02\x04\x06\x12\x04E\0M\x01\x1aB\x20Interface\
    Descriptor\x20describes\x20the\x20implementation\x20of\x20an\x20interfac\
    e\n\n\n\n\x03\x04\x06\x01\x12\x03E\x08\x1b\n4\n\x04\x04\x06\x02\0\x12\
    \x03G\x02\x16\x1a'\x20fullname\x20is\x20the\x20name\x20of\x20the\x20inte\
    rface\n\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\
    \x06\x02\0\x01\x12\x03G\t\x11\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03G\x14\
    \x15\n\x98\x01\n\x04\x04\x06\x02\x01\x12\x03J\x02P\x1a\x8a\x01\x20interf\
    ace_accepting_messages\x20contains\x20information\x20regarding\x20the\
    \x20proto\x20messages\x20which\x20contain\x20the\x20interface\x20as\n\
    \x20google.protobuf.Any\x20field\n\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\
    \x03J\x02\n\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x03J\x0b.\n\x0c\n\x05\
    \x04\x06\x02\x01\x01\x12\x03J/K\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03J\
    NO\n`\n\x04\x04\x06\x02\x02\x12\x03L\x02E\x1aS\x20interface_implementers\
    \x20is\x20a\x20list\x20of\x20the\x20descriptors\x20of\x20the\x20interfac\
    e\x20implementers\n\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03L\x02\n\n\x0c\
    \n\x05\x04\x06\x02\x02\x06\x12\x03L\x0b)\n\x0c\n\x05\x04\x06\x02\x02\x01\
    \x12\x03L*@\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03LCD\nO\n\x02\x04\x07\
    \x12\x04P\0X\x01\x1aC\x20InterfaceImplementerDescriptor\x20describes\x20\
    an\x20interface\x20implementer\n\n\n\n\x03\x04\x07\x01\x12\x03P\x08&\nS\
    \n\x04\x04\x07\x02\0\x12\x03R\x02\x16\x1aF\x20fullname\x20is\x20the\x20p\
    rotobuf\x20queryable\x20name\x20of\x20the\x20interface\x20implementer\n\
    \n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03R\x02\x08\n\x0c\n\x05\x04\x07\x02\
    \0\x01\x12\x03R\t\x11\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03R\x14\x15\n\
    \xff\x01\n\x04\x04\x07\x02\x01\x12\x03W\x02\x16\x1a\xf1\x01\x20type_url\
    \x20defines\x20the\x20type\x20URL\x20used\x20when\x20marshalling\x20the\
    \x20type\x20as\x20any\n\x20this\x20is\x20required\x20so\x20we\x20can\x20\
    provide\x20type\x20safe\x20google.protobuf.Any\x20marshalling\x20and\n\
    \x20unmarshalling,\x20making\x20sure\x20that\x20we\x20don't\x20accept\
    \x20just\x20'any'\x20type\n\x20in\x20our\x20interface\x20fields\n\n\x0c\
    \n\x05\x04\x07\x02\x01\x05\x12\x03W\x02\x08\n\x0c\n\x05\x04\x07\x02\x01\
    \x01\x12\x03W\t\x11\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03W\x14\x15\n\
    \x91\x01\n\x02\x04\x08\x12\x04\\\0c\x01\x1a\x84\x01\x20InterfaceAcceptin\
    gMessageDescriptor\x20describes\x20a\x20protobuf\x20message\x20which\x20\
    contains\n\x20an\x20interface\x20represented\x20as\x20a\x20google.protob\
    uf.Any\n\n\n\n\x03\x04\x08\x01\x12\x03\\\x08+\nU\n\x04\x04\x08\x02\0\x12\
    \x03^\x02\x16\x1aH\x20fullname\x20is\x20the\x20protobuf\x20fullname\x20o\
    f\x20the\x20type\x20containing\x20the\x20interface\n\n\x0c\n\x05\x04\x08\
    \x02\0\x05\x12\x03^\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03^\t\x11\
    \n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03^\x14\x15\n\xef\x01\n\x04\x04\x08\
    \x02\x01\x12\x03b\x02-\x1a\xe1\x01\x20field_descriptor_names\x20is\x20a\
    \x20list\x20of\x20the\x20protobuf\x20name\x20(not\x20fullname)\x20of\x20\
    the\x20field\n\x20which\x20contains\x20the\x20interface\x20as\x20google.\
    protobuf.Any\x20(the\x20interface\x20is\x20the\x20same,\x20but\n\x20it\
    \x20can\x20be\x20in\x20multiple\x20fields\x20of\x20the\x20same\x20proto\
    \x20message)\n\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03b\x02\n\n\x0c\n\
    \x05\x04\x08\x02\x01\x05\x12\x03b\x0b\x11\n\x0c\n\x05\x04\x08\x02\x01\
    \x01\x12\x03b\x12(\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03b+,\nU\n\x02\
    \x04\t\x12\x04f\0i\x01\x1aI\x20ConfigurationDescriptor\x20contains\x20me\
    tadata\x20information\x20on\x20the\x20sdk.Config\n\n\n\n\x03\x04\t\x01\
    \x12\x03f\x08\x1f\nJ\n\x04\x04\t\x02\0\x12\x03h\x02+\x1a=\x20bech32_acco\
    unt_address_prefix\x20is\x20the\x20account\x20address\x20prefix\n\n\x0c\
    \n\x05\x04\t\x02\0\x05\x12\x03h\x02\x08\n\x0c\n\x05\x04\t\x02\0\x01\x12\
    \x03h\t&\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03h)*\nc\n\x02\x04\n\x12\x04l\
    \0o\x01\x1aW\x20MsgDescriptor\x20describes\x20a\x20cosmos-sdk\x20message\
    \x20that\x20can\x20be\x20delivered\x20with\x20a\x20transaction\n\n\n\n\
    \x03\x04\n\x01\x12\x03l\x08\x15\n>\n\x04\x04\n\x02\0\x12\x03n\x02\x1a\
    \x1a1\x20msg_type_url\x20contains\x20the\x20TypeURL\x20of\x20a\x20sdk.Ms\
    g.\n\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03n\x02\x08\n\x0c\n\x05\x04\n\x02\
    \0\x01\x12\x03n\t\x15\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03n\x18\x19\nN\n\
    \x02\x06\0\x12\x05r\0\x8d\x01\x01\x1aA\x20ReflectionService\x20defines\
    \x20a\x20service\x20for\x20application\x20reflection.\n\n\n\n\x03\x06\0\
    \x01\x12\x03r\x08\x19\n\xef\x01\n\x04\x06\0\x02\0\x12\x04v\x02x\x03\x1a\
    \xe0\x01\x20GetAuthnDescriptor\x20returns\x20information\x20on\x20how\
    \x20to\x20authenticate\x20transactions\x20in\x20the\x20application\n\x20\
    NOTE:\x20this\x20RPC\x20is\x20still\x20experimental\x20and\x20might\x20b\
    e\x20subject\x20to\x20breaking\x20changes\x20or\x20removal\x20in\n\x20fu\
    ture\x20releases\x20of\x20the\x20cosmos-sdk.\n\n\x0c\n\x05\x06\0\x02\0\
    \x01\x12\x03v\x06\x18\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03v\x192\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03v=W\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03w\x04\
    Z\n\x11\n\n\x06\0\x02\0\x04\xb0\xca\xbc\"\x02\x12\x03w\x04Z\nG\n\x04\x06\
    \0\x02\x01\x12\x04z\x02|\x03\x1a9\x20GetChainDescriptor\x20returns\x20th\
    e\x20description\x20of\x20the\x20chain\n\n\x0c\n\x05\x06\0\x02\x01\x01\
    \x12\x03z\x06\x18\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03z\x192\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03z=W\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03{\
    \x04Z\n\x11\n\n\x06\0\x02\x01\x04\xb0\xca\xbc\"\x02\x12\x03{\x04Z\nZ\n\
    \x04\x06\0\x02\x02\x12\x05~\x02\x80\x01\x03\x1aK\x20GetCodecDescriptor\
    \x20returns\x20the\x20descriptor\x20of\x20the\x20codec\x20of\x20the\x20a\
    pplication\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03~\x06\x18\n\x0c\n\x05\
    \x06\0\x02\x02\x02\x12\x03~\x192\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03~=\
    W\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03\x7f\x04Z\n\x11\n\n\x06\0\x02\x02\
    \x04\xb0\xca\xbc\"\x02\x12\x03\x7f\x04Z\ni\n\x04\x06\0\x02\x03\x12\x06\
    \x82\x01\x02\x84\x01\x03\x1aY\x20GetConfigurationDescriptor\x20returns\
    \x20the\x20descriptor\x20for\x20the\x20sdk.Config\x20of\x20the\x20applic\
    ation\n\n\r\n\x05\x06\0\x02\x03\x01\x12\x04\x82\x01\x06\x20\n\r\n\x05\
    \x06\0\x02\x03\x02\x12\x04\x82\x01!B\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\
    \x82\x01Mo\n\r\n\x05\x06\0\x02\x03\x04\x12\x04\x83\x01\x04b\n\x12\n\n\
    \x06\0\x02\x03\x04\xb0\xca\xbc\"\x02\x12\x04\x83\x01\x04b\nm\n\x04\x06\0\
    \x02\x04\x12\x06\x86\x01\x02\x88\x01\x03\x1a]\x20GetQueryServicesDescrip\
    tor\x20returns\x20the\x20available\x20gRPC\x20queryable\x20services\x20o\
    f\x20the\x20application\n\n\r\n\x05\x06\0\x02\x04\x01\x12\x04\x86\x01\
    \x06\x20\n\r\n\x05\x06\0\x02\x04\x02\x12\x04\x86\x01!B\n\r\n\x05\x06\0\
    \x02\x04\x03\x12\x04\x86\x01Mo\n\r\n\x05\x06\0\x02\x04\x04\x12\x04\x87\
    \x01\x04c\n\x12\n\n\x06\0\x02\x04\x04\xb0\xca\xbc\"\x02\x12\x04\x87\x01\
    \x04c\nx\n\x04\x06\0\x02\x05\x12\x06\x8a\x01\x02\x8c\x01\x03\x1ah\x20Get\
    TxDescriptor\x20returns\x20information\x20on\x20the\x20used\x20transacti\
    on\x20object\x20and\x20available\x20msgs\x20that\x20can\x20be\x20used\n\
    \n\r\n\x05\x06\0\x02\x05\x01\x12\x04\x8a\x01\x06\x15\n\r\n\x05\x06\0\x02\
    \x05\x02\x12\x04\x8a\x01\x16,\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\x8a\
    \x017N\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\x8b\x01\x04b\n\x12\n\n\x06\0\
    \x02\x05\x04\xb0\xca\xbc\"\x02\x12\x04\x8b\x01\x04b\nZ\n\x02\x04\x0b\x12\
    \x04\x90\x01\0$\x1aN\x20GetAuthnDescriptorRequest\x20is\x20the\x20reques\
    t\x20used\x20for\x20the\x20GetAuthnDescriptor\x20RPC\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\x90\x01\x08!\na\n\x02\x04\x0c\x12\x06\x92\x01\0\x95\x01\
    \x01\x1aS\x20GetAuthnDescriptorResponse\x20is\x20the\x20response\x20retu\
    rned\x20by\x20the\x20GetAuthnDescriptor\x20RPC\n\n\x0b\n\x03\x04\x0c\x01\
    \x12\x04\x92\x01\x08\"\n`\n\x04\x04\x0c\x02\0\x12\x04\x94\x01\x02\x1c\
    \x1aR\x20authn\x20describes\x20how\x20to\x20authenticate\x20to\x20the\
    \x20application\x20when\x20sending\x20transactions\n\n\r\n\x05\x04\x0c\
    \x02\0\x06\x12\x04\x94\x01\x02\x11\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\
    \x94\x01\x12\x17\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x94\x01\x1a\x1b\nZ\
    \n\x02\x04\r\x12\x04\x98\x01\0$\x1aN\x20GetChainDescriptorRequest\x20is\
    \x20the\x20request\x20used\x20for\x20the\x20GetChainDescriptor\x20RPC\n\
    \n\x0b\n\x03\x04\r\x01\x12\x04\x98\x01\x08!\na\n\x02\x04\x0e\x12\x06\x9a\
    \x01\0\x9d\x01\x01\x1aS\x20GetChainDescriptorResponse\x20is\x20the\x20re\
    sponse\x20returned\x20by\x20the\x20GetChainDescriptor\x20RPC\n\n\x0b\n\
    \x03\x04\x0e\x01\x12\x04\x9a\x01\x08\"\n=\n\x04\x04\x0e\x02\0\x12\x04\
    \x9c\x01\x02\x1c\x1a/\x20chain\x20describes\x20application\x20chain\x20i\
    nformation\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\x9c\x01\x02\x11\n\r\n\
    \x05\x04\x0e\x02\0\x01\x12\x04\x9c\x01\x12\x17\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\x9c\x01\x1a\x1b\nZ\n\x02\x04\x0f\x12\x04\xa0\x01\0$\x1aN\
    \x20GetCodecDescriptorRequest\x20is\x20the\x20request\x20used\x20for\x20\
    the\x20GetCodecDescriptor\x20RPC\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa0\
    \x01\x08!\na\n\x02\x04\x10\x12\x06\xa2\x01\0\xa5\x01\x01\x1aS\x20GetCode\
    cDescriptorResponse\x20is\x20the\x20response\x20returned\x20by\x20the\
    \x20GetCodecDescriptor\x20RPC\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xa2\x01\
    \x08\"\ng\n\x04\x04\x10\x02\0\x12\x04\xa4\x01\x02\x1c\x1aY\x20codec\x20d\
    escribes\x20the\x20application\x20codec\x20such\x20as\x20registered\x20i\
    nterfaces\x20and\x20implementations\n\n\r\n\x05\x04\x10\x02\0\x06\x12\
    \x04\xa4\x01\x02\x11\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa4\x01\x12\x17\
    \n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa4\x01\x1a\x1b\nj\n\x02\x04\x11\
    \x12\x04\xa8\x01\0,\x1a^\x20GetConfigurationDescriptorRequest\x20is\x20t\
    he\x20request\x20used\x20for\x20the\x20GetConfigurationDescriptor\x20RPC\
    \n\n\x0b\n\x03\x04\x11\x01\x12\x04\xa8\x01\x08)\nq\n\x02\x04\x12\x12\x06\
    \xaa\x01\0\xad\x01\x01\x1ac\x20GetConfigurationDescriptorResponse\x20is\
    \x20the\x20response\x20returned\x20by\x20the\x20GetConfigurationDescript\
    or\x20RPC\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xaa\x01\x08*\n=\n\x04\x04\
    \x12\x02\0\x12\x04\xac\x01\x02%\x1a/\x20config\x20describes\x20the\x20ap\
    plication's\x20sdk.Config\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xac\x01\
    \x02\x19\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xac\x01\x1a\x20\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xac\x01#$\nj\n\x02\x04\x13\x12\x04\xb0\x01\0,\
    \x1a^\x20GetQueryServicesDescriptorRequest\x20is\x20the\x20request\x20us\
    ed\x20for\x20the\x20GetQueryServicesDescriptor\x20RPC\n\n\x0b\n\x03\x04\
    \x13\x01\x12\x04\xb0\x01\x08)\nq\n\x02\x04\x14\x12\x06\xb2\x01\0\xb5\x01\
    \x01\x1ac\x20GetQueryServicesDescriptorResponse\x20is\x20the\x20response\
    \x20returned\x20by\x20the\x20GetQueryServicesDescriptor\x20RPC\n\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xb2\x01\x08*\nP\n\x04\x04\x14\x02\0\x12\x04\xb4\
    \x01\x02&\x1aB\x20queries\x20provides\x20information\x20on\x20the\x20ava\
    ilable\x20queryable\x20services\n\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\
    \xb4\x01\x02\x19\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xb4\x01\x1a!\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xb4\x01$%\nT\n\x02\x04\x15\x12\x04\xb8\
    \x01\0!\x1aH\x20GetTxDescriptorRequest\x20is\x20the\x20request\x20used\
    \x20for\x20the\x20GetTxDescriptor\x20RPC\n\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xb8\x01\x08\x1e\n[\n\x02\x04\x16\x12\x06\xba\x01\0\xbe\x01\x01\x1aM\
    \x20GetTxDescriptorResponse\x20is\x20the\x20response\x20returned\x20by\
    \x20the\x20GetTxDescriptor\x20RPC\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xba\
    \x01\x08\x1f\n\x8a\x01\n\x04\x04\x16\x02\0\x12\x04\xbd\x01\x02\x16\x1a|\
    \x20tx\x20provides\x20information\x20on\x20msgs\x20that\x20can\x20be\x20\
    forwarded\x20to\x20the\x20application\n\x20alongside\x20the\x20accepted\
    \x20transaction\x20protobuf\x20type\n\n\r\n\x05\x04\x16\x02\0\x06\x12\
    \x04\xbd\x01\x02\x0e\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xbd\x01\x0f\x11\
    \n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xbd\x01\x14\x15\nZ\n\x02\x04\x17\
    \x12\x06\xc1\x01\0\xc4\x01\x01\x1aL\x20QueryServicesDescriptor\x20contai\
    ns\x20the\x20list\x20of\x20cosmos-sdk\x20queriable\x20services\n\n\x0b\n\
    \x03\x04\x17\x01\x12\x04\xc1\x01\x08\x1f\nM\n\x04\x04\x17\x02\0\x12\x04\
    \xc3\x01\x025\x1a?\x20query_services\x20is\x20a\x20list\x20of\x20cosmos-\
    sdk\x20QueryServiceDescriptor\n\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xc3\
    \x01\x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xc3\x01\x0b!\n\r\n\x05\
    \x04\x17\x02\0\x01\x12\x04\xc3\x01\"0\n\r\n\x05\x04\x17\x02\0\x03\x12\
    \x04\xc3\x0134\nO\n\x02\x04\x18\x12\x06\xc7\x01\0\xce\x01\x01\x1aA\x20Qu\
    eryServiceDescriptor\x20describes\x20a\x20cosmos-sdk\x20queryable\x20ser\
    vice\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xc7\x01\x08\x1e\nK\n\x04\x04\x18\
    \x02\0\x12\x04\xc9\x01\x02\x16\x1a=\x20fullname\x20is\x20the\x20protobuf\
    \x20fullname\x20of\x20the\x20service\x20descriptor\n\n\r\n\x05\x04\x18\
    \x02\0\x05\x12\x04\xc9\x01\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xc9\x01\t\x11\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc9\x01\x14\x15\nb\n\
    \x04\x04\x18\x02\x01\x12\x04\xcb\x01\x02\x15\x1aT\x20is_module\x20descri\
    bes\x20if\x20this\x20service\x20is\x20actually\x20exposed\x20by\x20an\
    \x20application's\x20module\n\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xcb\
    \x01\x02\x06\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xcb\x01\x07\x10\n\r\n\
    \x05\x04\x18\x02\x01\x03\x12\x04\xcb\x01\x13\x14\n@\n\x04\x04\x18\x02\
    \x02\x12\x04\xcd\x01\x02-\x1a2\x20methods\x20provides\x20a\x20list\x20of\
    \x20query\x20service\x20methods\n\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\
    \xcd\x01\x02\n\n\r\n\x05\x04\x18\x02\x02\x06\x12\x04\xcd\x01\x0b\x20\n\r\
    \n\x05\x04\x18\x02\x02\x01\x12\x04\xcd\x01!(\n\r\n\x05\x04\x18\x02\x02\
    \x03\x12\x04\xcd\x01+,\n\xe2\x01\n\x02\x04\x19\x12\x06\xd3\x01\0\xd9\x01\
    \x01\x1a\xd3\x01\x20QueryMethodDescriptor\x20describes\x20a\x20queryable\
    \x20method\x20of\x20a\x20query\x20service\n\x20no\x20other\x20info\x20is\
    \x20provided\x20beside\x20method\x20name\x20and\x20tendermint\x20queryab\
    le\x20path\n\x20because\x20it\x20would\x20be\x20redundant\x20with\x20the\
    \x20grpc\x20reflection\x20service\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xd3\
    \x01\x08\x1d\nF\n\x04\x04\x19\x02\0\x12\x04\xd5\x01\x02\x12\x1a8\x20name\
    \x20is\x20the\x20protobuf\x20name\x20(not\x20fullname)\x20of\x20the\x20m\
    ethod\n\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xd5\x01\x02\x08\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xd5\x01\t\r\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\xd5\x01\x10\x11\nl\n\x04\x04\x19\x02\x01\x12\x04\xd8\x01\x02\x1d\
    \x1a^\x20full_query_path\x20is\x20the\x20path\x20that\x20can\x20be\x20us\
    ed\x20to\x20query\n\x20this\x20method\x20via\x20tendermint\x20abci.Query\
    \n\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xd8\x01\x02\x08\n\r\n\x05\x04\
    \x19\x02\x01\x01\x12\x04\xd8\x01\t\x18\n\r\n\x05\x04\x19\x02\x01\x03\x12\
    \x04\xd8\x01\x1b\x1cb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::annotations::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(26);
            messages.push(AppDescriptor::generated_message_descriptor_data());
            messages.push(TxDescriptor::generated_message_descriptor_data());
            messages.push(AuthnDescriptor::generated_message_descriptor_data());
            messages.push(SigningModeDescriptor::generated_message_descriptor_data());
            messages.push(ChainDescriptor::generated_message_descriptor_data());
            messages.push(CodecDescriptor::generated_message_descriptor_data());
            messages.push(InterfaceDescriptor::generated_message_descriptor_data());
            messages.push(InterfaceImplementerDescriptor::generated_message_descriptor_data());
            messages.push(InterfaceAcceptingMessageDescriptor::generated_message_descriptor_data());
            messages.push(ConfigurationDescriptor::generated_message_descriptor_data());
            messages.push(MsgDescriptor::generated_message_descriptor_data());
            messages.push(GetAuthnDescriptorRequest::generated_message_descriptor_data());
            messages.push(GetAuthnDescriptorResponse::generated_message_descriptor_data());
            messages.push(GetChainDescriptorRequest::generated_message_descriptor_data());
            messages.push(GetChainDescriptorResponse::generated_message_descriptor_data());
            messages.push(GetCodecDescriptorRequest::generated_message_descriptor_data());
            messages.push(GetCodecDescriptorResponse::generated_message_descriptor_data());
            messages.push(GetConfigurationDescriptorRequest::generated_message_descriptor_data());
            messages.push(GetConfigurationDescriptorResponse::generated_message_descriptor_data());
            messages.push(GetQueryServicesDescriptorRequest::generated_message_descriptor_data());
            messages.push(GetQueryServicesDescriptorResponse::generated_message_descriptor_data());
            messages.push(GetTxDescriptorRequest::generated_message_descriptor_data());
            messages.push(GetTxDescriptorResponse::generated_message_descriptor_data());
            messages.push(QueryServicesDescriptor::generated_message_descriptor_data());
            messages.push(QueryServiceDescriptor::generated_message_descriptor_data());
            messages.push(QueryMethodDescriptor::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
