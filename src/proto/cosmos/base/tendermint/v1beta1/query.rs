// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos/base/tendermint/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  GetValidatorSetByHeightRequest is the request type for the Query/GetValidatorSetByHeight RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightRequest)
pub struct GetValidatorSetByHeightRequest {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightRequest.height)
    pub height: i64,
    ///  pagination defines an pagination for the request.
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetValidatorSetByHeightRequest {
    fn default() -> &'a GetValidatorSetByHeightRequest {
        <GetValidatorSetByHeightRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorSetByHeightRequest {
    pub fn new() -> GetValidatorSetByHeightRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &GetValidatorSetByHeightRequest| { &m.height },
            |m: &mut GetValidatorSetByHeightRequest| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &GetValidatorSetByHeightRequest| { &m.pagination },
            |m: &mut GetValidatorSetByHeightRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetValidatorSetByHeightRequest>(
            "GetValidatorSetByHeightRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetValidatorSetByHeightRequest {
    const NAME: &'static str = "GetValidatorSetByHeightRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetValidatorSetByHeightRequest {
        GetValidatorSetByHeightRequest::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetValidatorSetByHeightRequest {
        static instance: GetValidatorSetByHeightRequest = GetValidatorSetByHeightRequest {
            height: 0,
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetValidatorSetByHeightRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetValidatorSetByHeightRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetValidatorSetByHeightRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorSetByHeightRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse)
pub struct GetValidatorSetByHeightResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse.block_height)
    pub block_height: i64,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse.validators)
    pub validators: ::std::vec::Vec<Validator>,
    ///  pagination defines an pagination for the response.
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetValidatorSetByHeightResponse {
    fn default() -> &'a GetValidatorSetByHeightResponse {
        <GetValidatorSetByHeightResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorSetByHeightResponse {
    pub fn new() -> GetValidatorSetByHeightResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_height",
            |m: &GetValidatorSetByHeightResponse| { &m.block_height },
            |m: &mut GetValidatorSetByHeightResponse| { &mut m.block_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validators",
            |m: &GetValidatorSetByHeightResponse| { &m.validators },
            |m: &mut GetValidatorSetByHeightResponse| { &mut m.validators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &GetValidatorSetByHeightResponse| { &m.pagination },
            |m: &mut GetValidatorSetByHeightResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetValidatorSetByHeightResponse>(
            "GetValidatorSetByHeightResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetValidatorSetByHeightResponse {
    const NAME: &'static str = "GetValidatorSetByHeightResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.block_height = is.read_int64()?;
                },
                18 => {
                    self.validators.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.block_height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.block_height);
        }
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.block_height != 0 {
            os.write_int64(1, self.block_height)?;
        }
        for v in &self.validators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetValidatorSetByHeightResponse {
        GetValidatorSetByHeightResponse::new()
    }

    fn clear(&mut self) {
        self.block_height = 0;
        self.validators.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetValidatorSetByHeightResponse {
        static instance: GetValidatorSetByHeightResponse = GetValidatorSetByHeightResponse {
            block_height: 0,
            validators: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetValidatorSetByHeightResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetValidatorSetByHeightResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetValidatorSetByHeightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorSetByHeightResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetLatestValidatorSetRequest is the request type for the Query/GetValidatorSetByHeight RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetRequest)
pub struct GetLatestValidatorSetRequest {
    // message fields
    ///  pagination defines an pagination for the request.
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLatestValidatorSetRequest {
    fn default() -> &'a GetLatestValidatorSetRequest {
        <GetLatestValidatorSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestValidatorSetRequest {
    pub fn new() -> GetLatestValidatorSetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &GetLatestValidatorSetRequest| { &m.pagination },
            |m: &mut GetLatestValidatorSetRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLatestValidatorSetRequest>(
            "GetLatestValidatorSetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLatestValidatorSetRequest {
    const NAME: &'static str = "GetLatestValidatorSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLatestValidatorSetRequest {
        GetLatestValidatorSetRequest::new()
    }

    fn clear(&mut self) {
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLatestValidatorSetRequest {
        static instance: GetLatestValidatorSetRequest = GetLatestValidatorSetRequest {
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLatestValidatorSetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLatestValidatorSetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLatestValidatorSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestValidatorSetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse)
pub struct GetLatestValidatorSetResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse.block_height)
    pub block_height: i64,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse.validators)
    pub validators: ::std::vec::Vec<Validator>,
    ///  pagination defines an pagination for the response.
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLatestValidatorSetResponse {
    fn default() -> &'a GetLatestValidatorSetResponse {
        <GetLatestValidatorSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestValidatorSetResponse {
    pub fn new() -> GetLatestValidatorSetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_height",
            |m: &GetLatestValidatorSetResponse| { &m.block_height },
            |m: &mut GetLatestValidatorSetResponse| { &mut m.block_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validators",
            |m: &GetLatestValidatorSetResponse| { &m.validators },
            |m: &mut GetLatestValidatorSetResponse| { &mut m.validators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &GetLatestValidatorSetResponse| { &m.pagination },
            |m: &mut GetLatestValidatorSetResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLatestValidatorSetResponse>(
            "GetLatestValidatorSetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLatestValidatorSetResponse {
    const NAME: &'static str = "GetLatestValidatorSetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.block_height = is.read_int64()?;
                },
                18 => {
                    self.validators.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.block_height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.block_height);
        }
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.block_height != 0 {
            os.write_int64(1, self.block_height)?;
        }
        for v in &self.validators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLatestValidatorSetResponse {
        GetLatestValidatorSetResponse::new()
    }

    fn clear(&mut self) {
        self.block_height = 0;
        self.validators.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLatestValidatorSetResponse {
        static instance: GetLatestValidatorSetResponse = GetLatestValidatorSetResponse {
            block_height: 0,
            validators: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLatestValidatorSetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLatestValidatorSetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLatestValidatorSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestValidatorSetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Validator is the type for the validator-set.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.Validator)
pub struct Validator {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.Validator.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.Validator.pub_key)
    pub pub_key: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.Validator.voting_power)
    pub voting_power: i64,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.Validator.proposer_priority)
    pub proposer_priority: i64,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.Validator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Validator| { &m.address },
            |m: &mut Validator| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "pub_key",
            |m: &Validator| { &m.pub_key },
            |m: &mut Validator| { &mut m.pub_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "voting_power",
            |m: &Validator| { &m.voting_power },
            |m: &mut Validator| { &mut m.voting_power },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposer_priority",
            |m: &Validator| { &m.proposer_priority },
            |m: &mut Validator| { &mut m.proposer_priority },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Validator>(
            "Validator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Validator {
    const NAME: &'static str = "Validator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pub_key)?;
                },
                24 => {
                    self.voting_power = is.read_int64()?;
                },
                32 => {
                    self.proposer_priority = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if let Some(v) = self.pub_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.voting_power != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.voting_power);
        }
        if self.proposer_priority != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.proposer_priority);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if let Some(v) = self.pub_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.voting_power != 0 {
            os.write_int64(3, self.voting_power)?;
        }
        if self.proposer_priority != 0 {
            os.write_int64(4, self.proposer_priority)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.pub_key.clear();
        self.voting_power = 0;
        self.proposer_priority = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Validator {
        static instance: Validator = Validator {
            address: ::std::string::String::new(),
            pub_key: ::protobuf::MessageField::none(),
            voting_power: 0,
            proposer_priority: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Validator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Validator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetBlockByHeightRequest is the request type for the Query/GetBlockByHeight RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetBlockByHeightRequest)
pub struct GetBlockByHeightRequest {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetBlockByHeightRequest.height)
    pub height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetBlockByHeightRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBlockByHeightRequest {
    fn default() -> &'a GetBlockByHeightRequest {
        <GetBlockByHeightRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockByHeightRequest {
    pub fn new() -> GetBlockByHeightRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &GetBlockByHeightRequest| { &m.height },
            |m: &mut GetBlockByHeightRequest| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBlockByHeightRequest>(
            "GetBlockByHeightRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBlockByHeightRequest {
    const NAME: &'static str = "GetBlockByHeightRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBlockByHeightRequest {
        GetBlockByHeightRequest::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBlockByHeightRequest {
        static instance: GetBlockByHeightRequest = GetBlockByHeightRequest {
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBlockByHeightRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBlockByHeightRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBlockByHeightRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockByHeightRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse)
pub struct GetBlockByHeightResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse.block_id)
    pub block_id: ::protobuf::MessageField<super::types::BlockID>,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse.block)
    pub block: ::protobuf::MessageField<super::block::Block>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBlockByHeightResponse {
    fn default() -> &'a GetBlockByHeightResponse {
        <GetBlockByHeightResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockByHeightResponse {
    pub fn new() -> GetBlockByHeightResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::BlockID>(
            "block_id",
            |m: &GetBlockByHeightResponse| { &m.block_id },
            |m: &mut GetBlockByHeightResponse| { &mut m.block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::block::Block>(
            "block",
            |m: &GetBlockByHeightResponse| { &m.block },
            |m: &mut GetBlockByHeightResponse| { &mut m.block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBlockByHeightResponse>(
            "GetBlockByHeightResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBlockByHeightResponse {
    const NAME: &'static str = "GetBlockByHeightResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBlockByHeightResponse {
        GetBlockByHeightResponse::new()
    }

    fn clear(&mut self) {
        self.block_id.clear();
        self.block.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBlockByHeightResponse {
        static instance: GetBlockByHeightResponse = GetBlockByHeightResponse {
            block_id: ::protobuf::MessageField::none(),
            block: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBlockByHeightResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBlockByHeightResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBlockByHeightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockByHeightResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetLatestBlockRequest is the request type for the Query/GetLatestBlock RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetLatestBlockRequest)
pub struct GetLatestBlockRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetLatestBlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLatestBlockRequest {
    fn default() -> &'a GetLatestBlockRequest {
        <GetLatestBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestBlockRequest {
    pub fn new() -> GetLatestBlockRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLatestBlockRequest>(
            "GetLatestBlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLatestBlockRequest {
    const NAME: &'static str = "GetLatestBlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLatestBlockRequest {
        GetLatestBlockRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLatestBlockRequest {
        static instance: GetLatestBlockRequest = GetLatestBlockRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLatestBlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLatestBlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLatestBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestBlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetLatestBlockResponse)
pub struct GetLatestBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetLatestBlockResponse.block_id)
    pub block_id: ::protobuf::MessageField<super::types::BlockID>,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetLatestBlockResponse.block)
    pub block: ::protobuf::MessageField<super::block::Block>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetLatestBlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLatestBlockResponse {
    fn default() -> &'a GetLatestBlockResponse {
        <GetLatestBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestBlockResponse {
    pub fn new() -> GetLatestBlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::BlockID>(
            "block_id",
            |m: &GetLatestBlockResponse| { &m.block_id },
            |m: &mut GetLatestBlockResponse| { &mut m.block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::block::Block>(
            "block",
            |m: &GetLatestBlockResponse| { &m.block },
            |m: &mut GetLatestBlockResponse| { &mut m.block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLatestBlockResponse>(
            "GetLatestBlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLatestBlockResponse {
    const NAME: &'static str = "GetLatestBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLatestBlockResponse {
        GetLatestBlockResponse::new()
    }

    fn clear(&mut self) {
        self.block_id.clear();
        self.block.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLatestBlockResponse {
        static instance: GetLatestBlockResponse = GetLatestBlockResponse {
            block_id: ::protobuf::MessageField::none(),
            block: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLatestBlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLatestBlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLatestBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestBlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetSyncingRequest is the request type for the Query/GetSyncing RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetSyncingRequest)
pub struct GetSyncingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetSyncingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSyncingRequest {
    fn default() -> &'a GetSyncingRequest {
        <GetSyncingRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSyncingRequest {
    pub fn new() -> GetSyncingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSyncingRequest>(
            "GetSyncingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSyncingRequest {
    const NAME: &'static str = "GetSyncingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSyncingRequest {
        GetSyncingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSyncingRequest {
        static instance: GetSyncingRequest = GetSyncingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSyncingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSyncingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSyncingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSyncingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetSyncingResponse is the response type for the Query/GetSyncing RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetSyncingResponse)
pub struct GetSyncingResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetSyncingResponse.syncing)
    pub syncing: bool,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetSyncingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSyncingResponse {
    fn default() -> &'a GetSyncingResponse {
        <GetSyncingResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSyncingResponse {
    pub fn new() -> GetSyncingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "syncing",
            |m: &GetSyncingResponse| { &m.syncing },
            |m: &mut GetSyncingResponse| { &mut m.syncing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSyncingResponse>(
            "GetSyncingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSyncingResponse {
    const NAME: &'static str = "GetSyncingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.syncing = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.syncing != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.syncing != false {
            os.write_bool(1, self.syncing)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSyncingResponse {
        GetSyncingResponse::new()
    }

    fn clear(&mut self) {
        self.syncing = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSyncingResponse {
        static instance: GetSyncingResponse = GetSyncingResponse {
            syncing: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSyncingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSyncingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSyncingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSyncingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetNodeInfoRequest is the request type for the Query/GetNodeInfo RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetNodeInfoRequest)
pub struct GetNodeInfoRequest {
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetNodeInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNodeInfoRequest {
    fn default() -> &'a GetNodeInfoRequest {
        <GetNodeInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetNodeInfoRequest {
    pub fn new() -> GetNodeInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNodeInfoRequest>(
            "GetNodeInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNodeInfoRequest {
    const NAME: &'static str = "GetNodeInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNodeInfoRequest {
        GetNodeInfoRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNodeInfoRequest {
        static instance: GetNodeInfoRequest = GetNodeInfoRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNodeInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNodeInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNodeInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNodeInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.GetNodeInfoResponse)
pub struct GetNodeInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetNodeInfoResponse.default_node_info)
    pub default_node_info: ::protobuf::MessageField<super::types::DefaultNodeInfo>,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.GetNodeInfoResponse.application_version)
    pub application_version: ::protobuf::MessageField<VersionInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.GetNodeInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNodeInfoResponse {
    fn default() -> &'a GetNodeInfoResponse {
        <GetNodeInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetNodeInfoResponse {
    pub fn new() -> GetNodeInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::DefaultNodeInfo>(
            "default_node_info",
            |m: &GetNodeInfoResponse| { &m.default_node_info },
            |m: &mut GetNodeInfoResponse| { &mut m.default_node_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VersionInfo>(
            "application_version",
            |m: &GetNodeInfoResponse| { &m.application_version },
            |m: &mut GetNodeInfoResponse| { &mut m.application_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNodeInfoResponse>(
            "GetNodeInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNodeInfoResponse {
    const NAME: &'static str = "GetNodeInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_node_info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.application_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.default_node_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.application_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.default_node_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.application_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNodeInfoResponse {
        GetNodeInfoResponse::new()
    }

    fn clear(&mut self) {
        self.default_node_info.clear();
        self.application_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNodeInfoResponse {
        static instance: GetNodeInfoResponse = GetNodeInfoResponse {
            default_node_info: ::protobuf::MessageField::none(),
            application_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNodeInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNodeInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNodeInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNodeInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  VersionInfo is the type for the GetNodeInfoResponse message.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.VersionInfo)
pub struct VersionInfo {
    // message fields
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.app_name)
    pub app_name: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.git_commit)
    pub git_commit: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.build_tags)
    pub build_tags: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.go_version)
    pub go_version: ::std::string::String,
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.build_deps)
    pub build_deps: ::std::vec::Vec<Module>,
    ///  Since: cosmos-sdk 0.43
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.VersionInfo.cosmos_sdk_version)
    pub cosmos_sdk_version: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.VersionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VersionInfo {
    fn default() -> &'a VersionInfo {
        <VersionInfo as ::protobuf::Message>::default_instance()
    }
}

impl VersionInfo {
    pub fn new() -> VersionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &VersionInfo| { &m.name },
            |m: &mut VersionInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_name",
            |m: &VersionInfo| { &m.app_name },
            |m: &mut VersionInfo| { &mut m.app_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &VersionInfo| { &m.version },
            |m: &mut VersionInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "git_commit",
            |m: &VersionInfo| { &m.git_commit },
            |m: &mut VersionInfo| { &mut m.git_commit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "build_tags",
            |m: &VersionInfo| { &m.build_tags },
            |m: &mut VersionInfo| { &mut m.build_tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "go_version",
            |m: &VersionInfo| { &m.go_version },
            |m: &mut VersionInfo| { &mut m.go_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_deps",
            |m: &VersionInfo| { &m.build_deps },
            |m: &mut VersionInfo| { &mut m.build_deps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cosmos_sdk_version",
            |m: &VersionInfo| { &m.cosmos_sdk_version },
            |m: &mut VersionInfo| { &mut m.cosmos_sdk_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionInfo>(
            "VersionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VersionInfo {
    const NAME: &'static str = "VersionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.app_name = is.read_string()?;
                },
                26 => {
                    self.version = is.read_string()?;
                },
                34 => {
                    self.git_commit = is.read_string()?;
                },
                42 => {
                    self.build_tags = is.read_string()?;
                },
                50 => {
                    self.go_version = is.read_string()?;
                },
                58 => {
                    self.build_deps.push(is.read_message()?);
                },
                66 => {
                    self.cosmos_sdk_version = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.app_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version);
        }
        if !self.git_commit.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.git_commit);
        }
        if !self.build_tags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.build_tags);
        }
        if !self.go_version.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.go_version);
        }
        for value in &self.build_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.cosmos_sdk_version.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.cosmos_sdk_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.app_name.is_empty() {
            os.write_string(2, &self.app_name)?;
        }
        if !self.version.is_empty() {
            os.write_string(3, &self.version)?;
        }
        if !self.git_commit.is_empty() {
            os.write_string(4, &self.git_commit)?;
        }
        if !self.build_tags.is_empty() {
            os.write_string(5, &self.build_tags)?;
        }
        if !self.go_version.is_empty() {
            os.write_string(6, &self.go_version)?;
        }
        for v in &self.build_deps {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if !self.cosmos_sdk_version.is_empty() {
            os.write_string(8, &self.cosmos_sdk_version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VersionInfo {
        VersionInfo::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.app_name.clear();
        self.version.clear();
        self.git_commit.clear();
        self.build_tags.clear();
        self.go_version.clear();
        self.build_deps.clear();
        self.cosmos_sdk_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VersionInfo {
        static instance: VersionInfo = VersionInfo {
            name: ::std::string::String::new(),
            app_name: ::std::string::String::new(),
            version: ::std::string::String::new(),
            git_commit: ::std::string::String::new(),
            build_tags: ::std::string::String::new(),
            go_version: ::std::string::String::new(),
            build_deps: ::std::vec::Vec::new(),
            cosmos_sdk_version: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VersionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VersionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VersionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Module is the type for VersionInfo
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.base.tendermint.v1beta1.Module)
pub struct Module {
    // message fields
    ///  module path
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.Module.path)
    pub path: ::std::string::String,
    ///  module version
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.Module.version)
    pub version: ::std::string::String,
    ///  checksum
    // @@protoc_insertion_point(field:cosmos.base.tendermint.v1beta1.Module.sum)
    pub sum: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.base.tendermint.v1beta1.Module.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &Module| { &m.path },
            |m: &mut Module| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &Module| { &m.version },
            |m: &mut Module| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sum",
            |m: &Module| { &m.sum },
            |m: &mut Module| { &mut m.sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Module>(
            "Module",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Module {
    const NAME: &'static str = "Module";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.version = is.read_string()?;
                },
                26 => {
                    self.sum = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.sum.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sum);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.sum.is_empty() {
            os.write_string(3, &self.sum)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Module {
        Module::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.version.clear();
        self.sum.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Module {
        static instance: Module = Module {
            path: ::std::string::String::new(),
            version: ::std::string::String::new(),
            sum: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Module {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Module").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*cosmos/base/tendermint/v1beta1/query.proto\x12\x1ecosmos.base.tenderm\
    int.v1beta1\x1a\x14gogoproto/gogo.proto\x1a\x19google/protobuf/any.proto\
    \x1a\x1cgoogle/api/annotations.proto\x1a\x1atendermint/p2p/types.proto\
    \x1a\x1ctendermint/types/block.proto\x1a\x1ctendermint/types/types.proto\
    \x1a*cosmos/base/query/v1beta1/pagination.proto\"\x80\x01\n\x1eGetValida\
    torSetByHeightRequest\x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06heigh\
    t\x12F\n\npagination\x18\x02\x20\x01(\x0b2&.cosmos.base.query.v1beta1.Pa\
    geRequestR\npagination\"\xd8\x01\n\x1fGetValidatorSetByHeightResponse\
    \x12!\n\x0cblock_height\x18\x01\x20\x01(\x03R\x0bblockHeight\x12I\n\nval\
    idators\x18\x02\x20\x03(\x0b2).cosmos.base.tendermint.v1beta1.ValidatorR\
    \nvalidators\x12G\n\npagination\x18\x03\x20\x01(\x0b2'.cosmos.base.query\
    .v1beta1.PageResponseR\npagination\"f\n\x1cGetLatestValidatorSetRequest\
    \x12F\n\npagination\x18\x01\x20\x01(\x0b2&.cosmos.base.query.v1beta1.Pag\
    eRequestR\npagination\"\xd6\x01\n\x1dGetLatestValidatorSetResponse\x12!\
    \n\x0cblock_height\x18\x01\x20\x01(\x03R\x0bblockHeight\x12I\n\nvalidato\
    rs\x18\x02\x20\x03(\x0b2).cosmos.base.tendermint.v1beta1.ValidatorR\nval\
    idators\x12G\n\npagination\x18\x03\x20\x01(\x0b2'.cosmos.base.query.v1be\
    ta1.PageResponseR\npagination\"\xa4\x01\n\tValidator\x12\x18\n\x07addres\
    s\x18\x01\x20\x01(\tR\x07address\x12-\n\x07pub_key\x18\x02\x20\x01(\x0b2\
    \x14.google.protobuf.AnyR\x06pubKey\x12!\n\x0cvoting_power\x18\x03\x20\
    \x01(\x03R\x0bvotingPower\x12+\n\x11proposer_priority\x18\x04\x20\x01(\
    \x03R\x10proposerPriority\"1\n\x17GetBlockByHeightRequest\x12\x16\n\x06h\
    eight\x18\x01\x20\x01(\x03R\x06height\"\x7f\n\x18GetBlockByHeightRespons\
    e\x124\n\x08block_id\x18\x01\x20\x01(\x0b2\x19.tendermint.types.BlockIDR\
    \x07blockId\x12-\n\x05block\x18\x02\x20\x01(\x0b2\x17.tendermint.types.B\
    lockR\x05block\"\x17\n\x15GetLatestBlockRequest\"}\n\x16GetLatestBlockRe\
    sponse\x124\n\x08block_id\x18\x01\x20\x01(\x0b2\x19.tendermint.types.Blo\
    ckIDR\x07blockId\x12-\n\x05block\x18\x02\x20\x01(\x0b2\x17.tendermint.ty\
    pes.BlockR\x05block\"\x13\n\x11GetSyncingRequest\".\n\x12GetSyncingRespo\
    nse\x12\x18\n\x07syncing\x18\x01\x20\x01(\x08R\x07syncing\"\x14\n\x12Get\
    NodeInfoRequest\"\xc0\x01\n\x13GetNodeInfoResponse\x12K\n\x11default_nod\
    e_info\x18\x01\x20\x01(\x0b2\x1f.tendermint.p2p.DefaultNodeInfoR\x0fdefa\
    ultNodeInfo\x12\\\n\x13application_version\x18\x02\x20\x01(\x0b2+.cosmos\
    .base.tendermint.v1beta1.VersionInfoR\x12applicationVersion\"\xa8\x02\n\
    \x0bVersionInfo\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x19\n\
    \x08app_name\x18\x02\x20\x01(\tR\x07appName\x12\x18\n\x07version\x18\x03\
    \x20\x01(\tR\x07version\x12\x1d\n\ngit_commit\x18\x04\x20\x01(\tR\tgitCo\
    mmit\x12\x1d\n\nbuild_tags\x18\x05\x20\x01(\tR\tbuildTags\x12\x1d\n\ngo_\
    version\x18\x06\x20\x01(\tR\tgoVersion\x12E\n\nbuild_deps\x18\x07\x20\
    \x03(\x0b2&.cosmos.base.tendermint.v1beta1.ModuleR\tbuildDeps\x12,\n\x12\
    cosmos_sdk_version\x18\x08\x20\x01(\tR\x10cosmosSdkVersion\"H\n\x06Modul\
    e\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x18\n\x07version\x18\
    \x02\x20\x01(\tR\x07version\x12\x10\n\x03sum\x18\x03\x20\x01(\tR\x03sum2\
    \x88\t\n\x07Service\x12\xa9\x01\n\x0bGetNodeInfo\x122.cosmos.base.tender\
    mint.v1beta1.GetNodeInfoRequest\x1a3.cosmos.base.tendermint.v1beta1.GetN\
    odeInfoResponse\"1\x82\xd3\xe4\x93\x02+\x12)/cosmos/base/tendermint/v1be\
    ta1/node_info\x12\xa4\x01\n\nGetSyncing\x121.cosmos.base.tendermint.v1be\
    ta1.GetSyncingRequest\x1a2.cosmos.base.tendermint.v1beta1.GetSyncingResp\
    onse\"/\x82\xd3\xe4\x93\x02)\x12'/cosmos/base/tendermint/v1beta1/syncing\
    \x12\xb6\x01\n\x0eGetLatestBlock\x125.cosmos.base.tendermint.v1beta1.Get\
    LatestBlockRequest\x1a6.cosmos.base.tendermint.v1beta1.GetLatestBlockRes\
    ponse\"5\x82\xd3\xe4\x93\x02/\x12-/cosmos/base/tendermint/v1beta1/blocks\
    /latest\x12\xbe\x01\n\x10GetBlockByHeight\x127.cosmos.base.tendermint.v1\
    beta1.GetBlockByHeightRequest\x1a8.cosmos.base.tendermint.v1beta1.GetBlo\
    ckByHeightResponse\"7\x82\xd3\xe4\x93\x021\x12//cosmos/base/tendermint/v\
    1beta1/blocks/{height}\x12\xd2\x01\n\x15GetLatestValidatorSet\x12<.cosmo\
    s.base.tendermint.v1beta1.GetLatestValidatorSetRequest\x1a=.cosmos.base.\
    tendermint.v1beta1.GetLatestValidatorSetResponse\"<\x82\xd3\xe4\x93\x026\
    \x124/cosmos/base/tendermint/v1beta1/validatorsets/latest\x12\xda\x01\n\
    \x17GetValidatorSetByHeight\x12>.cosmos.base.tendermint.v1beta1.GetValid\
    atorSetByHeightRequest\x1a?.cosmos.base.tendermint.v1beta1.GetValidatorS\
    etByHeightResponse\">\x82\xd3\xe4\x93\x028\x126/cosmos/base/tendermint/v\
    1beta1/validatorsets/{height}B4Z2github.com/cosmos/cosmos-sdk/client/grp\
    c/tmserviceJ\x92%\n\x07\x12\x05\0\0\x89\x01\x01\n\x08\n\x01\x0c\x12\x03\
    \0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0'\n\t\n\x02\x03\0\x12\x03\x03\0\
    \x1e\n\t\n\x02\x03\x01\x12\x03\x04\0#\n\t\n\x02\x03\x02\x12\x03\x05\0&\n\
    \t\n\x02\x03\x03\x12\x03\x06\0$\n\t\n\x02\x03\x04\x12\x03\x07\0&\n\t\n\
    \x02\x03\x05\x12\x03\x08\0&\n\t\n\x02\x03\x06\x12\x03\t\04\n\x08\n\x01\
    \x08\x12\x03\x0b\0I\n\t\n\x02\x08\x0b\x12\x03\x0b\0I\nN\n\x02\x06\0\x12\
    \x04\x0e\0(\x01\x1aB\x20Service\x20defines\x20the\x20gRPC\x20querier\x20\
    service\x20for\x20tendermint\x20queries.\n\n\n\n\x03\x06\0\x01\x12\x03\
    \x0e\x08\x0f\n:\n\x04\x06\0\x02\0\x12\x04\x10\x02\x12\x03\x1a,\x20GetNod\
    eInfo\x20queries\x20the\x20current\x20node\x20info.\n\n\x0c\n\x05\x06\0\
    \x02\0\x01\x12\x03\x10\x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x10\
    \x12$\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x10/B\n\x0c\n\x05\x06\0\x02\0\
    \x04\x12\x03\x11\x04O\n\x11\n\n\x06\0\x02\0\x04\xb0\xca\xbc\"\x02\x12\
    \x03\x11\x04O\n0\n\x04\x06\0\x02\x01\x12\x04\x14\x02\x16\x03\x1a\"\x20Ge\
    tSyncing\x20queries\x20node\x20syncing.\n\n\x0c\n\x05\x06\0\x02\x01\x01\
    \x12\x03\x14\x06\x10\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x14\x11\"\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x14-?\n\x0c\n\x05\x06\0\x02\x01\x04\
    \x12\x03\x15\x04M\n\x11\n\n\x06\0\x02\x01\x04\xb0\xca\xbc\"\x02\x12\x03\
    \x15\x04M\n8\n\x04\x06\0\x02\x02\x12\x04\x18\x02\x1a\x03\x1a*\x20GetLate\
    stBlock\x20returns\x20the\x20latest\x20block.\n\n\x0c\n\x05\x06\0\x02\
    \x02\x01\x12\x03\x18\x06\x14\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x18\
    \x15*\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x185K\n\x0c\n\x05\x06\0\x02\
    \x02\x04\x12\x03\x19\x04S\n\x11\n\n\x06\0\x02\x02\x04\xb0\xca\xbc\"\x02\
    \x12\x03\x19\x04S\n@\n\x04\x06\0\x02\x03\x12\x04\x1c\x02\x1e\x03\x1a2\
    \x20GetBlockByHeight\x20queries\x20block\x20for\x20given\x20height.\n\n\
    \x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x1c\x06\x16\n\x0c\n\x05\x06\0\x02\
    \x03\x02\x12\x03\x1c\x17.\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x1c9Q\n\
    \x0c\n\x05\x06\0\x02\x03\x04\x12\x03\x1d\x04U\n\x11\n\n\x06\0\x02\x03\
    \x04\xb0\xca\xbc\"\x02\x12\x03\x1d\x04U\nC\n\x04\x06\0\x02\x04\x12\x04!\
    \x02#\x03\x1a5\x20GetLatestValidatorSet\x20queries\x20latest\x20validato\
    r-set.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03!\x06\x1b\n\x0c\n\x05\x06\
    \0\x02\x04\x02\x12\x03!\x1c8\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03!C`\n\
    \x0c\n\x05\x06\0\x02\x04\x04\x12\x03\"\x04Z\n\x11\n\n\x06\0\x02\x04\x04\
    \xb0\xca\xbc\"\x02\x12\x03\"\x04Z\nP\n\x04\x06\0\x02\x05\x12\x04%\x02'\
    \x03\x1aB\x20GetValidatorSetByHeight\x20queries\x20validator-set\x20at\
    \x20a\x20given\x20height.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03%\x06\
    \x1d\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03%\x1e<\n\x0c\n\x05\x06\0\x02\
    \x05\x03\x12\x03%Gf\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03&\x04\\\n\x11\n\
    \n\x06\0\x02\x05\x04\xb0\xca\xbc\"\x02\x12\x03&\x04\\\nr\n\x02\x04\0\x12\
    \x04+\0/\x01\x1af\x20GetValidatorSetByHeightRequest\x20is\x20the\x20requ\
    est\x20type\x20for\x20the\x20Query/GetValidatorSetByHeight\x20RPC\x20met\
    hod.\n\n\n\n\x03\x04\0\x01\x12\x03+\x08&\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    ,\x02\x13\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03,\x02\x07\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03,\x08\x0e\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03,\x11\x12\
    \n@\n\x04\x04\0\x02\x01\x12\x03.\x027\x1a3\x20pagination\x20defines\x20a\
    n\x20pagination\x20for\x20the\x20request.\n\n\x0c\n\x05\x04\0\x02\x01\
    \x06\x12\x03.\x02'\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03.(2\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03.56\nt\n\x02\x04\x01\x12\x042\07\x01\x1ah\x20G\
    etValidatorSetByHeightResponse\x20is\x20the\x20response\x20type\x20for\
    \x20the\x20Query/GetValidatorSetByHeight\x20RPC\x20method.\n\n\n\n\x03\
    \x04\x01\x01\x12\x032\x08'\n\x0b\n\x04\x04\x01\x02\0\x12\x033\x02&\n\x0c\
    \n\x05\x04\x01\x02\0\x05\x12\x033\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x033\x15!\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x033$%\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x034\x02&\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x034\x02\
    \n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x034\x0b\x14\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x034\x15\x1f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x034$%\
    \nA\n\x04\x04\x01\x02\x02\x12\x036\x028\x1a4\x20pagination\x20defines\
    \x20an\x20pagination\x20for\x20the\x20response.\n\n\x0c\n\x05\x04\x01\
    \x02\x02\x06\x12\x036\x02(\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x036)3\n\
    \x0c\n\x05\x04\x01\x02\x02\x03\x12\x03667\np\n\x02\x04\x02\x12\x04:\0=\
    \x01\x1ad\x20GetLatestValidatorSetRequest\x20is\x20the\x20request\x20typ\
    e\x20for\x20the\x20Query/GetValidatorSetByHeight\x20RPC\x20method.\n\n\n\
    \n\x03\x04\x02\x01\x12\x03:\x08$\n@\n\x04\x04\x02\x02\0\x12\x03<\x027\
    \x1a3\x20pagination\x20defines\x20an\x20pagination\x20for\x20the\x20requ\
    est.\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03<\x02'\n\x0c\n\x05\x04\x02\
    \x02\0\x01\x12\x03<(2\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03<56\nr\n\x02\
    \x04\x03\x12\x04@\0E\x01\x1af\x20GetLatestValidatorSetResponse\x20is\x20\
    the\x20response\x20type\x20for\x20the\x20Query/GetValidatorSetByHeight\
    \x20RPC\x20method.\n\n\n\n\x03\x04\x03\x01\x12\x03@\x08%\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03A\x02&\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03A\x02\x07\
    \n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03A\x15!\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03A$%\n\x0b\n\x04\x04\x03\x02\x01\x12\x03B\x02&\n\x0c\n\x05\
    \x04\x03\x02\x01\x04\x12\x03B\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\
    \x03B\x0b\x14\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03B\x15\x1f\n\x0c\n\
    \x05\x04\x03\x02\x01\x03\x12\x03B$%\nA\n\x04\x04\x03\x02\x02\x12\x03D\
    \x028\x1a4\x20pagination\x20defines\x20an\x20pagination\x20for\x20the\
    \x20response.\n\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03D\x02(\n\x0c\n\
    \x05\x04\x03\x02\x02\x01\x12\x03D)3\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\
    \x03D67\n:\n\x02\x04\x04\x12\x04H\0M\x01\x1a.\x20Validator\x20is\x20the\
    \x20type\x20for\x20the\x20validator-set.\n\n\n\n\x03\x04\x04\x01\x12\x03\
    H\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03I\x02,\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03I\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03I\x16\
    \x1d\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03I*+\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x03J\x02,\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03J\x02\x15\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03J\x16\x1d\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03J*+\n\x0b\n\x04\x04\x04\x02\x02\x12\x03K\x02,\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03K\x02\x07\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03K\x16\"\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03K*+\n\x0b\n\
    \x04\x04\x04\x02\x03\x12\x03L\x02,\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\
    \x03L\x02\x07\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03L\x16'\n\x0c\n\x05\
    \x04\x04\x02\x03\x03\x12\x03L*+\nd\n\x02\x04\x05\x12\x04P\0R\x01\x1aX\
    \x20GetBlockByHeightRequest\x20is\x20the\x20request\x20type\x20for\x20th\
    e\x20Query/GetBlockByHeight\x20RPC\x20method.\n\n\n\n\x03\x04\x05\x01\
    \x12\x03P\x08\x1f\n\x0b\n\x04\x04\x05\x02\0\x12\x03Q\x02\x13\n\x0c\n\x05\
    \x04\x05\x02\0\x05\x12\x03Q\x02\x07\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03Q\x08\x0e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03Q\x11\x12\nf\n\x02\
    \x04\x06\x12\x04U\0X\x01\x1aZ\x20GetBlockByHeightResponse\x20is\x20the\
    \x20response\x20type\x20for\x20the\x20Query/GetBlockByHeight\x20RPC\x20m\
    ethod.\n\n\n\n\x03\x04\x06\x01\x12\x03U\x08\x20\n\x0b\n\x04\x04\x06\x02\
    \0\x12\x03V\x02)\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03V\x02\x1b\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03V\x1c$\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03V'(\n\x0b\n\x04\x04\x06\x02\x01\x12\x03W\x02)\n\x0c\n\x05\x04\x06\
    \x02\x01\x06\x12\x03W\x02\x19\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03W\
    \x1c!\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03W'(\n_\n\x02\x04\x07\x12\
    \x03[\0\x20\x1aT\x20GetLatestBlockRequest\x20is\x20the\x20request\x20typ\
    e\x20for\x20the\x20Query/GetLatestBlock\x20RPC\x20method.\n\n\n\n\x03\
    \x04\x07\x01\x12\x03[\x08\x1d\nb\n\x02\x04\x08\x12\x04^\0a\x01\x1aV\x20G\
    etLatestBlockResponse\x20is\x20the\x20response\x20type\x20for\x20the\x20\
    Query/GetLatestBlock\x20RPC\x20method.\n\n\n\n\x03\x04\x08\x01\x12\x03^\
    \x08\x1e\n\x0b\n\x04\x04\x08\x02\0\x12\x03_\x02)\n\x0c\n\x05\x04\x08\x02\
    \0\x06\x12\x03_\x02\x1b\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03_\x1c$\n\
    \x0c\n\x05\x04\x08\x02\0\x03\x12\x03_'(\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03`\x02)\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03`\x02\x19\n\x0c\n\x05\
    \x04\x08\x02\x01\x01\x12\x03`\x1c!\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\
    \x03`'(\nW\n\x02\x04\t\x12\x03d\0\x1c\x1aL\x20GetSyncingRequest\x20is\
    \x20the\x20request\x20type\x20for\x20the\x20Query/GetSyncing\x20RPC\x20m\
    ethod.\n\n\n\n\x03\x04\t\x01\x12\x03d\x08\x19\nZ\n\x02\x04\n\x12\x04g\0i\
    \x01\x1aN\x20GetSyncingResponse\x20is\x20the\x20response\x20type\x20for\
    \x20the\x20Query/GetSyncing\x20RPC\x20method.\n\n\n\n\x03\x04\n\x01\x12\
    \x03g\x08\x1a\n\x0b\n\x04\x04\n\x02\0\x12\x03h\x02\x13\n\x0c\n\x05\x04\n\
    \x02\0\x05\x12\x03h\x02\x06\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03h\x07\x0e\
    \n\x0c\n\x05\x04\n\x02\0\x03\x12\x03h\x11\x12\nY\n\x02\x04\x0b\x12\x03l\
    \0\x1d\x1aN\x20GetNodeInfoRequest\x20is\x20the\x20request\x20type\x20for\
    \x20the\x20Query/GetNodeInfo\x20RPC\x20method.\n\n\n\n\x03\x04\x0b\x01\
    \x12\x03l\x08\x1a\n[\n\x02\x04\x0c\x12\x04o\0r\x01\x1aO\x20GetNodeInfoRe\
    sponse\x20is\x20the\x20request\x20type\x20for\x20the\x20Query/GetNodeInf\
    o\x20RPC\x20method.\n\n\n\n\x03\x04\x0c\x01\x12\x03o\x08\x1b\n\x0b\n\x04\
    \x04\x0c\x02\0\x12\x03p\x02:\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03p\x02!\
    \n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03p\"3\n\x0c\n\x05\x04\x0c\x02\0\x03\
    \x12\x03p89\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03q\x02:\n\x0c\n\x05\x04\
    \x0c\x02\x01\x06\x12\x03q\x02\r\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03q\
    \"5\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03q89\nJ\n\x02\x04\r\x12\x04u\0\
    \x7f\x01\x1a>\x20VersionInfo\x20is\x20the\x20type\x20for\x20the\x20GetNo\
    deInfoResponse\x20message.\n\n\n\n\x03\x04\r\x01\x12\x03u\x08\x13\n\x0b\
    \n\x04\x04\r\x02\0\x12\x03v\x02)\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03v\
    \x02\x08\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03v\x12\x16\n\x0c\n\x05\x04\r\
    \x02\0\x03\x12\x03v'(\n\x0b\n\x04\x04\r\x02\x01\x12\x03w\x02)\n\x0c\n\
    \x05\x04\r\x02\x01\x05\x12\x03w\x02\x08\n\x0c\n\x05\x04\r\x02\x01\x01\
    \x12\x03w\x12\x1a\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03w'(\n\x0b\n\x04\
    \x04\r\x02\x02\x12\x03x\x02)\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03x\x02\
    \x08\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03x\x12\x19\n\x0c\n\x05\x04\r\
    \x02\x02\x03\x12\x03x'(\n\x0b\n\x04\x04\r\x02\x03\x12\x03y\x02)\n\x0c\n\
    \x05\x04\r\x02\x03\x05\x12\x03y\x02\x08\n\x0c\n\x05\x04\r\x02\x03\x01\
    \x12\x03y\x12\x1c\n\x0c\n\x05\x04\r\x02\x03\x03\x12\x03y'(\n\x0b\n\x04\
    \x04\r\x02\x04\x12\x03z\x02)\n\x0c\n\x05\x04\r\x02\x04\x05\x12\x03z\x02\
    \x08\n\x0c\n\x05\x04\r\x02\x04\x01\x12\x03z\x12\x1c\n\x0c\n\x05\x04\r\
    \x02\x04\x03\x12\x03z'(\n\x0b\n\x04\x04\r\x02\x05\x12\x03{\x02)\n\x0c\n\
    \x05\x04\r\x02\x05\x05\x12\x03{\x02\x08\n\x0c\n\x05\x04\r\x02\x05\x01\
    \x12\x03{\x12\x1c\n\x0c\n\x05\x04\r\x02\x05\x03\x12\x03{'(\n\x0b\n\x04\
    \x04\r\x02\x06\x12\x03|\x02)\n\x0c\n\x05\x04\r\x02\x06\x04\x12\x03|\x02\
    \n\n\x0c\n\x05\x04\r\x02\x06\x06\x12\x03|\x0b\x11\n\x0c\n\x05\x04\r\x02\
    \x06\x01\x12\x03|\x12\x1c\n\x0c\n\x05\x04\r\x02\x06\x03\x12\x03|'(\n%\n\
    \x04\x04\r\x02\x07\x12\x03~\x02)\x1a\x18\x20Since:\x20cosmos-sdk\x200.43\
    \n\n\x0c\n\x05\x04\r\x02\x07\x05\x12\x03~\x02\x08\n\x0c\n\x05\x04\r\x02\
    \x07\x01\x12\x03~\x12$\n\x0c\n\x05\x04\r\x02\x07\x03\x12\x03~'(\n2\n\x02\
    \x04\x0e\x12\x06\x82\x01\0\x89\x01\x01\x1a$\x20Module\x20is\x20the\x20ty\
    pe\x20for\x20VersionInfo\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x82\x01\x08\
    \x0e\n\x1b\n\x04\x04\x0e\x02\0\x12\x04\x84\x01\x02\x12\x1a\r\x20module\
    \x20path\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x84\x01\x02\x08\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\x84\x01\t\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\x84\x01\x10\x11\n\x1e\n\x04\x04\x0e\x02\x01\x12\x04\x86\x01\x02\x15\
    \x1a\x10\x20module\x20version\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\
    \x86\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x86\x01\t\x10\n\r\
    \n\x05\x04\x0e\x02\x01\x03\x12\x04\x86\x01\x13\x14\n\x18\n\x04\x04\x0e\
    \x02\x02\x12\x04\x88\x01\x02\x11\x1a\n\x20checksum\n\n\r\n\x05\x04\x0e\
    \x02\x02\x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x02\x01\x12\
    \x04\x88\x01\t\x0c\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x88\x01\x0f\x10\
    b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(7);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(super::block::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(super::pagination::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(GetValidatorSetByHeightRequest::generated_message_descriptor_data());
            messages.push(GetValidatorSetByHeightResponse::generated_message_descriptor_data());
            messages.push(GetLatestValidatorSetRequest::generated_message_descriptor_data());
            messages.push(GetLatestValidatorSetResponse::generated_message_descriptor_data());
            messages.push(Validator::generated_message_descriptor_data());
            messages.push(GetBlockByHeightRequest::generated_message_descriptor_data());
            messages.push(GetBlockByHeightResponse::generated_message_descriptor_data());
            messages.push(GetLatestBlockRequest::generated_message_descriptor_data());
            messages.push(GetLatestBlockResponse::generated_message_descriptor_data());
            messages.push(GetSyncingRequest::generated_message_descriptor_data());
            messages.push(GetSyncingResponse::generated_message_descriptor_data());
            messages.push(GetNodeInfoRequest::generated_message_descriptor_data());
            messages.push(GetNodeInfoResponse::generated_message_descriptor_data());
            messages.push(VersionInfo::generated_message_descriptor_data());
            messages.push(Module::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
