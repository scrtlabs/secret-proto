// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cosmos/tx/signing/v1beta1/signing.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  SignatureDescriptors wraps multiple SignatureDescriptor's.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.tx.signing.v1beta1.SignatureDescriptors)
pub struct SignatureDescriptors {
    // message fields
    ///  signatures are the signature descriptors
    // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptors.signatures)
    pub signatures: ::std::vec::Vec<SignatureDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.tx.signing.v1beta1.SignatureDescriptors.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignatureDescriptors {
    fn default() -> &'a SignatureDescriptors {
        <SignatureDescriptors as ::protobuf::Message>::default_instance()
    }
}

impl SignatureDescriptors {
    pub fn new() -> SignatureDescriptors {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &SignatureDescriptors| { &m.signatures },
            |m: &mut SignatureDescriptors| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignatureDescriptors>(
            "SignatureDescriptors",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignatureDescriptors {
    const NAME: &'static str = "SignatureDescriptors";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signatures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.signatures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignatureDescriptors {
        SignatureDescriptors::new()
    }

    fn clear(&mut self) {
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignatureDescriptors {
        static instance: SignatureDescriptors = SignatureDescriptors {
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignatureDescriptors {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignatureDescriptors").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignatureDescriptors {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignatureDescriptors {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SignatureDescriptor is a convenience type which represents the full data for
///  a signature including the public key of the signer, signing modes and the
///  signature itself. It is primarily used for coordinating signatures between
///  clients.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cosmos.tx.signing.v1beta1.SignatureDescriptor)
pub struct SignatureDescriptor {
    // message fields
    ///  public_key is the public key of the signer
    // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptor.public_key)
    pub public_key: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptor.data)
    pub data: ::protobuf::MessageField<signature_descriptor::Data>,
    ///  sequence is the sequence of the account, which describes the
    ///  number of committed transactions signed by a given address. It is used to prevent
    ///  replay attacks.
    // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptor.sequence)
    pub sequence: u64,
    // special fields
    // @@protoc_insertion_point(special_field:cosmos.tx.signing.v1beta1.SignatureDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignatureDescriptor {
    fn default() -> &'a SignatureDescriptor {
        <SignatureDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl SignatureDescriptor {
    pub fn new() -> SignatureDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "public_key",
            |m: &SignatureDescriptor| { &m.public_key },
            |m: &mut SignatureDescriptor| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, signature_descriptor::Data>(
            "data",
            |m: &SignatureDescriptor| { &m.data },
            |m: &mut SignatureDescriptor| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &SignatureDescriptor| { &m.sequence },
            |m: &mut SignatureDescriptor| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignatureDescriptor>(
            "SignatureDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignatureDescriptor {
    const NAME: &'static str = "SignatureDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_key)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                24 => {
                    self.sequence = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.public_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.public_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignatureDescriptor {
        SignatureDescriptor::new()
    }

    fn clear(&mut self) {
        self.public_key.clear();
        self.data.clear();
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignatureDescriptor {
        static instance: SignatureDescriptor = SignatureDescriptor {
            public_key: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignatureDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignatureDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignatureDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignatureDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SignatureDescriptor`
pub mod signature_descriptor {
    ///  Data represents signature data
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data)
    pub struct Data {
        // message oneof groups
        pub sum: ::std::option::Option<data::Sum>,
        // special fields
        // @@protoc_insertion_point(special_field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }

        // .cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single single = 1;

        pub fn single(&self) -> &data::Single {
            match self.sum {
                ::std::option::Option::Some(data::Sum::Single(ref v)) => v,
                _ => <data::Single as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_single(&mut self) {
            self.sum = ::std::option::Option::None;
        }

        pub fn has_single(&self) -> bool {
            match self.sum {
                ::std::option::Option::Some(data::Sum::Single(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_single(&mut self, v: data::Single) {
            self.sum = ::std::option::Option::Some(data::Sum::Single(v))
        }

        // Mutable pointer to the field.
        pub fn mut_single(&mut self) -> &mut data::Single {
            if let ::std::option::Option::Some(data::Sum::Single(_)) = self.sum {
            } else {
                self.sum = ::std::option::Option::Some(data::Sum::Single(data::Single::new()));
            }
            match self.sum {
                ::std::option::Option::Some(data::Sum::Single(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_single(&mut self) -> data::Single {
            if self.has_single() {
                match self.sum.take() {
                    ::std::option::Option::Some(data::Sum::Single(v)) => v,
                    _ => panic!(),
                }
            } else {
                data::Single::new()
            }
        }

        // .cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi multi = 2;

        pub fn multi(&self) -> &data::Multi {
            match self.sum {
                ::std::option::Option::Some(data::Sum::Multi(ref v)) => v,
                _ => <data::Multi as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_multi(&mut self) {
            self.sum = ::std::option::Option::None;
        }

        pub fn has_multi(&self) -> bool {
            match self.sum {
                ::std::option::Option::Some(data::Sum::Multi(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_multi(&mut self, v: data::Multi) {
            self.sum = ::std::option::Option::Some(data::Sum::Multi(v))
        }

        // Mutable pointer to the field.
        pub fn mut_multi(&mut self) -> &mut data::Multi {
            if let ::std::option::Option::Some(data::Sum::Multi(_)) = self.sum {
            } else {
                self.sum = ::std::option::Option::Some(data::Sum::Multi(data::Multi::new()));
            }
            match self.sum {
                ::std::option::Option::Some(data::Sum::Multi(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_multi(&mut self) -> data::Multi {
            if self.has_multi() {
                match self.sum.take() {
                    ::std::option::Option::Some(data::Sum::Multi(v)) => v,
                    _ => panic!(),
                }
            } else {
                data::Multi::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data::Single>(
                "single",
                Data::has_single,
                Data::single,
                Data::mut_single,
                Data::set_single,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data::Multi>(
                "multi",
                Data::has_multi,
                Data::multi,
                Data::mut_multi,
                Data::set_multi,
            ));
            oneofs.push(data::Sum::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Data>(
                "SignatureDescriptor.Data",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.sum = ::std::option::Option::Some(data::Sum::Single(is.read_message()?));
                    },
                    18 => {
                        self.sum = ::std::option::Option::Some(data::Sum::Multi(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.sum {
                match v {
                    &data::Sum::Single(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &data::Sum::Multi(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.sum {
                match v {
                    &data::Sum::Single(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &data::Sum::Multi(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.sum = ::std::option::Option::None;
            self.sum = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                sum: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Data {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SignatureDescriptor.Data").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Data {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Data {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Data`
    pub mod data {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.sum)
        pub enum Sum {
            // @@protoc_insertion_point(oneof_field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.single)
            Single(Single),
            // @@protoc_insertion_point(oneof_field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.multi)
            Multi(Multi),
        }

        impl ::protobuf::Oneof for Sum {
        }

        impl ::protobuf::OneofFull for Sum {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Data as ::protobuf::MessageFull>::descriptor().oneof_by_name("sum").unwrap()).clone()
            }
        }

        impl Sum {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sum>("sum")
            }
        }
        ///  Single is the signature data for a single signer
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single)
        pub struct Single {
            // message fields
            ///  mode is the signing mode of the single signer
            // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.mode)
            pub mode: ::protobuf::EnumOrUnknown<super::super::SignMode>,
            ///  signature is the raw signature bytes
            // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.signature)
            pub signature: ::std::vec::Vec<u8>,
            // special fields
            // @@protoc_insertion_point(special_field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Single {
            fn default() -> &'a Single {
                <Single as ::protobuf::Message>::default_instance()
            }
        }

        impl Single {
            pub fn new() -> Single {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "mode",
                    |m: &Single| { &m.mode },
                    |m: &mut Single| { &mut m.mode },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "signature",
                    |m: &Single| { &m.signature },
                    |m: &mut Single| { &mut m.signature },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Single>(
                    "SignatureDescriptor.Data.Single",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Single {
            const NAME: &'static str = "Single";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.mode = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.signature = is.read_bytes()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.mode != ::protobuf::EnumOrUnknown::new(super::super::SignMode::SIGN_MODE_UNSPECIFIED) {
                    my_size += ::protobuf::rt::int32_size(1, self.mode.value());
                }
                if !self.signature.is_empty() {
                    my_size += ::protobuf::rt::bytes_size(2, &self.signature);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.mode != ::protobuf::EnumOrUnknown::new(super::super::SignMode::SIGN_MODE_UNSPECIFIED) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.mode))?;
                }
                if !self.signature.is_empty() {
                    os.write_bytes(2, &self.signature)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Single {
                Single::new()
            }

            fn clear(&mut self) {
                self.mode = ::protobuf::EnumOrUnknown::new(super::super::SignMode::SIGN_MODE_UNSPECIFIED);
                self.signature.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Single {
                static instance: Single = Single {
                    mode: ::protobuf::EnumOrUnknown::from_i32(0),
                    signature: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Single {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SignatureDescriptor.Data.Single").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Single {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Single {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        ///  Multi is the signature data for a multisig public key
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi)
        pub struct Multi {
            // message fields
            ///  bitarray specifies which keys within the multisig are signing
            // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.bitarray)
            pub bitarray: ::protobuf::MessageField<super::super::super::multisig::CompactBitArray>,
            ///  signatures is the signatures of the multi-signature
            // @@protoc_insertion_point(field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.signatures)
            pub signatures: ::std::vec::Vec<super::Data>,
            // special fields
            // @@protoc_insertion_point(special_field:cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Multi {
            fn default() -> &'a Multi {
                <Multi as ::protobuf::Message>::default_instance()
            }
        }

        impl Multi {
            pub fn new() -> Multi {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::multisig::CompactBitArray>(
                    "bitarray",
                    |m: &Multi| { &m.bitarray },
                    |m: &mut Multi| { &mut m.bitarray },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "signatures",
                    |m: &Multi| { &m.signatures },
                    |m: &mut Multi| { &mut m.signatures },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Multi>(
                    "SignatureDescriptor.Data.Multi",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Multi {
            const NAME: &'static str = "Multi";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.bitarray)?;
                        },
                        18 => {
                            self.signatures.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.bitarray.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                for value in &self.signatures {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.bitarray.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                }
                for v in &self.signatures {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Multi {
                Multi::new()
            }

            fn clear(&mut self) {
                self.bitarray.clear();
                self.signatures.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Multi {
                static instance: Multi = Multi {
                    bitarray: ::protobuf::MessageField::none(),
                    signatures: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Multi {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SignatureDescriptor.Data.Multi").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Multi {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Multi {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

///  SignMode represents a signing mode with its own security guarantees.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cosmos.tx.signing.v1beta1.SignMode)
pub enum SignMode {
    // @@protoc_insertion_point(enum_value:cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_UNSPECIFIED)
    SIGN_MODE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_DIRECT)
    SIGN_MODE_DIRECT = 1,
    // @@protoc_insertion_point(enum_value:cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_TEXTUAL)
    SIGN_MODE_TEXTUAL = 2,
    // @@protoc_insertion_point(enum_value:cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON)
    SIGN_MODE_LEGACY_AMINO_JSON = 127,
    // @@protoc_insertion_point(enum_value:cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_EIP_191)
    SIGN_MODE_EIP_191 = 191,
}

impl ::protobuf::Enum for SignMode {
    const NAME: &'static str = "SignMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SignMode> {
        match value {
            0 => ::std::option::Option::Some(SignMode::SIGN_MODE_UNSPECIFIED),
            1 => ::std::option::Option::Some(SignMode::SIGN_MODE_DIRECT),
            2 => ::std::option::Option::Some(SignMode::SIGN_MODE_TEXTUAL),
            127 => ::std::option::Option::Some(SignMode::SIGN_MODE_LEGACY_AMINO_JSON),
            191 => ::std::option::Option::Some(SignMode::SIGN_MODE_EIP_191),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SignMode] = &[
        SignMode::SIGN_MODE_UNSPECIFIED,
        SignMode::SIGN_MODE_DIRECT,
        SignMode::SIGN_MODE_TEXTUAL,
        SignMode::SIGN_MODE_LEGACY_AMINO_JSON,
        SignMode::SIGN_MODE_EIP_191,
    ];
}

impl ::protobuf::EnumFull for SignMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SignMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SignMode::SIGN_MODE_UNSPECIFIED => 0,
            SignMode::SIGN_MODE_DIRECT => 1,
            SignMode::SIGN_MODE_TEXTUAL => 2,
            SignMode::SIGN_MODE_LEGACY_AMINO_JSON => 3,
            SignMode::SIGN_MODE_EIP_191 => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SignMode {
    fn default() -> Self {
        SignMode::SIGN_MODE_UNSPECIFIED
    }
}

impl SignMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SignMode>("SignMode")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'cosmos/tx/signing/v1beta1/signing.proto\x12\x19cosmos.tx.signing.v1be\
    ta1\x1a-cosmos/crypto/multisig/v1beta1/multisig.proto\x1a\x19google/prot\
    obuf/any.proto\"f\n\x14SignatureDescriptors\x12N\n\nsignatures\x18\x01\
    \x20\x03(\x0b2..cosmos.tx.signing.v1beta1.SignatureDescriptorR\nsignatur\
    es\"\xf5\x04\n\x13SignatureDescriptor\x123\n\npublic_key\x18\x01\x20\x01\
    (\x0b2\x14.google.protobuf.AnyR\tpublicKey\x12G\n\x04data\x18\x02\x20\
    \x01(\x0b23.cosmos.tx.signing.v1beta1.SignatureDescriptor.DataR\x04data\
    \x12\x1a\n\x08sequence\x18\x03\x20\x01(\x04R\x08sequence\x1a\xc3\x03\n\
    \x04Data\x12T\n\x06single\x18\x01\x20\x01(\x0b2:.cosmos.tx.signing.v1bet\
    a1.SignatureDescriptor.Data.SingleH\0R\x06single\x12Q\n\x05multi\x18\x02\
    \x20\x01(\x0b29.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi\
    H\0R\x05multi\x1a_\n\x06Single\x127\n\x04mode\x18\x01\x20\x01(\x0e2#.cos\
    mos.tx.signing.v1beta1.SignModeR\x04mode\x12\x1c\n\tsignature\x18\x02\
    \x20\x01(\x0cR\tsignature\x1a\xa9\x01\n\x05Multi\x12K\n\x08bitarray\x18\
    \x01\x20\x01(\x0b2/.cosmos.crypto.multisig.v1beta1.CompactBitArrayR\x08b\
    itarray\x12S\n\nsignatures\x18\x02\x20\x03(\x0b23.cosmos.tx.signing.v1be\
    ta1.SignatureDescriptor.DataR\nsignaturesB\x05\n\x03sum*\x8b\x01\n\x08Si\
    gnMode\x12\x19\n\x15SIGN_MODE_UNSPECIFIED\x10\0\x12\x14\n\x10SIGN_MODE_D\
    IRECT\x10\x01\x12\x15\n\x11SIGN_MODE_TEXTUAL\x10\x02\x12\x1f\n\x1bSIGN_M\
    ODE_LEGACY_AMINO_JSON\x10\x7f\x12\x16\n\x11SIGN_MODE_EIP_191\x10\xbf\x01\
    B/Z-github.com/cosmos/cosmos-sdk/types/tx/signingJ\x92\x19\n\x06\x12\x04\
    \0\0Z\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\
    \"\n\t\n\x02\x03\0\x12\x03\x03\07\n\t\n\x02\x03\x01\x12\x03\x04\0#\n\x08\
    \n\x01\x08\x12\x03\x06\0D\n\t\n\x02\x08\x0b\x12\x03\x06\0D\nR\n\x02\x05\
    \0\x12\x04\t\0&\x01\x1aF\x20SignMode\x20represents\x20a\x20signing\x20mo\
    de\x20with\x20its\x20own\x20security\x20guarantees.\n\n\n\n\x03\x05\0\
    \x01\x12\x03\t\x05\r\n\\\n\x04\x05\0\x02\0\x12\x03\x0c\x02\x1c\x1aO\x20S\
    IGN_MODE_UNSPECIFIED\x20specifies\x20an\x20unknown\x20signing\x20mode\
    \x20and\x20will\x20be\n\x20rejected\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\
    \x03\x0c\x02\x17\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x0c\x1a\x1b\ns\n\
    \x04\x05\0\x02\x01\x12\x03\x10\x02\x17\x1af\x20SIGN_MODE_DIRECT\x20speci\
    fies\x20a\x20signing\x20mode\x20which\x20uses\x20SignDoc\x20and\x20is\n\
    \x20verified\x20with\x20raw\x20bytes\x20from\x20Tx\n\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x10\x02\x12\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\
    \x10\x15\x16\n\xb2\x01\n\x04\x05\0\x02\x02\x12\x03\x15\x02\x18\x1a\xa4\
    \x01\x20SIGN_MODE_TEXTUAL\x20is\x20a\x20future\x20signing\x20mode\x20tha\
    t\x20will\x20verify\x20some\n\x20human-readable\x20textual\x20representa\
    tion\x20on\x20top\x20of\x20the\x20binary\x20representation\n\x20from\x20\
    SIGN_MODE_DIRECT\n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x15\x02\x13\n\
    \x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x15\x16\x17\n\x85\x01\n\x04\x05\0\
    \x02\x03\x12\x03\x19\x02$\x1ax\x20SIGN_MODE_LEGACY_AMINO_JSON\x20is\x20a\
    \x20backwards\x20compatibility\x20mode\x20which\x20uses\n\x20Amino\x20JS\
    ON\x20and\x20will\x20be\x20removed\x20in\x20the\x20future\n\n\x0c\n\x05\
    \x05\0\x02\x03\x01\x12\x03\x19\x02\x1d\n\x0c\n\x05\x05\0\x02\x03\x02\x12\
    \x03\x19\x20#\n\xd4\x03\n\x04\x05\0\x02\x04\x12\x03%\x02\x1a\x1a\xc6\x03\
    \x20SIGN_MODE_EIP_191\x20specifies\x20the\x20sign\x20mode\x20for\x20EIP\
    \x20191\x20signing\x20on\x20the\x20Cosmos\n\x20SDK.\x20Ref:\x20https://e\
    ips.ethereum.org/EIPS/eip-191\n\x20\n\x20Currently,\x20SIGN_MODE_EIP_191\
    \x20is\x20registered\x20as\x20a\x20SignMode\x20enum\x20variant,\n\x20but\
    \x20is\x20not\x20implemented\x20on\x20the\x20SDK\x20by\x20default.\x20To\
    \x20enable\x20EIP-191,\x20you\x20need\n\x20to\x20pass\x20a\x20custom\x20\
    `TxConfig`\x20that\x20has\x20an\x20implementation\x20of\n\x20`SignModeHa\
    ndler`\x20for\x20EIP-191.\x20The\x20SDK\x20may\x20decide\x20to\x20fully\
    \x20support\n\x20EIP-191\x20in\x20the\x20future.\n\n\x20Since:\x20cosmos\
    -sdk\x200.45.2\n\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03%\x02\x13\n\x0c\n\
    \x05\x05\0\x02\x04\x02\x12\x03%\x16\x19\nH\n\x02\x04\0\x12\x04)\0,\x01\
    \x1a<\x20SignatureDescriptors\x20wraps\x20multiple\x20SignatureDescripto\
    r's.\n\n\n\n\x03\x04\0\x01\x12\x03)\x08\x1c\n7\n\x04\x04\0\x02\0\x12\x03\
    +\x02.\x1a*\x20signatures\x20are\x20the\x20signature\x20descriptors\n\n\
    \x0c\n\x05\x04\0\x02\0\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\0\x02\0\x06\
    \x12\x03+\x0b\x1e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03+\x1f)\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03+,-\n\xfc\x01\n\x02\x04\x01\x12\x042\0Z\x01\x1a\
    \xef\x01\x20SignatureDescriptor\x20is\x20a\x20convenience\x20type\x20whi\
    ch\x20represents\x20the\x20full\x20data\x20for\n\x20a\x20signature\x20in\
    cluding\x20the\x20public\x20key\x20of\x20the\x20signer,\x20signing\x20mo\
    des\x20and\x20the\n\x20signature\x20itself.\x20It\x20is\x20primarily\x20\
    used\x20for\x20coordinating\x20signatures\x20between\n\x20clients.\n\n\n\
    \n\x03\x04\x01\x01\x12\x032\x08\x1b\n9\n\x04\x04\x01\x02\0\x12\x034\x02%\
    \x1a,\x20public_key\x20is\x20the\x20public\x20key\x20of\x20the\x20signer\
    \n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x034\x02\x15\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x034\x16\x20\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x034#$\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x036\x02\x10\n\x0c\n\x05\x04\x01\x02\x01\
    \x06\x12\x036\x02\x06\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x036\x07\x0b\n\
    \x0c\n\x05\x04\x01\x02\x01\x03\x12\x036\x0e\x0f\n\xb0\x01\n\x04\x04\x01\
    \x02\x02\x12\x03;\x02\x16\x1a\xa2\x01\x20sequence\x20is\x20the\x20sequen\
    ce\x20of\x20the\x20account,\x20which\x20describes\x20the\n\x20number\x20\
    of\x20committed\x20transactions\x20signed\x20by\x20a\x20given\x20address\
    .\x20It\x20is\x20used\x20to\x20prevent\n\x20replay\x20attacks.\n\n\x0c\n\
    \x05\x04\x01\x02\x02\x05\x12\x03;\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03;\t\x11\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03;\x14\x15\n.\
    \n\x04\x04\x01\x03\0\x12\x04>\x02Y\x03\x1a\x20\x20Data\x20represents\x20\
    signature\x20data\n\n\x0c\n\x05\x04\x01\x03\0\x01\x12\x03>\n\x0e\nh\n\
    \x06\x04\x01\x03\0\x08\0\x12\x04@\x04F\x05\x1aX\x20sum\x20is\x20the\x20o\
    neof\x20that\x20specifies\x20whether\x20this\x20represents\x20single\x20\
    or\x20multi-signature\x20data\n\n\x0e\n\x07\x04\x01\x03\0\x08\0\x01\x12\
    \x03@\n\r\n2\n\x06\x04\x01\x03\0\x02\0\x12\x03B\x06\x18\x1a#\x20single\
    \x20represents\x20a\x20single\x20signer\n\n\x0e\n\x07\x04\x01\x03\0\x02\
    \0\x06\x12\x03B\x06\x0c\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\x12\x03B\r\
    \x13\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x03B\x16\x17\n3\n\x06\x04\
    \x01\x03\0\x02\x01\x12\x03E\x06\x16\x1a$\x20multi\x20represents\x20a\x20\
    multisig\x20signer\n\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x06\x12\x03E\x06\
    \x0b\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x03E\x0c\x11\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x01\x03\x12\x03E\x14\x15\nB\n\x06\x04\x01\x03\0\x03\0\
    \x12\x04I\x04O\x05\x1a2\x20Single\x20is\x20the\x20signature\x20data\x20f\
    or\x20a\x20single\x20signer\n\n\x0e\n\x07\x04\x01\x03\0\x03\0\x01\x12\
    \x03I\x0c\x12\n@\n\x08\x04\x01\x03\0\x03\0\x02\0\x12\x03K\x06\x18\x1a/\
    \x20mode\x20is\x20the\x20signing\x20mode\x20of\x20the\x20single\x20signe\
    r\n\n\x10\n\t\x04\x01\x03\0\x03\0\x02\0\x06\x12\x03K\x06\x0e\n\x10\n\t\
    \x04\x01\x03\0\x03\0\x02\0\x01\x12\x03K\x0f\x13\n\x10\n\t\x04\x01\x03\0\
    \x03\0\x02\0\x03\x12\x03K\x16\x17\n7\n\x08\x04\x01\x03\0\x03\0\x02\x01\
    \x12\x03N\x06\x1a\x1a&\x20signature\x20is\x20the\x20raw\x20signature\x20\
    bytes\n\n\x10\n\t\x04\x01\x03\0\x03\0\x02\x01\x05\x12\x03N\x06\x0b\n\x10\
    \n\t\x04\x01\x03\0\x03\0\x02\x01\x01\x12\x03N\x0c\x15\n\x10\n\t\x04\x01\
    \x03\0\x03\0\x02\x01\x03\x12\x03N\x18\x19\nG\n\x06\x04\x01\x03\0\x03\x01\
    \x12\x04R\x04X\x05\x1a7\x20Multi\x20is\x20the\x20signature\x20data\x20fo\
    r\x20a\x20multisig\x20public\x20key\n\n\x0e\n\x07\x04\x01\x03\0\x03\x01\
    \x01\x12\x03R\x0c\x11\nP\n\x08\x04\x01\x03\0\x03\x01\x02\0\x12\x03T\x06B\
    \x1a?\x20bitarray\x20specifies\x20which\x20keys\x20within\x20the\x20mult\
    isig\x20are\x20signing\n\n\x10\n\t\x04\x01\x03\0\x03\x01\x02\0\x06\x12\
    \x03T\x064\n\x10\n\t\x04\x01\x03\0\x03\x01\x02\0\x01\x12\x03T5=\n\x10\n\
    \t\x04\x01\x03\0\x03\x01\x02\0\x03\x12\x03T@A\nF\n\x08\x04\x01\x03\0\x03\
    \x01\x02\x01\x12\x03W\x06#\x1a5\x20signatures\x20is\x20the\x20signatures\
    \x20of\x20the\x20multi-signature\n\n\x10\n\t\x04\x01\x03\0\x03\x01\x02\
    \x01\x04\x12\x03W\x06\x0e\n\x10\n\t\x04\x01\x03\0\x03\x01\x02\x01\x06\
    \x12\x03W\x0f\x13\n\x10\n\t\x04\x01\x03\0\x03\x01\x02\x01\x01\x12\x03W\
    \x14\x1e\n\x10\n\t\x04\x01\x03\0\x03\x01\x02\x01\x03\x12\x03W!\"b\x06pro\
    to3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::multisig::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(SignatureDescriptors::generated_message_descriptor_data());
            messages.push(SignatureDescriptor::generated_message_descriptor_data());
            messages.push(signature_descriptor::Data::generated_message_descriptor_data());
            messages.push(signature_descriptor::data::Single::generated_message_descriptor_data());
            messages.push(signature_descriptor::data::Multi::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(SignMode::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
