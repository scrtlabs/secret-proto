// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tendermint/abci/types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.Request)
pub struct Request {
    // message oneof groups
    pub value: ::std::option::Option<request::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // .tendermint.abci.RequestEcho echo = 1;

    pub fn echo(&self) -> &RequestEcho {
        match self.value {
            ::std::option::Option::Some(request::Value::Echo(ref v)) => v,
            _ => <RequestEcho as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_echo(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_echo(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::Echo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_echo(&mut self, v: RequestEcho) {
        self.value = ::std::option::Option::Some(request::Value::Echo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_echo(&mut self) -> &mut RequestEcho {
        if let ::std::option::Option::Some(request::Value::Echo(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::Echo(RequestEcho::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::Echo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_echo(&mut self) -> RequestEcho {
        if self.has_echo() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::Echo(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestEcho::new()
        }
    }

    // .tendermint.abci.RequestFlush flush = 2;

    pub fn flush(&self) -> &RequestFlush {
        match self.value {
            ::std::option::Option::Some(request::Value::Flush(ref v)) => v,
            _ => <RequestFlush as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_flush(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_flush(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::Flush(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_flush(&mut self, v: RequestFlush) {
        self.value = ::std::option::Option::Some(request::Value::Flush(v))
    }

    // Mutable pointer to the field.
    pub fn mut_flush(&mut self) -> &mut RequestFlush {
        if let ::std::option::Option::Some(request::Value::Flush(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::Flush(RequestFlush::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::Flush(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_flush(&mut self) -> RequestFlush {
        if self.has_flush() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::Flush(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestFlush::new()
        }
    }

    // .tendermint.abci.RequestInfo info = 3;

    pub fn info(&self) -> &RequestInfo {
        match self.value {
            ::std::option::Option::Some(request::Value::Info(ref v)) => v,
            _ => <RequestInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_info(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::Info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: RequestInfo) {
        self.value = ::std::option::Option::Some(request::Value::Info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_info(&mut self) -> &mut RequestInfo {
        if let ::std::option::Option::Some(request::Value::Info(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::Info(RequestInfo::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::Info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_info(&mut self) -> RequestInfo {
        if self.has_info() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::Info(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestInfo::new()
        }
    }

    // .tendermint.abci.RequestSetOption set_option = 4;

    pub fn set_option(&self) -> &RequestSetOption {
        match self.value {
            ::std::option::Option::Some(request::Value::SetOption(ref v)) => v,
            _ => <RequestSetOption as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_option(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_set_option(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::SetOption(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_option(&mut self, v: RequestSetOption) {
        self.value = ::std::option::Option::Some(request::Value::SetOption(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_option(&mut self) -> &mut RequestSetOption {
        if let ::std::option::Option::Some(request::Value::SetOption(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::SetOption(RequestSetOption::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::SetOption(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_option(&mut self) -> RequestSetOption {
        if self.has_set_option() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::SetOption(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestSetOption::new()
        }
    }

    // .tendermint.abci.RequestInitChain init_chain = 5;

    pub fn init_chain(&self) -> &RequestInitChain {
        match self.value {
            ::std::option::Option::Some(request::Value::InitChain(ref v)) => v,
            _ => <RequestInitChain as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_init_chain(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_init_chain(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::InitChain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_init_chain(&mut self, v: RequestInitChain) {
        self.value = ::std::option::Option::Some(request::Value::InitChain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_init_chain(&mut self) -> &mut RequestInitChain {
        if let ::std::option::Option::Some(request::Value::InitChain(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::InitChain(RequestInitChain::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::InitChain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_init_chain(&mut self) -> RequestInitChain {
        if self.has_init_chain() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::InitChain(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestInitChain::new()
        }
    }

    // .tendermint.abci.RequestQuery query = 6;

    pub fn query(&self) -> &RequestQuery {
        match self.value {
            ::std::option::Option::Some(request::Value::Query(ref v)) => v,
            _ => <RequestQuery as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_query(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::Query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: RequestQuery) {
        self.value = ::std::option::Option::Some(request::Value::Query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut RequestQuery {
        if let ::std::option::Option::Some(request::Value::Query(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::Query(RequestQuery::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::Query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> RequestQuery {
        if self.has_query() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::Query(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestQuery::new()
        }
    }

    // .tendermint.abci.RequestBeginBlock begin_block = 7;

    pub fn begin_block(&self) -> &RequestBeginBlock {
        match self.value {
            ::std::option::Option::Some(request::Value::BeginBlock(ref v)) => v,
            _ => <RequestBeginBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_begin_block(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_begin_block(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::BeginBlock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_begin_block(&mut self, v: RequestBeginBlock) {
        self.value = ::std::option::Option::Some(request::Value::BeginBlock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_begin_block(&mut self) -> &mut RequestBeginBlock {
        if let ::std::option::Option::Some(request::Value::BeginBlock(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::BeginBlock(RequestBeginBlock::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::BeginBlock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_begin_block(&mut self) -> RequestBeginBlock {
        if self.has_begin_block() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::BeginBlock(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestBeginBlock::new()
        }
    }

    // .tendermint.abci.RequestCheckTx check_tx = 8;

    pub fn check_tx(&self) -> &RequestCheckTx {
        match self.value {
            ::std::option::Option::Some(request::Value::CheckTx(ref v)) => v,
            _ => <RequestCheckTx as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_check_tx(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_check_tx(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::CheckTx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_check_tx(&mut self, v: RequestCheckTx) {
        self.value = ::std::option::Option::Some(request::Value::CheckTx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_check_tx(&mut self) -> &mut RequestCheckTx {
        if let ::std::option::Option::Some(request::Value::CheckTx(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::CheckTx(RequestCheckTx::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::CheckTx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_check_tx(&mut self) -> RequestCheckTx {
        if self.has_check_tx() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::CheckTx(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestCheckTx::new()
        }
    }

    // .tendermint.abci.RequestDeliverTx deliver_tx = 9;

    pub fn deliver_tx(&self) -> &RequestDeliverTx {
        match self.value {
            ::std::option::Option::Some(request::Value::DeliverTx(ref v)) => v,
            _ => <RequestDeliverTx as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_deliver_tx(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_deliver_tx(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::DeliverTx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deliver_tx(&mut self, v: RequestDeliverTx) {
        self.value = ::std::option::Option::Some(request::Value::DeliverTx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_deliver_tx(&mut self) -> &mut RequestDeliverTx {
        if let ::std::option::Option::Some(request::Value::DeliverTx(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::DeliverTx(RequestDeliverTx::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::DeliverTx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deliver_tx(&mut self) -> RequestDeliverTx {
        if self.has_deliver_tx() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::DeliverTx(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestDeliverTx::new()
        }
    }

    // .tendermint.abci.RequestEndBlock end_block = 10;

    pub fn end_block(&self) -> &RequestEndBlock {
        match self.value {
            ::std::option::Option::Some(request::Value::EndBlock(ref v)) => v,
            _ => <RequestEndBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_end_block(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_end_block(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::EndBlock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_block(&mut self, v: RequestEndBlock) {
        self.value = ::std::option::Option::Some(request::Value::EndBlock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_block(&mut self) -> &mut RequestEndBlock {
        if let ::std::option::Option::Some(request::Value::EndBlock(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::EndBlock(RequestEndBlock::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::EndBlock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_block(&mut self) -> RequestEndBlock {
        if self.has_end_block() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::EndBlock(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestEndBlock::new()
        }
    }

    // .tendermint.abci.RequestCommit commit = 11;

    pub fn commit(&self) -> &RequestCommit {
        match self.value {
            ::std::option::Option::Some(request::Value::Commit(ref v)) => v,
            _ => <RequestCommit as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_commit(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_commit(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::Commit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_commit(&mut self, v: RequestCommit) {
        self.value = ::std::option::Option::Some(request::Value::Commit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_commit(&mut self) -> &mut RequestCommit {
        if let ::std::option::Option::Some(request::Value::Commit(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::Commit(RequestCommit::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::Commit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_commit(&mut self) -> RequestCommit {
        if self.has_commit() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::Commit(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestCommit::new()
        }
    }

    // .tendermint.abci.RequestListSnapshots list_snapshots = 12;

    pub fn list_snapshots(&self) -> &RequestListSnapshots {
        match self.value {
            ::std::option::Option::Some(request::Value::ListSnapshots(ref v)) => v,
            _ => <RequestListSnapshots as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_snapshots(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_list_snapshots(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::ListSnapshots(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_snapshots(&mut self, v: RequestListSnapshots) {
        self.value = ::std::option::Option::Some(request::Value::ListSnapshots(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_snapshots(&mut self) -> &mut RequestListSnapshots {
        if let ::std::option::Option::Some(request::Value::ListSnapshots(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::ListSnapshots(RequestListSnapshots::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::ListSnapshots(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_snapshots(&mut self) -> RequestListSnapshots {
        if self.has_list_snapshots() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::ListSnapshots(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestListSnapshots::new()
        }
    }

    // .tendermint.abci.RequestOfferSnapshot offer_snapshot = 13;

    pub fn offer_snapshot(&self) -> &RequestOfferSnapshot {
        match self.value {
            ::std::option::Option::Some(request::Value::OfferSnapshot(ref v)) => v,
            _ => <RequestOfferSnapshot as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_offer_snapshot(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_offer_snapshot(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::OfferSnapshot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offer_snapshot(&mut self, v: RequestOfferSnapshot) {
        self.value = ::std::option::Option::Some(request::Value::OfferSnapshot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_offer_snapshot(&mut self) -> &mut RequestOfferSnapshot {
        if let ::std::option::Option::Some(request::Value::OfferSnapshot(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::OfferSnapshot(RequestOfferSnapshot::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::OfferSnapshot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_offer_snapshot(&mut self) -> RequestOfferSnapshot {
        if self.has_offer_snapshot() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::OfferSnapshot(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestOfferSnapshot::new()
        }
    }

    // .tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14;

    pub fn load_snapshot_chunk(&self) -> &RequestLoadSnapshotChunk {
        match self.value {
            ::std::option::Option::Some(request::Value::LoadSnapshotChunk(ref v)) => v,
            _ => <RequestLoadSnapshotChunk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_load_snapshot_chunk(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_load_snapshot_chunk(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::LoadSnapshotChunk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_load_snapshot_chunk(&mut self, v: RequestLoadSnapshotChunk) {
        self.value = ::std::option::Option::Some(request::Value::LoadSnapshotChunk(v))
    }

    // Mutable pointer to the field.
    pub fn mut_load_snapshot_chunk(&mut self) -> &mut RequestLoadSnapshotChunk {
        if let ::std::option::Option::Some(request::Value::LoadSnapshotChunk(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::LoadSnapshotChunk(RequestLoadSnapshotChunk::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::LoadSnapshotChunk(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_load_snapshot_chunk(&mut self) -> RequestLoadSnapshotChunk {
        if self.has_load_snapshot_chunk() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::LoadSnapshotChunk(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestLoadSnapshotChunk::new()
        }
    }

    // .tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15;

    pub fn apply_snapshot_chunk(&self) -> &RequestApplySnapshotChunk {
        match self.value {
            ::std::option::Option::Some(request::Value::ApplySnapshotChunk(ref v)) => v,
            _ => <RequestApplySnapshotChunk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_apply_snapshot_chunk(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_apply_snapshot_chunk(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(request::Value::ApplySnapshotChunk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_snapshot_chunk(&mut self, v: RequestApplySnapshotChunk) {
        self.value = ::std::option::Option::Some(request::Value::ApplySnapshotChunk(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_snapshot_chunk(&mut self) -> &mut RequestApplySnapshotChunk {
        if let ::std::option::Option::Some(request::Value::ApplySnapshotChunk(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(request::Value::ApplySnapshotChunk(RequestApplySnapshotChunk::new()));
        }
        match self.value {
            ::std::option::Option::Some(request::Value::ApplySnapshotChunk(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_snapshot_chunk(&mut self) -> RequestApplySnapshotChunk {
        if self.has_apply_snapshot_chunk() {
            match self.value.take() {
                ::std::option::Option::Some(request::Value::ApplySnapshotChunk(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestApplySnapshotChunk::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestEcho>(
            "echo",
            Request::has_echo,
            Request::echo,
            Request::mut_echo,
            Request::set_echo,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestFlush>(
            "flush",
            Request::has_flush,
            Request::flush,
            Request::mut_flush,
            Request::set_flush,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestInfo>(
            "info",
            Request::has_info,
            Request::info,
            Request::mut_info,
            Request::set_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestSetOption>(
            "set_option",
            Request::has_set_option,
            Request::set_option,
            Request::mut_set_option,
            Request::set_set_option,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestInitChain>(
            "init_chain",
            Request::has_init_chain,
            Request::init_chain,
            Request::mut_init_chain,
            Request::set_init_chain,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestQuery>(
            "query",
            Request::has_query,
            Request::query,
            Request::mut_query,
            Request::set_query,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestBeginBlock>(
            "begin_block",
            Request::has_begin_block,
            Request::begin_block,
            Request::mut_begin_block,
            Request::set_begin_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestCheckTx>(
            "check_tx",
            Request::has_check_tx,
            Request::check_tx,
            Request::mut_check_tx,
            Request::set_check_tx,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestDeliverTx>(
            "deliver_tx",
            Request::has_deliver_tx,
            Request::deliver_tx,
            Request::mut_deliver_tx,
            Request::set_deliver_tx,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestEndBlock>(
            "end_block",
            Request::has_end_block,
            Request::end_block,
            Request::mut_end_block,
            Request::set_end_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestCommit>(
            "commit",
            Request::has_commit,
            Request::commit,
            Request::mut_commit,
            Request::set_commit,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestListSnapshots>(
            "list_snapshots",
            Request::has_list_snapshots,
            Request::list_snapshots,
            Request::mut_list_snapshots,
            Request::set_list_snapshots,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestOfferSnapshot>(
            "offer_snapshot",
            Request::has_offer_snapshot,
            Request::offer_snapshot,
            Request::mut_offer_snapshot,
            Request::set_offer_snapshot,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestLoadSnapshotChunk>(
            "load_snapshot_chunk",
            Request::has_load_snapshot_chunk,
            Request::load_snapshot_chunk,
            Request::mut_load_snapshot_chunk,
            Request::set_load_snapshot_chunk,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestApplySnapshotChunk>(
            "apply_snapshot_chunk",
            Request::has_apply_snapshot_chunk,
            Request::apply_snapshot_chunk,
            Request::mut_apply_snapshot_chunk,
            Request::set_apply_snapshot_chunk,
        ));
        oneofs.push(request::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Request>(
            "Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Request {
    const NAME: &'static str = "Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(request::Value::Echo(is.read_message()?));
                },
                18 => {
                    self.value = ::std::option::Option::Some(request::Value::Flush(is.read_message()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(request::Value::Info(is.read_message()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(request::Value::SetOption(is.read_message()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(request::Value::InitChain(is.read_message()?));
                },
                50 => {
                    self.value = ::std::option::Option::Some(request::Value::Query(is.read_message()?));
                },
                58 => {
                    self.value = ::std::option::Option::Some(request::Value::BeginBlock(is.read_message()?));
                },
                66 => {
                    self.value = ::std::option::Option::Some(request::Value::CheckTx(is.read_message()?));
                },
                74 => {
                    self.value = ::std::option::Option::Some(request::Value::DeliverTx(is.read_message()?));
                },
                82 => {
                    self.value = ::std::option::Option::Some(request::Value::EndBlock(is.read_message()?));
                },
                90 => {
                    self.value = ::std::option::Option::Some(request::Value::Commit(is.read_message()?));
                },
                98 => {
                    self.value = ::std::option::Option::Some(request::Value::ListSnapshots(is.read_message()?));
                },
                106 => {
                    self.value = ::std::option::Option::Some(request::Value::OfferSnapshot(is.read_message()?));
                },
                114 => {
                    self.value = ::std::option::Option::Some(request::Value::LoadSnapshotChunk(is.read_message()?));
                },
                122 => {
                    self.value = ::std::option::Option::Some(request::Value::ApplySnapshotChunk(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &request::Value::Echo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::Flush(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::Info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::SetOption(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::InitChain(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::Query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::BeginBlock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::CheckTx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::DeliverTx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::EndBlock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::Commit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::ListSnapshots(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::OfferSnapshot(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::LoadSnapshotChunk(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Value::ApplySnapshotChunk(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &request::Value::Echo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &request::Value::Flush(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &request::Value::Info(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &request::Value::SetOption(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &request::Value::InitChain(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &request::Value::Query(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &request::Value::BeginBlock(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &request::Value::CheckTx(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &request::Value::DeliverTx(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &request::Value::EndBlock(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &request::Value::Commit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &request::Value::ListSnapshots(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &request::Value::OfferSnapshot(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &request::Value::LoadSnapshotChunk(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &request::Value::ApplySnapshotChunk(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Request {
        Request::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Request {
        static instance: Request = Request {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Request`
pub mod request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:tendermint.abci.Request.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.echo)
        Echo(super::RequestEcho),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.flush)
        Flush(super::RequestFlush),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.info)
        Info(super::RequestInfo),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.set_option)
        SetOption(super::RequestSetOption),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.init_chain)
        InitChain(super::RequestInitChain),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.query)
        Query(super::RequestQuery),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.begin_block)
        BeginBlock(super::RequestBeginBlock),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.check_tx)
        CheckTx(super::RequestCheckTx),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.deliver_tx)
        DeliverTx(super::RequestDeliverTx),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.end_block)
        EndBlock(super::RequestEndBlock),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.commit)
        Commit(super::RequestCommit),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.list_snapshots)
        ListSnapshots(super::RequestListSnapshots),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.offer_snapshot)
        OfferSnapshot(super::RequestOfferSnapshot),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.load_snapshot_chunk)
        LoadSnapshotChunk(super::RequestLoadSnapshotChunk),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Request.apply_snapshot_chunk)
        ApplySnapshotChunk(super::RequestApplySnapshotChunk),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Request as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestEcho)
pub struct RequestEcho {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestEcho.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestEcho.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestEcho {
    fn default() -> &'a RequestEcho {
        <RequestEcho as ::protobuf::Message>::default_instance()
    }
}

impl RequestEcho {
    pub fn new() -> RequestEcho {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &RequestEcho| { &m.message },
            |m: &mut RequestEcho| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestEcho>(
            "RequestEcho",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestEcho {
    const NAME: &'static str = "RequestEcho";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestEcho {
        RequestEcho::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestEcho {
        static instance: RequestEcho = RequestEcho {
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestEcho {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestEcho").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestEcho {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestEcho {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestFlush)
pub struct RequestFlush {
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestFlush.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestFlush {
    fn default() -> &'a RequestFlush {
        <RequestFlush as ::protobuf::Message>::default_instance()
    }
}

impl RequestFlush {
    pub fn new() -> RequestFlush {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestFlush>(
            "RequestFlush",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestFlush {
    const NAME: &'static str = "RequestFlush";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestFlush {
        RequestFlush::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestFlush {
        static instance: RequestFlush = RequestFlush {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestFlush {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestFlush").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestFlush {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestFlush {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestInfo)
pub struct RequestInfo {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestInfo.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.RequestInfo.block_version)
    pub block_version: u64,
    // @@protoc_insertion_point(field:tendermint.abci.RequestInfo.p2p_version)
    pub p2p_version: u64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestInfo {
    fn default() -> &'a RequestInfo {
        <RequestInfo as ::protobuf::Message>::default_instance()
    }
}

impl RequestInfo {
    pub fn new() -> RequestInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &RequestInfo| { &m.version },
            |m: &mut RequestInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_version",
            |m: &RequestInfo| { &m.block_version },
            |m: &mut RequestInfo| { &mut m.block_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "p2p_version",
            |m: &RequestInfo| { &m.p2p_version },
            |m: &mut RequestInfo| { &mut m.p2p_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestInfo>(
            "RequestInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestInfo {
    const NAME: &'static str = "RequestInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = is.read_string()?;
                },
                16 => {
                    self.block_version = is.read_uint64()?;
                },
                24 => {
                    self.p2p_version = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if self.block_version != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.block_version);
        }
        if self.p2p_version != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.p2p_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if self.block_version != 0 {
            os.write_uint64(2, self.block_version)?;
        }
        if self.p2p_version != 0 {
            os.write_uint64(3, self.p2p_version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestInfo {
        RequestInfo::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.block_version = 0;
        self.p2p_version = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestInfo {
        static instance: RequestInfo = RequestInfo {
            version: ::std::string::String::new(),
            block_version: 0,
            p2p_version: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  nondeterministic
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestSetOption)
pub struct RequestSetOption {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestSetOption.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.RequestSetOption.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestSetOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestSetOption {
    fn default() -> &'a RequestSetOption {
        <RequestSetOption as ::protobuf::Message>::default_instance()
    }
}

impl RequestSetOption {
    pub fn new() -> RequestSetOption {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &RequestSetOption| { &m.key },
            |m: &mut RequestSetOption| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &RequestSetOption| { &m.value },
            |m: &mut RequestSetOption| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestSetOption>(
            "RequestSetOption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestSetOption {
    const NAME: &'static str = "RequestSetOption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestSetOption {
        RequestSetOption::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestSetOption {
        static instance: RequestSetOption = RequestSetOption {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestSetOption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestSetOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestSetOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestSetOption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestInitChain)
pub struct RequestInitChain {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestInitChain.time)
    pub time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestInitChain.chain_id)
    pub chain_id: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.RequestInitChain.consensus_params)
    pub consensus_params: ::protobuf::MessageField<ConsensusParams>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestInitChain.validators)
    pub validators: ::std::vec::Vec<ValidatorUpdate>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestInitChain.app_state_bytes)
    pub app_state_bytes: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestInitChain.initial_height)
    pub initial_height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestInitChain.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestInitChain {
    fn default() -> &'a RequestInitChain {
        <RequestInitChain as ::protobuf::Message>::default_instance()
    }
}

impl RequestInitChain {
    pub fn new() -> RequestInitChain {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            |m: &RequestInitChain| { &m.time },
            |m: &mut RequestInitChain| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &RequestInitChain| { &m.chain_id },
            |m: &mut RequestInitChain| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConsensusParams>(
            "consensus_params",
            |m: &RequestInitChain| { &m.consensus_params },
            |m: &mut RequestInitChain| { &mut m.consensus_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validators",
            |m: &RequestInitChain| { &m.validators },
            |m: &mut RequestInitChain| { &mut m.validators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_state_bytes",
            |m: &RequestInitChain| { &m.app_state_bytes },
            |m: &mut RequestInitChain| { &mut m.app_state_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "initial_height",
            |m: &RequestInitChain| { &m.initial_height },
            |m: &mut RequestInitChain| { &mut m.initial_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestInitChain>(
            "RequestInitChain",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestInitChain {
    const NAME: &'static str = "RequestInitChain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                18 => {
                    self.chain_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_params)?;
                },
                34 => {
                    self.validators.push(is.read_message()?);
                },
                42 => {
                    self.app_state_bytes = is.read_bytes()?;
                },
                48 => {
                    self.initial_height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chain_id);
        }
        if let Some(v) = self.consensus_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.app_state_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.app_state_bytes);
        }
        if self.initial_height != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.initial_height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(2, &self.chain_id)?;
        }
        if let Some(v) = self.consensus_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.validators {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if !self.app_state_bytes.is_empty() {
            os.write_bytes(5, &self.app_state_bytes)?;
        }
        if self.initial_height != 0 {
            os.write_int64(6, self.initial_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestInitChain {
        RequestInitChain::new()
    }

    fn clear(&mut self) {
        self.time.clear();
        self.chain_id.clear();
        self.consensus_params.clear();
        self.validators.clear();
        self.app_state_bytes.clear();
        self.initial_height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestInitChain {
        static instance: RequestInitChain = RequestInitChain {
            time: ::protobuf::MessageField::none(),
            chain_id: ::std::string::String::new(),
            consensus_params: ::protobuf::MessageField::none(),
            validators: ::std::vec::Vec::new(),
            app_state_bytes: ::std::vec::Vec::new(),
            initial_height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestInitChain {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestInitChain").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestInitChain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestInitChain {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestQuery)
pub struct RequestQuery {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestQuery.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestQuery.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.RequestQuery.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.abci.RequestQuery.prove)
    pub prove: bool,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQuery {
    fn default() -> &'a RequestQuery {
        <RequestQuery as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuery {
    pub fn new() -> RequestQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &RequestQuery| { &m.data },
            |m: &mut RequestQuery| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &RequestQuery| { &m.path },
            |m: &mut RequestQuery| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &RequestQuery| { &m.height },
            |m: &mut RequestQuery| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prove",
            |m: &RequestQuery| { &m.prove },
            |m: &mut RequestQuery| { &mut m.prove },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQuery>(
            "RequestQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQuery {
    const NAME: &'static str = "RequestQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.height = is.read_int64()?;
                },
                32 => {
                    self.prove = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.height);
        }
        if self.prove != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.height != 0 {
            os.write_int64(3, self.height)?;
        }
        if self.prove != false {
            os.write_bool(4, self.prove)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQuery {
        RequestQuery::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.path.clear();
        self.height = 0;
        self.prove = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQuery {
        static instance: RequestQuery = RequestQuery {
            data: ::std::vec::Vec::new(),
            path: ::std::string::String::new(),
            height: 0,
            prove: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestBeginBlock)
pub struct RequestBeginBlock {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestBeginBlock.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestBeginBlock.header)
    pub header: ::protobuf::MessageField<super::types::Header>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestBeginBlock.last_commit_info)
    pub last_commit_info: ::protobuf::MessageField<LastCommitInfo>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestBeginBlock.byzantine_validators)
    pub byzantine_validators: ::std::vec::Vec<Evidence>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestBeginBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestBeginBlock {
    fn default() -> &'a RequestBeginBlock {
        <RequestBeginBlock as ::protobuf::Message>::default_instance()
    }
}

impl RequestBeginBlock {
    pub fn new() -> RequestBeginBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &RequestBeginBlock| { &m.hash },
            |m: &mut RequestBeginBlock| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Header>(
            "header",
            |m: &RequestBeginBlock| { &m.header },
            |m: &mut RequestBeginBlock| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LastCommitInfo>(
            "last_commit_info",
            |m: &RequestBeginBlock| { &m.last_commit_info },
            |m: &mut RequestBeginBlock| { &mut m.last_commit_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "byzantine_validators",
            |m: &RequestBeginBlock| { &m.byzantine_validators },
            |m: &mut RequestBeginBlock| { &mut m.byzantine_validators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestBeginBlock>(
            "RequestBeginBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestBeginBlock {
    const NAME: &'static str = "RequestBeginBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_commit_info)?;
                },
                34 => {
                    self.byzantine_validators.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_commit_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.byzantine_validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.last_commit_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.byzantine_validators {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestBeginBlock {
        RequestBeginBlock::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.header.clear();
        self.last_commit_info.clear();
        self.byzantine_validators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestBeginBlock {
        static instance: RequestBeginBlock = RequestBeginBlock {
            hash: ::std::vec::Vec::new(),
            header: ::protobuf::MessageField::none(),
            last_commit_info: ::protobuf::MessageField::none(),
            byzantine_validators: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestBeginBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestBeginBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestBeginBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestBeginBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestCheckTx)
pub struct RequestCheckTx {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestCheckTx.tx)
    pub tx: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestCheckTx.type)
    pub type_: ::protobuf::EnumOrUnknown<CheckTxType>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestCheckTx.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestCheckTx {
    fn default() -> &'a RequestCheckTx {
        <RequestCheckTx as ::protobuf::Message>::default_instance()
    }
}

impl RequestCheckTx {
    pub fn new() -> RequestCheckTx {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx",
            |m: &RequestCheckTx| { &m.tx },
            |m: &mut RequestCheckTx| { &mut m.tx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &RequestCheckTx| { &m.type_ },
            |m: &mut RequestCheckTx| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestCheckTx>(
            "RequestCheckTx",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestCheckTx {
    const NAME: &'static str = "RequestCheckTx";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tx = is.read_bytes()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.tx);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(CheckTxType::NEW) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tx.is_empty() {
            os.write_bytes(1, &self.tx)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(CheckTxType::NEW) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestCheckTx {
        RequestCheckTx::new()
    }

    fn clear(&mut self) {
        self.tx.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(CheckTxType::NEW);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestCheckTx {
        static instance: RequestCheckTx = RequestCheckTx {
            tx: ::std::vec::Vec::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestCheckTx {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestCheckTx").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestCheckTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestCheckTx {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestDeliverTx)
pub struct RequestDeliverTx {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestDeliverTx.tx)
    pub tx: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestDeliverTx.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestDeliverTx {
    fn default() -> &'a RequestDeliverTx {
        <RequestDeliverTx as ::protobuf::Message>::default_instance()
    }
}

impl RequestDeliverTx {
    pub fn new() -> RequestDeliverTx {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx",
            |m: &RequestDeliverTx| { &m.tx },
            |m: &mut RequestDeliverTx| { &mut m.tx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestDeliverTx>(
            "RequestDeliverTx",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestDeliverTx {
    const NAME: &'static str = "RequestDeliverTx";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tx = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.tx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tx.is_empty() {
            os.write_bytes(1, &self.tx)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestDeliverTx {
        RequestDeliverTx::new()
    }

    fn clear(&mut self) {
        self.tx.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestDeliverTx {
        static instance: RequestDeliverTx = RequestDeliverTx {
            tx: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestDeliverTx {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestDeliverTx").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestDeliverTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestDeliverTx {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestEndBlock)
pub struct RequestEndBlock {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestEndBlock.height)
    pub height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestEndBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestEndBlock {
    fn default() -> &'a RequestEndBlock {
        <RequestEndBlock as ::protobuf::Message>::default_instance()
    }
}

impl RequestEndBlock {
    pub fn new() -> RequestEndBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &RequestEndBlock| { &m.height },
            |m: &mut RequestEndBlock| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestEndBlock>(
            "RequestEndBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestEndBlock {
    const NAME: &'static str = "RequestEndBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestEndBlock {
        RequestEndBlock::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestEndBlock {
        static instance: RequestEndBlock = RequestEndBlock {
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestEndBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestEndBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestEndBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestEndBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestCommit)
pub struct RequestCommit {
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestCommit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestCommit {
    fn default() -> &'a RequestCommit {
        <RequestCommit as ::protobuf::Message>::default_instance()
    }
}

impl RequestCommit {
    pub fn new() -> RequestCommit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestCommit>(
            "RequestCommit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestCommit {
    const NAME: &'static str = "RequestCommit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestCommit {
        RequestCommit::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestCommit {
        static instance: RequestCommit = RequestCommit {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestCommit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestCommit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestCommit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  lists available snapshots
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestListSnapshots)
pub struct RequestListSnapshots {
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestListSnapshots.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestListSnapshots {
    fn default() -> &'a RequestListSnapshots {
        <RequestListSnapshots as ::protobuf::Message>::default_instance()
    }
}

impl RequestListSnapshots {
    pub fn new() -> RequestListSnapshots {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestListSnapshots>(
            "RequestListSnapshots",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestListSnapshots {
    const NAME: &'static str = "RequestListSnapshots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestListSnapshots {
        RequestListSnapshots::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestListSnapshots {
        static instance: RequestListSnapshots = RequestListSnapshots {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestListSnapshots {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestListSnapshots").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestListSnapshots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestListSnapshots {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  offers a snapshot to the application
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestOfferSnapshot)
pub struct RequestOfferSnapshot {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestOfferSnapshot.snapshot)
    pub snapshot: ::protobuf::MessageField<Snapshot>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestOfferSnapshot.app_hash)
    pub app_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestOfferSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestOfferSnapshot {
    fn default() -> &'a RequestOfferSnapshot {
        <RequestOfferSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl RequestOfferSnapshot {
    pub fn new() -> RequestOfferSnapshot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Snapshot>(
            "snapshot",
            |m: &RequestOfferSnapshot| { &m.snapshot },
            |m: &mut RequestOfferSnapshot| { &mut m.snapshot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_hash",
            |m: &RequestOfferSnapshot| { &m.app_hash },
            |m: &mut RequestOfferSnapshot| { &mut m.app_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestOfferSnapshot>(
            "RequestOfferSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestOfferSnapshot {
    const NAME: &'static str = "RequestOfferSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.snapshot)?;
                },
                18 => {
                    self.app_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.snapshot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.app_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.snapshot.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.app_hash.is_empty() {
            os.write_bytes(2, &self.app_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestOfferSnapshot {
        RequestOfferSnapshot::new()
    }

    fn clear(&mut self) {
        self.snapshot.clear();
        self.app_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestOfferSnapshot {
        static instance: RequestOfferSnapshot = RequestOfferSnapshot {
            snapshot: ::protobuf::MessageField::none(),
            app_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestOfferSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestOfferSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestOfferSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestOfferSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  loads a snapshot chunk
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestLoadSnapshotChunk)
pub struct RequestLoadSnapshotChunk {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestLoadSnapshotChunk.height)
    pub height: u64,
    // @@protoc_insertion_point(field:tendermint.abci.RequestLoadSnapshotChunk.format)
    pub format: u32,
    // @@protoc_insertion_point(field:tendermint.abci.RequestLoadSnapshotChunk.chunk)
    pub chunk: u32,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestLoadSnapshotChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestLoadSnapshotChunk {
    fn default() -> &'a RequestLoadSnapshotChunk {
        <RequestLoadSnapshotChunk as ::protobuf::Message>::default_instance()
    }
}

impl RequestLoadSnapshotChunk {
    pub fn new() -> RequestLoadSnapshotChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &RequestLoadSnapshotChunk| { &m.height },
            |m: &mut RequestLoadSnapshotChunk| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &RequestLoadSnapshotChunk| { &m.format },
            |m: &mut RequestLoadSnapshotChunk| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chunk",
            |m: &RequestLoadSnapshotChunk| { &m.chunk },
            |m: &mut RequestLoadSnapshotChunk| { &mut m.chunk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestLoadSnapshotChunk>(
            "RequestLoadSnapshotChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestLoadSnapshotChunk {
    const NAME: &'static str = "RequestLoadSnapshotChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_uint64()?;
                },
                16 => {
                    self.format = is.read_uint32()?;
                },
                24 => {
                    self.chunk = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.height);
        }
        if self.format != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.format);
        }
        if self.chunk != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.chunk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_uint64(1, self.height)?;
        }
        if self.format != 0 {
            os.write_uint32(2, self.format)?;
        }
        if self.chunk != 0 {
            os.write_uint32(3, self.chunk)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestLoadSnapshotChunk {
        RequestLoadSnapshotChunk::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.format = 0;
        self.chunk = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestLoadSnapshotChunk {
        static instance: RequestLoadSnapshotChunk = RequestLoadSnapshotChunk {
            height: 0,
            format: 0,
            chunk: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestLoadSnapshotChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestLoadSnapshotChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestLoadSnapshotChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestLoadSnapshotChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Applies a snapshot chunk
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.RequestApplySnapshotChunk)
pub struct RequestApplySnapshotChunk {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.RequestApplySnapshotChunk.index)
    pub index: u32,
    // @@protoc_insertion_point(field:tendermint.abci.RequestApplySnapshotChunk.chunk)
    pub chunk: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.RequestApplySnapshotChunk.sender)
    pub sender: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.RequestApplySnapshotChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestApplySnapshotChunk {
    fn default() -> &'a RequestApplySnapshotChunk {
        <RequestApplySnapshotChunk as ::protobuf::Message>::default_instance()
    }
}

impl RequestApplySnapshotChunk {
    pub fn new() -> RequestApplySnapshotChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &RequestApplySnapshotChunk| { &m.index },
            |m: &mut RequestApplySnapshotChunk| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chunk",
            |m: &RequestApplySnapshotChunk| { &m.chunk },
            |m: &mut RequestApplySnapshotChunk| { &mut m.chunk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sender",
            |m: &RequestApplySnapshotChunk| { &m.sender },
            |m: &mut RequestApplySnapshotChunk| { &mut m.sender },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestApplySnapshotChunk>(
            "RequestApplySnapshotChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestApplySnapshotChunk {
    const NAME: &'static str = "RequestApplySnapshotChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = is.read_uint32()?;
                },
                18 => {
                    self.chunk = is.read_bytes()?;
                },
                26 => {
                    self.sender = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.index);
        }
        if !self.chunk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.chunk);
        }
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sender);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if !self.chunk.is_empty() {
            os.write_bytes(2, &self.chunk)?;
        }
        if !self.sender.is_empty() {
            os.write_string(3, &self.sender)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestApplySnapshotChunk {
        RequestApplySnapshotChunk::new()
    }

    fn clear(&mut self) {
        self.index = 0;
        self.chunk.clear();
        self.sender.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestApplySnapshotChunk {
        static instance: RequestApplySnapshotChunk = RequestApplySnapshotChunk {
            index: 0,
            chunk: ::std::vec::Vec::new(),
            sender: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestApplySnapshotChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestApplySnapshotChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestApplySnapshotChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestApplySnapshotChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.Response)
pub struct Response {
    // message oneof groups
    pub value: ::std::option::Option<response::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .tendermint.abci.ResponseException exception = 1;

    pub fn exception(&self) -> &ResponseException {
        match self.value {
            ::std::option::Option::Some(response::Value::Exception(ref v)) => v,
            _ => <ResponseException as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_exception(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_exception(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::Exception(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: ResponseException) {
        self.value = ::std::option::Option::Some(response::Value::Exception(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exception(&mut self) -> &mut ResponseException {
        if let ::std::option::Option::Some(response::Value::Exception(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::Exception(ResponseException::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::Exception(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exception(&mut self) -> ResponseException {
        if self.has_exception() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::Exception(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseException::new()
        }
    }

    // .tendermint.abci.ResponseEcho echo = 2;

    pub fn echo(&self) -> &ResponseEcho {
        match self.value {
            ::std::option::Option::Some(response::Value::Echo(ref v)) => v,
            _ => <ResponseEcho as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_echo(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_echo(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::Echo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_echo(&mut self, v: ResponseEcho) {
        self.value = ::std::option::Option::Some(response::Value::Echo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_echo(&mut self) -> &mut ResponseEcho {
        if let ::std::option::Option::Some(response::Value::Echo(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::Echo(ResponseEcho::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::Echo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_echo(&mut self) -> ResponseEcho {
        if self.has_echo() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::Echo(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseEcho::new()
        }
    }

    // .tendermint.abci.ResponseFlush flush = 3;

    pub fn flush(&self) -> &ResponseFlush {
        match self.value {
            ::std::option::Option::Some(response::Value::Flush(ref v)) => v,
            _ => <ResponseFlush as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_flush(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_flush(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::Flush(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_flush(&mut self, v: ResponseFlush) {
        self.value = ::std::option::Option::Some(response::Value::Flush(v))
    }

    // Mutable pointer to the field.
    pub fn mut_flush(&mut self) -> &mut ResponseFlush {
        if let ::std::option::Option::Some(response::Value::Flush(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::Flush(ResponseFlush::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::Flush(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_flush(&mut self) -> ResponseFlush {
        if self.has_flush() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::Flush(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseFlush::new()
        }
    }

    // .tendermint.abci.ResponseInfo info = 4;

    pub fn info(&self) -> &ResponseInfo {
        match self.value {
            ::std::option::Option::Some(response::Value::Info(ref v)) => v,
            _ => <ResponseInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_info(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::Info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ResponseInfo) {
        self.value = ::std::option::Option::Some(response::Value::Info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_info(&mut self) -> &mut ResponseInfo {
        if let ::std::option::Option::Some(response::Value::Info(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::Info(ResponseInfo::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::Info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_info(&mut self) -> ResponseInfo {
        if self.has_info() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::Info(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseInfo::new()
        }
    }

    // .tendermint.abci.ResponseSetOption set_option = 5;

    pub fn set_option(&self) -> &ResponseSetOption {
        match self.value {
            ::std::option::Option::Some(response::Value::SetOption(ref v)) => v,
            _ => <ResponseSetOption as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_option(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_set_option(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::SetOption(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_option(&mut self, v: ResponseSetOption) {
        self.value = ::std::option::Option::Some(response::Value::SetOption(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_option(&mut self) -> &mut ResponseSetOption {
        if let ::std::option::Option::Some(response::Value::SetOption(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::SetOption(ResponseSetOption::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::SetOption(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_option(&mut self) -> ResponseSetOption {
        if self.has_set_option() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::SetOption(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseSetOption::new()
        }
    }

    // .tendermint.abci.ResponseInitChain init_chain = 6;

    pub fn init_chain(&self) -> &ResponseInitChain {
        match self.value {
            ::std::option::Option::Some(response::Value::InitChain(ref v)) => v,
            _ => <ResponseInitChain as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_init_chain(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_init_chain(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::InitChain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_init_chain(&mut self, v: ResponseInitChain) {
        self.value = ::std::option::Option::Some(response::Value::InitChain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_init_chain(&mut self) -> &mut ResponseInitChain {
        if let ::std::option::Option::Some(response::Value::InitChain(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::InitChain(ResponseInitChain::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::InitChain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_init_chain(&mut self) -> ResponseInitChain {
        if self.has_init_chain() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::InitChain(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseInitChain::new()
        }
    }

    // .tendermint.abci.ResponseQuery query = 7;

    pub fn query(&self) -> &ResponseQuery {
        match self.value {
            ::std::option::Option::Some(response::Value::Query(ref v)) => v,
            _ => <ResponseQuery as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_query(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::Query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ResponseQuery) {
        self.value = ::std::option::Option::Some(response::Value::Query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut ResponseQuery {
        if let ::std::option::Option::Some(response::Value::Query(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::Query(ResponseQuery::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::Query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> ResponseQuery {
        if self.has_query() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::Query(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseQuery::new()
        }
    }

    // .tendermint.abci.ResponseBeginBlock begin_block = 8;

    pub fn begin_block(&self) -> &ResponseBeginBlock {
        match self.value {
            ::std::option::Option::Some(response::Value::BeginBlock(ref v)) => v,
            _ => <ResponseBeginBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_begin_block(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_begin_block(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::BeginBlock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_begin_block(&mut self, v: ResponseBeginBlock) {
        self.value = ::std::option::Option::Some(response::Value::BeginBlock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_begin_block(&mut self) -> &mut ResponseBeginBlock {
        if let ::std::option::Option::Some(response::Value::BeginBlock(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::BeginBlock(ResponseBeginBlock::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::BeginBlock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_begin_block(&mut self) -> ResponseBeginBlock {
        if self.has_begin_block() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::BeginBlock(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseBeginBlock::new()
        }
    }

    // .tendermint.abci.ResponseCheckTx check_tx = 9;

    pub fn check_tx(&self) -> &ResponseCheckTx {
        match self.value {
            ::std::option::Option::Some(response::Value::CheckTx(ref v)) => v,
            _ => <ResponseCheckTx as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_check_tx(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_check_tx(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::CheckTx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_check_tx(&mut self, v: ResponseCheckTx) {
        self.value = ::std::option::Option::Some(response::Value::CheckTx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_check_tx(&mut self) -> &mut ResponseCheckTx {
        if let ::std::option::Option::Some(response::Value::CheckTx(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::CheckTx(ResponseCheckTx::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::CheckTx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_check_tx(&mut self) -> ResponseCheckTx {
        if self.has_check_tx() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::CheckTx(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseCheckTx::new()
        }
    }

    // .tendermint.abci.ResponseDeliverTx deliver_tx = 10;

    pub fn deliver_tx(&self) -> &ResponseDeliverTx {
        match self.value {
            ::std::option::Option::Some(response::Value::DeliverTx(ref v)) => v,
            _ => <ResponseDeliverTx as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_deliver_tx(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_deliver_tx(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::DeliverTx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deliver_tx(&mut self, v: ResponseDeliverTx) {
        self.value = ::std::option::Option::Some(response::Value::DeliverTx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_deliver_tx(&mut self) -> &mut ResponseDeliverTx {
        if let ::std::option::Option::Some(response::Value::DeliverTx(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::DeliverTx(ResponseDeliverTx::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::DeliverTx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deliver_tx(&mut self) -> ResponseDeliverTx {
        if self.has_deliver_tx() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::DeliverTx(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseDeliverTx::new()
        }
    }

    // .tendermint.abci.ResponseEndBlock end_block = 11;

    pub fn end_block(&self) -> &ResponseEndBlock {
        match self.value {
            ::std::option::Option::Some(response::Value::EndBlock(ref v)) => v,
            _ => <ResponseEndBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_end_block(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_end_block(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::EndBlock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_block(&mut self, v: ResponseEndBlock) {
        self.value = ::std::option::Option::Some(response::Value::EndBlock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_block(&mut self) -> &mut ResponseEndBlock {
        if let ::std::option::Option::Some(response::Value::EndBlock(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::EndBlock(ResponseEndBlock::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::EndBlock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_block(&mut self) -> ResponseEndBlock {
        if self.has_end_block() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::EndBlock(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseEndBlock::new()
        }
    }

    // .tendermint.abci.ResponseCommit commit = 12;

    pub fn commit(&self) -> &ResponseCommit {
        match self.value {
            ::std::option::Option::Some(response::Value::Commit(ref v)) => v,
            _ => <ResponseCommit as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_commit(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_commit(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::Commit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_commit(&mut self, v: ResponseCommit) {
        self.value = ::std::option::Option::Some(response::Value::Commit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_commit(&mut self) -> &mut ResponseCommit {
        if let ::std::option::Option::Some(response::Value::Commit(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::Commit(ResponseCommit::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::Commit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_commit(&mut self) -> ResponseCommit {
        if self.has_commit() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::Commit(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseCommit::new()
        }
    }

    // .tendermint.abci.ResponseListSnapshots list_snapshots = 13;

    pub fn list_snapshots(&self) -> &ResponseListSnapshots {
        match self.value {
            ::std::option::Option::Some(response::Value::ListSnapshots(ref v)) => v,
            _ => <ResponseListSnapshots as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_snapshots(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_list_snapshots(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::ListSnapshots(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_snapshots(&mut self, v: ResponseListSnapshots) {
        self.value = ::std::option::Option::Some(response::Value::ListSnapshots(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_snapshots(&mut self) -> &mut ResponseListSnapshots {
        if let ::std::option::Option::Some(response::Value::ListSnapshots(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::ListSnapshots(ResponseListSnapshots::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::ListSnapshots(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_snapshots(&mut self) -> ResponseListSnapshots {
        if self.has_list_snapshots() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::ListSnapshots(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseListSnapshots::new()
        }
    }

    // .tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14;

    pub fn offer_snapshot(&self) -> &ResponseOfferSnapshot {
        match self.value {
            ::std::option::Option::Some(response::Value::OfferSnapshot(ref v)) => v,
            _ => <ResponseOfferSnapshot as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_offer_snapshot(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_offer_snapshot(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::OfferSnapshot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offer_snapshot(&mut self, v: ResponseOfferSnapshot) {
        self.value = ::std::option::Option::Some(response::Value::OfferSnapshot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_offer_snapshot(&mut self) -> &mut ResponseOfferSnapshot {
        if let ::std::option::Option::Some(response::Value::OfferSnapshot(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::OfferSnapshot(ResponseOfferSnapshot::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::OfferSnapshot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_offer_snapshot(&mut self) -> ResponseOfferSnapshot {
        if self.has_offer_snapshot() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::OfferSnapshot(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseOfferSnapshot::new()
        }
    }

    // .tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15;

    pub fn load_snapshot_chunk(&self) -> &ResponseLoadSnapshotChunk {
        match self.value {
            ::std::option::Option::Some(response::Value::LoadSnapshotChunk(ref v)) => v,
            _ => <ResponseLoadSnapshotChunk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_load_snapshot_chunk(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_load_snapshot_chunk(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::LoadSnapshotChunk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_load_snapshot_chunk(&mut self, v: ResponseLoadSnapshotChunk) {
        self.value = ::std::option::Option::Some(response::Value::LoadSnapshotChunk(v))
    }

    // Mutable pointer to the field.
    pub fn mut_load_snapshot_chunk(&mut self) -> &mut ResponseLoadSnapshotChunk {
        if let ::std::option::Option::Some(response::Value::LoadSnapshotChunk(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::LoadSnapshotChunk(ResponseLoadSnapshotChunk::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::LoadSnapshotChunk(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_load_snapshot_chunk(&mut self) -> ResponseLoadSnapshotChunk {
        if self.has_load_snapshot_chunk() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::LoadSnapshotChunk(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseLoadSnapshotChunk::new()
        }
    }

    // .tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16;

    pub fn apply_snapshot_chunk(&self) -> &ResponseApplySnapshotChunk {
        match self.value {
            ::std::option::Option::Some(response::Value::ApplySnapshotChunk(ref v)) => v,
            _ => <ResponseApplySnapshotChunk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_apply_snapshot_chunk(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_apply_snapshot_chunk(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(response::Value::ApplySnapshotChunk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_snapshot_chunk(&mut self, v: ResponseApplySnapshotChunk) {
        self.value = ::std::option::Option::Some(response::Value::ApplySnapshotChunk(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_snapshot_chunk(&mut self) -> &mut ResponseApplySnapshotChunk {
        if let ::std::option::Option::Some(response::Value::ApplySnapshotChunk(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(response::Value::ApplySnapshotChunk(ResponseApplySnapshotChunk::new()));
        }
        match self.value {
            ::std::option::Option::Some(response::Value::ApplySnapshotChunk(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_snapshot_chunk(&mut self) -> ResponseApplySnapshotChunk {
        if self.has_apply_snapshot_chunk() {
            match self.value.take() {
                ::std::option::Option::Some(response::Value::ApplySnapshotChunk(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseApplySnapshotChunk::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseException>(
            "exception",
            Response::has_exception,
            Response::exception,
            Response::mut_exception,
            Response::set_exception,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseEcho>(
            "echo",
            Response::has_echo,
            Response::echo,
            Response::mut_echo,
            Response::set_echo,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseFlush>(
            "flush",
            Response::has_flush,
            Response::flush,
            Response::mut_flush,
            Response::set_flush,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseInfo>(
            "info",
            Response::has_info,
            Response::info,
            Response::mut_info,
            Response::set_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseSetOption>(
            "set_option",
            Response::has_set_option,
            Response::set_option,
            Response::mut_set_option,
            Response::set_set_option,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseInitChain>(
            "init_chain",
            Response::has_init_chain,
            Response::init_chain,
            Response::mut_init_chain,
            Response::set_init_chain,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseQuery>(
            "query",
            Response::has_query,
            Response::query,
            Response::mut_query,
            Response::set_query,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseBeginBlock>(
            "begin_block",
            Response::has_begin_block,
            Response::begin_block,
            Response::mut_begin_block,
            Response::set_begin_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseCheckTx>(
            "check_tx",
            Response::has_check_tx,
            Response::check_tx,
            Response::mut_check_tx,
            Response::set_check_tx,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseDeliverTx>(
            "deliver_tx",
            Response::has_deliver_tx,
            Response::deliver_tx,
            Response::mut_deliver_tx,
            Response::set_deliver_tx,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseEndBlock>(
            "end_block",
            Response::has_end_block,
            Response::end_block,
            Response::mut_end_block,
            Response::set_end_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseCommit>(
            "commit",
            Response::has_commit,
            Response::commit,
            Response::mut_commit,
            Response::set_commit,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseListSnapshots>(
            "list_snapshots",
            Response::has_list_snapshots,
            Response::list_snapshots,
            Response::mut_list_snapshots,
            Response::set_list_snapshots,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseOfferSnapshot>(
            "offer_snapshot",
            Response::has_offer_snapshot,
            Response::offer_snapshot,
            Response::mut_offer_snapshot,
            Response::set_offer_snapshot,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseLoadSnapshotChunk>(
            "load_snapshot_chunk",
            Response::has_load_snapshot_chunk,
            Response::load_snapshot_chunk,
            Response::mut_load_snapshot_chunk,
            Response::set_load_snapshot_chunk,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseApplySnapshotChunk>(
            "apply_snapshot_chunk",
            Response::has_apply_snapshot_chunk,
            Response::apply_snapshot_chunk,
            Response::mut_apply_snapshot_chunk,
            Response::set_apply_snapshot_chunk,
        ));
        oneofs.push(response::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Response>(
            "Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Response {
    const NAME: &'static str = "Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(response::Value::Exception(is.read_message()?));
                },
                18 => {
                    self.value = ::std::option::Option::Some(response::Value::Echo(is.read_message()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(response::Value::Flush(is.read_message()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(response::Value::Info(is.read_message()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(response::Value::SetOption(is.read_message()?));
                },
                50 => {
                    self.value = ::std::option::Option::Some(response::Value::InitChain(is.read_message()?));
                },
                58 => {
                    self.value = ::std::option::Option::Some(response::Value::Query(is.read_message()?));
                },
                66 => {
                    self.value = ::std::option::Option::Some(response::Value::BeginBlock(is.read_message()?));
                },
                74 => {
                    self.value = ::std::option::Option::Some(response::Value::CheckTx(is.read_message()?));
                },
                82 => {
                    self.value = ::std::option::Option::Some(response::Value::DeliverTx(is.read_message()?));
                },
                90 => {
                    self.value = ::std::option::Option::Some(response::Value::EndBlock(is.read_message()?));
                },
                98 => {
                    self.value = ::std::option::Option::Some(response::Value::Commit(is.read_message()?));
                },
                106 => {
                    self.value = ::std::option::Option::Some(response::Value::ListSnapshots(is.read_message()?));
                },
                114 => {
                    self.value = ::std::option::Option::Some(response::Value::OfferSnapshot(is.read_message()?));
                },
                122 => {
                    self.value = ::std::option::Option::Some(response::Value::LoadSnapshotChunk(is.read_message()?));
                },
                130 => {
                    self.value = ::std::option::Option::Some(response::Value::ApplySnapshotChunk(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &response::Value::Exception(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::Echo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::Flush(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::Info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::SetOption(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::InitChain(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::Query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::BeginBlock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::CheckTx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::DeliverTx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::EndBlock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::Commit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::ListSnapshots(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::OfferSnapshot(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::LoadSnapshotChunk(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Value::ApplySnapshotChunk(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &response::Value::Exception(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &response::Value::Echo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &response::Value::Flush(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &response::Value::Info(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &response::Value::SetOption(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &response::Value::InitChain(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &response::Value::Query(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &response::Value::BeginBlock(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &response::Value::CheckTx(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &response::Value::DeliverTx(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &response::Value::EndBlock(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &response::Value::Commit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &response::Value::ListSnapshots(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &response::Value::OfferSnapshot(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &response::Value::LoadSnapshotChunk(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &response::Value::ApplySnapshotChunk(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Response {
        Response::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Response {
        static instance: Response = Response {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Response`
pub mod response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:tendermint.abci.Response.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.exception)
        Exception(super::ResponseException),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.echo)
        Echo(super::ResponseEcho),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.flush)
        Flush(super::ResponseFlush),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.info)
        Info(super::ResponseInfo),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.set_option)
        SetOption(super::ResponseSetOption),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.init_chain)
        InitChain(super::ResponseInitChain),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.query)
        Query(super::ResponseQuery),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.begin_block)
        BeginBlock(super::ResponseBeginBlock),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.check_tx)
        CheckTx(super::ResponseCheckTx),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.deliver_tx)
        DeliverTx(super::ResponseDeliverTx),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.end_block)
        EndBlock(super::ResponseEndBlock),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.commit)
        Commit(super::ResponseCommit),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.list_snapshots)
        ListSnapshots(super::ResponseListSnapshots),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.offer_snapshot)
        OfferSnapshot(super::ResponseOfferSnapshot),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.load_snapshot_chunk)
        LoadSnapshotChunk(super::ResponseLoadSnapshotChunk),
        // @@protoc_insertion_point(oneof_field:tendermint.abci.Response.apply_snapshot_chunk)
        ApplySnapshotChunk(super::ResponseApplySnapshotChunk),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Response as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

///  nondeterministic
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseException)
pub struct ResponseException {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseException.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseException.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseException {
    fn default() -> &'a ResponseException {
        <ResponseException as ::protobuf::Message>::default_instance()
    }
}

impl ResponseException {
    pub fn new() -> ResponseException {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &ResponseException| { &m.error },
            |m: &mut ResponseException| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseException>(
            "ResponseException",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseException {
    const NAME: &'static str = "ResponseException";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseException {
        ResponseException::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseException {
        static instance: ResponseException = ResponseException {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseException {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseException").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseException {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseEcho)
pub struct ResponseEcho {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseEcho.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseEcho.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseEcho {
    fn default() -> &'a ResponseEcho {
        <ResponseEcho as ::protobuf::Message>::default_instance()
    }
}

impl ResponseEcho {
    pub fn new() -> ResponseEcho {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &ResponseEcho| { &m.message },
            |m: &mut ResponseEcho| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseEcho>(
            "ResponseEcho",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseEcho {
    const NAME: &'static str = "ResponseEcho";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseEcho {
        ResponseEcho::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseEcho {
        static instance: ResponseEcho = ResponseEcho {
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseEcho {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseEcho").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseEcho {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseEcho {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseFlush)
pub struct ResponseFlush {
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseFlush.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseFlush {
    fn default() -> &'a ResponseFlush {
        <ResponseFlush as ::protobuf::Message>::default_instance()
    }
}

impl ResponseFlush {
    pub fn new() -> ResponseFlush {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseFlush>(
            "ResponseFlush",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseFlush {
    const NAME: &'static str = "ResponseFlush";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseFlush {
        ResponseFlush::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseFlush {
        static instance: ResponseFlush = ResponseFlush {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseFlush {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseFlush").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseFlush {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseFlush {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseInfo)
pub struct ResponseInfo {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInfo.data)
    pub data: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInfo.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInfo.app_version)
    pub app_version: u64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInfo.last_block_height)
    pub last_block_height: i64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInfo.last_block_app_hash)
    pub last_block_app_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseInfo {
    fn default() -> &'a ResponseInfo {
        <ResponseInfo as ::protobuf::Message>::default_instance()
    }
}

impl ResponseInfo {
    pub fn new() -> ResponseInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ResponseInfo| { &m.data },
            |m: &mut ResponseInfo| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &ResponseInfo| { &m.version },
            |m: &mut ResponseInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_version",
            |m: &ResponseInfo| { &m.app_version },
            |m: &mut ResponseInfo| { &mut m.app_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_block_height",
            |m: &ResponseInfo| { &m.last_block_height },
            |m: &mut ResponseInfo| { &mut m.last_block_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_block_app_hash",
            |m: &ResponseInfo| { &m.last_block_app_hash },
            |m: &mut ResponseInfo| { &mut m.last_block_app_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseInfo>(
            "ResponseInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseInfo {
    const NAME: &'static str = "ResponseInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_string()?;
                },
                18 => {
                    self.version = is.read_string()?;
                },
                24 => {
                    self.app_version = is.read_uint64()?;
                },
                32 => {
                    self.last_block_height = is.read_int64()?;
                },
                42 => {
                    self.last_block_app_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.data);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if self.app_version != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.app_version);
        }
        if self.last_block_height != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.last_block_height);
        }
        if !self.last_block_app_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.last_block_app_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_string(1, &self.data)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if self.app_version != 0 {
            os.write_uint64(3, self.app_version)?;
        }
        if self.last_block_height != 0 {
            os.write_int64(4, self.last_block_height)?;
        }
        if !self.last_block_app_hash.is_empty() {
            os.write_bytes(5, &self.last_block_app_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseInfo {
        ResponseInfo::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.version.clear();
        self.app_version = 0;
        self.last_block_height = 0;
        self.last_block_app_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseInfo {
        static instance: ResponseInfo = ResponseInfo {
            data: ::std::string::String::new(),
            version: ::std::string::String::new(),
            app_version: 0,
            last_block_height: 0,
            last_block_app_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  nondeterministic
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseSetOption)
pub struct ResponseSetOption {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseSetOption.code)
    pub code: u32,
    ///  bytes data = 2;
    // @@protoc_insertion_point(field:tendermint.abci.ResponseSetOption.log)
    pub log: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseSetOption.info)
    pub info: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseSetOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseSetOption {
    fn default() -> &'a ResponseSetOption {
        <ResponseSetOption as ::protobuf::Message>::default_instance()
    }
}

impl ResponseSetOption {
    pub fn new() -> ResponseSetOption {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ResponseSetOption| { &m.code },
            |m: &mut ResponseSetOption| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "log",
            |m: &ResponseSetOption| { &m.log },
            |m: &mut ResponseSetOption| { &mut m.log },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "info",
            |m: &ResponseSetOption| { &m.info },
            |m: &mut ResponseSetOption| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseSetOption>(
            "ResponseSetOption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseSetOption {
    const NAME: &'static str = "ResponseSetOption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_uint32()?;
                },
                26 => {
                    self.log = is.read_string()?;
                },
                34 => {
                    self.info = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.code);
        }
        if !self.log.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.log);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_uint32(1, self.code)?;
        }
        if !self.log.is_empty() {
            os.write_string(3, &self.log)?;
        }
        if !self.info.is_empty() {
            os.write_string(4, &self.info)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseSetOption {
        ResponseSetOption::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.log.clear();
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseSetOption {
        static instance: ResponseSetOption = ResponseSetOption {
            code: 0,
            log: ::std::string::String::new(),
            info: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseSetOption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseSetOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseSetOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseSetOption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseInitChain)
pub struct ResponseInitChain {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInitChain.consensus_params)
    pub consensus_params: ::protobuf::MessageField<ConsensusParams>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInitChain.validators)
    pub validators: ::std::vec::Vec<ValidatorUpdate>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseInitChain.app_hash)
    pub app_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseInitChain.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseInitChain {
    fn default() -> &'a ResponseInitChain {
        <ResponseInitChain as ::protobuf::Message>::default_instance()
    }
}

impl ResponseInitChain {
    pub fn new() -> ResponseInitChain {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConsensusParams>(
            "consensus_params",
            |m: &ResponseInitChain| { &m.consensus_params },
            |m: &mut ResponseInitChain| { &mut m.consensus_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validators",
            |m: &ResponseInitChain| { &m.validators },
            |m: &mut ResponseInitChain| { &mut m.validators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_hash",
            |m: &ResponseInitChain| { &m.app_hash },
            |m: &mut ResponseInitChain| { &mut m.app_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseInitChain>(
            "ResponseInitChain",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseInitChain {
    const NAME: &'static str = "ResponseInitChain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_params)?;
                },
                18 => {
                    self.validators.push(is.read_message()?);
                },
                26 => {
                    self.app_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.consensus_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.app_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.app_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.consensus_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.validators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.app_hash.is_empty() {
            os.write_bytes(3, &self.app_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseInitChain {
        ResponseInitChain::new()
    }

    fn clear(&mut self) {
        self.consensus_params.clear();
        self.validators.clear();
        self.app_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseInitChain {
        static instance: ResponseInitChain = ResponseInitChain {
            consensus_params: ::protobuf::MessageField::none(),
            validators: ::std::vec::Vec::new(),
            app_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseInitChain {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseInitChain").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseInitChain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseInitChain {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseQuery)
pub struct ResponseQuery {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.code)
    pub code: u32,
    ///  bytes data = 2; // use "value" instead.
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.log)
    pub log: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.info)
    pub info: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.index)
    pub index: i64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.value)
    pub value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.proof_ops)
    pub proof_ops: ::protobuf::MessageField<super::proof::ProofOps>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseQuery.codespace)
    pub codespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQuery {
    fn default() -> &'a ResponseQuery {
        <ResponseQuery as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuery {
    pub fn new() -> ResponseQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ResponseQuery| { &m.code },
            |m: &mut ResponseQuery| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "log",
            |m: &ResponseQuery| { &m.log },
            |m: &mut ResponseQuery| { &mut m.log },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "info",
            |m: &ResponseQuery| { &m.info },
            |m: &mut ResponseQuery| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &ResponseQuery| { &m.index },
            |m: &mut ResponseQuery| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ResponseQuery| { &m.key },
            |m: &mut ResponseQuery| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &ResponseQuery| { &m.value },
            |m: &mut ResponseQuery| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::proof::ProofOps>(
            "proof_ops",
            |m: &ResponseQuery| { &m.proof_ops },
            |m: &mut ResponseQuery| { &mut m.proof_ops },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &ResponseQuery| { &m.height },
            |m: &mut ResponseQuery| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "codespace",
            |m: &ResponseQuery| { &m.codespace },
            |m: &mut ResponseQuery| { &mut m.codespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQuery>(
            "ResponseQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQuery {
    const NAME: &'static str = "ResponseQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_uint32()?;
                },
                26 => {
                    self.log = is.read_string()?;
                },
                34 => {
                    self.info = is.read_string()?;
                },
                40 => {
                    self.index = is.read_int64()?;
                },
                50 => {
                    self.key = is.read_bytes()?;
                },
                58 => {
                    self.value = is.read_bytes()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof_ops)?;
                },
                72 => {
                    self.height = is.read_int64()?;
                },
                82 => {
                    self.codespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.code);
        }
        if !self.log.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.log);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.info);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.index);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.value);
        }
        if let Some(v) = self.proof_ops.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.height);
        }
        if !self.codespace.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.codespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_uint32(1, self.code)?;
        }
        if !self.log.is_empty() {
            os.write_string(3, &self.log)?;
        }
        if !self.info.is_empty() {
            os.write_string(4, &self.info)?;
        }
        if self.index != 0 {
            os.write_int64(5, self.index)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(6, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(7, &self.value)?;
        }
        if let Some(v) = self.proof_ops.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.height != 0 {
            os.write_int64(9, self.height)?;
        }
        if !self.codespace.is_empty() {
            os.write_string(10, &self.codespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQuery {
        ResponseQuery::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.log.clear();
        self.info.clear();
        self.index = 0;
        self.key.clear();
        self.value.clear();
        self.proof_ops.clear();
        self.height = 0;
        self.codespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQuery {
        static instance: ResponseQuery = ResponseQuery {
            code: 0,
            log: ::std::string::String::new(),
            info: ::std::string::String::new(),
            index: 0,
            key: ::std::vec::Vec::new(),
            value: ::std::vec::Vec::new(),
            proof_ops: ::protobuf::MessageField::none(),
            height: 0,
            codespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseBeginBlock)
pub struct ResponseBeginBlock {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseBeginBlock.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseBeginBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseBeginBlock {
    fn default() -> &'a ResponseBeginBlock {
        <ResponseBeginBlock as ::protobuf::Message>::default_instance()
    }
}

impl ResponseBeginBlock {
    pub fn new() -> ResponseBeginBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &ResponseBeginBlock| { &m.events },
            |m: &mut ResponseBeginBlock| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseBeginBlock>(
            "ResponseBeginBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseBeginBlock {
    const NAME: &'static str = "ResponseBeginBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseBeginBlock {
        ResponseBeginBlock::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseBeginBlock {
        static instance: ResponseBeginBlock = ResponseBeginBlock {
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseBeginBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseBeginBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseBeginBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseBeginBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseCheckTx)
pub struct ResponseCheckTx {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.code)
    pub code: u32,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.log)
    pub log: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.info)
    pub info: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.gas_wanted)
    pub gas_wanted: i64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.gas_used)
    pub gas_used: i64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.events)
    pub events: ::std::vec::Vec<Event>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCheckTx.codespace)
    pub codespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseCheckTx.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseCheckTx {
    fn default() -> &'a ResponseCheckTx {
        <ResponseCheckTx as ::protobuf::Message>::default_instance()
    }
}

impl ResponseCheckTx {
    pub fn new() -> ResponseCheckTx {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ResponseCheckTx| { &m.code },
            |m: &mut ResponseCheckTx| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ResponseCheckTx| { &m.data },
            |m: &mut ResponseCheckTx| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "log",
            |m: &ResponseCheckTx| { &m.log },
            |m: &mut ResponseCheckTx| { &mut m.log },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "info",
            |m: &ResponseCheckTx| { &m.info },
            |m: &mut ResponseCheckTx| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_wanted",
            |m: &ResponseCheckTx| { &m.gas_wanted },
            |m: &mut ResponseCheckTx| { &mut m.gas_wanted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &ResponseCheckTx| { &m.gas_used },
            |m: &mut ResponseCheckTx| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &ResponseCheckTx| { &m.events },
            |m: &mut ResponseCheckTx| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "codespace",
            |m: &ResponseCheckTx| { &m.codespace },
            |m: &mut ResponseCheckTx| { &mut m.codespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseCheckTx>(
            "ResponseCheckTx",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseCheckTx {
    const NAME: &'static str = "ResponseCheckTx";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_uint32()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                26 => {
                    self.log = is.read_string()?;
                },
                34 => {
                    self.info = is.read_string()?;
                },
                40 => {
                    self.gas_wanted = is.read_int64()?;
                },
                48 => {
                    self.gas_used = is.read_int64()?;
                },
                58 => {
                    self.events.push(is.read_message()?);
                },
                66 => {
                    self.codespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.code);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.log.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.log);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.info);
        }
        if self.gas_wanted != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.gas_wanted);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.gas_used);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.codespace.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.codespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_uint32(1, self.code)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.log.is_empty() {
            os.write_string(3, &self.log)?;
        }
        if !self.info.is_empty() {
            os.write_string(4, &self.info)?;
        }
        if self.gas_wanted != 0 {
            os.write_int64(5, self.gas_wanted)?;
        }
        if self.gas_used != 0 {
            os.write_int64(6, self.gas_used)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if !self.codespace.is_empty() {
            os.write_string(8, &self.codespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseCheckTx {
        ResponseCheckTx::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.data.clear();
        self.log.clear();
        self.info.clear();
        self.gas_wanted = 0;
        self.gas_used = 0;
        self.events.clear();
        self.codespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseCheckTx {
        static instance: ResponseCheckTx = ResponseCheckTx {
            code: 0,
            data: ::std::vec::Vec::new(),
            log: ::std::string::String::new(),
            info: ::std::string::String::new(),
            gas_wanted: 0,
            gas_used: 0,
            events: ::std::vec::Vec::new(),
            codespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseCheckTx {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseCheckTx").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseCheckTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseCheckTx {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseDeliverTx)
pub struct ResponseDeliverTx {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.code)
    pub code: u32,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.log)
    pub log: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.info)
    pub info: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.gas_wanted)
    pub gas_wanted: i64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.gas_used)
    pub gas_used: i64,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.events)
    pub events: ::std::vec::Vec<Event>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseDeliverTx.codespace)
    pub codespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseDeliverTx.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseDeliverTx {
    fn default() -> &'a ResponseDeliverTx {
        <ResponseDeliverTx as ::protobuf::Message>::default_instance()
    }
}

impl ResponseDeliverTx {
    pub fn new() -> ResponseDeliverTx {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ResponseDeliverTx| { &m.code },
            |m: &mut ResponseDeliverTx| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ResponseDeliverTx| { &m.data },
            |m: &mut ResponseDeliverTx| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "log",
            |m: &ResponseDeliverTx| { &m.log },
            |m: &mut ResponseDeliverTx| { &mut m.log },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "info",
            |m: &ResponseDeliverTx| { &m.info },
            |m: &mut ResponseDeliverTx| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_wanted",
            |m: &ResponseDeliverTx| { &m.gas_wanted },
            |m: &mut ResponseDeliverTx| { &mut m.gas_wanted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &ResponseDeliverTx| { &m.gas_used },
            |m: &mut ResponseDeliverTx| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &ResponseDeliverTx| { &m.events },
            |m: &mut ResponseDeliverTx| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "codespace",
            |m: &ResponseDeliverTx| { &m.codespace },
            |m: &mut ResponseDeliverTx| { &mut m.codespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseDeliverTx>(
            "ResponseDeliverTx",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseDeliverTx {
    const NAME: &'static str = "ResponseDeliverTx";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_uint32()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                26 => {
                    self.log = is.read_string()?;
                },
                34 => {
                    self.info = is.read_string()?;
                },
                40 => {
                    self.gas_wanted = is.read_int64()?;
                },
                48 => {
                    self.gas_used = is.read_int64()?;
                },
                58 => {
                    self.events.push(is.read_message()?);
                },
                66 => {
                    self.codespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.code);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.log.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.log);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.info);
        }
        if self.gas_wanted != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.gas_wanted);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.gas_used);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.codespace.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.codespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_uint32(1, self.code)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.log.is_empty() {
            os.write_string(3, &self.log)?;
        }
        if !self.info.is_empty() {
            os.write_string(4, &self.info)?;
        }
        if self.gas_wanted != 0 {
            os.write_int64(5, self.gas_wanted)?;
        }
        if self.gas_used != 0 {
            os.write_int64(6, self.gas_used)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if !self.codespace.is_empty() {
            os.write_string(8, &self.codespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseDeliverTx {
        ResponseDeliverTx::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.data.clear();
        self.log.clear();
        self.info.clear();
        self.gas_wanted = 0;
        self.gas_used = 0;
        self.events.clear();
        self.codespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseDeliverTx {
        static instance: ResponseDeliverTx = ResponseDeliverTx {
            code: 0,
            data: ::std::vec::Vec::new(),
            log: ::std::string::String::new(),
            info: ::std::string::String::new(),
            gas_wanted: 0,
            gas_used: 0,
            events: ::std::vec::Vec::new(),
            codespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseDeliverTx {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseDeliverTx").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseDeliverTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseDeliverTx {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseEndBlock)
pub struct ResponseEndBlock {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseEndBlock.validator_updates)
    pub validator_updates: ::std::vec::Vec<ValidatorUpdate>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseEndBlock.consensus_param_updates)
    pub consensus_param_updates: ::protobuf::MessageField<ConsensusParams>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseEndBlock.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseEndBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseEndBlock {
    fn default() -> &'a ResponseEndBlock {
        <ResponseEndBlock as ::protobuf::Message>::default_instance()
    }
}

impl ResponseEndBlock {
    pub fn new() -> ResponseEndBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validator_updates",
            |m: &ResponseEndBlock| { &m.validator_updates },
            |m: &mut ResponseEndBlock| { &mut m.validator_updates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConsensusParams>(
            "consensus_param_updates",
            |m: &ResponseEndBlock| { &m.consensus_param_updates },
            |m: &mut ResponseEndBlock| { &mut m.consensus_param_updates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &ResponseEndBlock| { &m.events },
            |m: &mut ResponseEndBlock| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseEndBlock>(
            "ResponseEndBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseEndBlock {
    const NAME: &'static str = "ResponseEndBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.validator_updates.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_param_updates)?;
                },
                26 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.validator_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.consensus_param_updates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.validator_updates {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.consensus_param_updates.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseEndBlock {
        ResponseEndBlock::new()
    }

    fn clear(&mut self) {
        self.validator_updates.clear();
        self.consensus_param_updates.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseEndBlock {
        static instance: ResponseEndBlock = ResponseEndBlock {
            validator_updates: ::std::vec::Vec::new(),
            consensus_param_updates: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseEndBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseEndBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseEndBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseEndBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseCommit)
pub struct ResponseCommit {
    // message fields
    ///  reserve 1
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCommit.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseCommit.retain_height)
    pub retain_height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseCommit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseCommit {
    fn default() -> &'a ResponseCommit {
        <ResponseCommit as ::protobuf::Message>::default_instance()
    }
}

impl ResponseCommit {
    pub fn new() -> ResponseCommit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ResponseCommit| { &m.data },
            |m: &mut ResponseCommit| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retain_height",
            |m: &ResponseCommit| { &m.retain_height },
            |m: &mut ResponseCommit| { &mut m.retain_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseCommit>(
            "ResponseCommit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseCommit {
    const NAME: &'static str = "ResponseCommit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.data = is.read_bytes()?;
                },
                24 => {
                    self.retain_height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.retain_height != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.retain_height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.retain_height != 0 {
            os.write_int64(3, self.retain_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseCommit {
        ResponseCommit::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.retain_height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseCommit {
        static instance: ResponseCommit = ResponseCommit {
            data: ::std::vec::Vec::new(),
            retain_height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseCommit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseCommit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseCommit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseListSnapshots)
pub struct ResponseListSnapshots {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseListSnapshots.snapshots)
    pub snapshots: ::std::vec::Vec<Snapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseListSnapshots.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseListSnapshots {
    fn default() -> &'a ResponseListSnapshots {
        <ResponseListSnapshots as ::protobuf::Message>::default_instance()
    }
}

impl ResponseListSnapshots {
    pub fn new() -> ResponseListSnapshots {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshots",
            |m: &ResponseListSnapshots| { &m.snapshots },
            |m: &mut ResponseListSnapshots| { &mut m.snapshots },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseListSnapshots>(
            "ResponseListSnapshots",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseListSnapshots {
    const NAME: &'static str = "ResponseListSnapshots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshots.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.snapshots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.snapshots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseListSnapshots {
        ResponseListSnapshots::new()
    }

    fn clear(&mut self) {
        self.snapshots.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseListSnapshots {
        static instance: ResponseListSnapshots = ResponseListSnapshots {
            snapshots: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseListSnapshots {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseListSnapshots").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseListSnapshots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseListSnapshots {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseOfferSnapshot)
pub struct ResponseOfferSnapshot {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseOfferSnapshot.result)
    pub result: ::protobuf::EnumOrUnknown<response_offer_snapshot::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseOfferSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseOfferSnapshot {
    fn default() -> &'a ResponseOfferSnapshot {
        <ResponseOfferSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl ResponseOfferSnapshot {
    pub fn new() -> ResponseOfferSnapshot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &ResponseOfferSnapshot| { &m.result },
            |m: &mut ResponseOfferSnapshot| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseOfferSnapshot>(
            "ResponseOfferSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseOfferSnapshot {
    const NAME: &'static str = "ResponseOfferSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(response_offer_snapshot::Result::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(response_offer_snapshot::Result::UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseOfferSnapshot {
        ResponseOfferSnapshot::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(response_offer_snapshot::Result::UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseOfferSnapshot {
        static instance: ResponseOfferSnapshot = ResponseOfferSnapshot {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseOfferSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseOfferSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseOfferSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseOfferSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseOfferSnapshot`
pub mod response_offer_snapshot {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:tendermint.abci.ResponseOfferSnapshot.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseOfferSnapshot.Result.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseOfferSnapshot.Result.ACCEPT)
        ACCEPT = 1,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseOfferSnapshot.Result.ABORT)
        ABORT = 2,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseOfferSnapshot.Result.REJECT)
        REJECT = 3,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseOfferSnapshot.Result.REJECT_FORMAT)
        REJECT_FORMAT = 4,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseOfferSnapshot.Result.REJECT_SENDER)
        REJECT_SENDER = 5,
    }

    impl ::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::UNKNOWN),
                1 => ::std::option::Option::Some(Result::ACCEPT),
                2 => ::std::option::Option::Some(Result::ABORT),
                3 => ::std::option::Option::Some(Result::REJECT),
                4 => ::std::option::Option::Some(Result::REJECT_FORMAT),
                5 => ::std::option::Option::Some(Result::REJECT_SENDER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::UNKNOWN,
            Result::ACCEPT,
            Result::ABORT,
            Result::REJECT,
            Result::REJECT_FORMAT,
            Result::REJECT_SENDER,
        ];
    }

    impl ::protobuf::EnumFull for Result {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseOfferSnapshot.Result").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::UNKNOWN
        }
    }

    impl Result {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Result>("ResponseOfferSnapshot.Result")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseLoadSnapshotChunk)
pub struct ResponseLoadSnapshotChunk {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
    pub chunk: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseLoadSnapshotChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseLoadSnapshotChunk {
    fn default() -> &'a ResponseLoadSnapshotChunk {
        <ResponseLoadSnapshotChunk as ::protobuf::Message>::default_instance()
    }
}

impl ResponseLoadSnapshotChunk {
    pub fn new() -> ResponseLoadSnapshotChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chunk",
            |m: &ResponseLoadSnapshotChunk| { &m.chunk },
            |m: &mut ResponseLoadSnapshotChunk| { &mut m.chunk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseLoadSnapshotChunk>(
            "ResponseLoadSnapshotChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseLoadSnapshotChunk {
    const NAME: &'static str = "ResponseLoadSnapshotChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chunk = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.chunk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.chunk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.chunk.is_empty() {
            os.write_bytes(1, &self.chunk)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseLoadSnapshotChunk {
        ResponseLoadSnapshotChunk::new()
    }

    fn clear(&mut self) {
        self.chunk.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseLoadSnapshotChunk {
        static instance: ResponseLoadSnapshotChunk = ResponseLoadSnapshotChunk {
            chunk: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseLoadSnapshotChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseLoadSnapshotChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseLoadSnapshotChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseLoadSnapshotChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ResponseApplySnapshotChunk)
pub struct ResponseApplySnapshotChunk {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ResponseApplySnapshotChunk.result)
    pub result: ::protobuf::EnumOrUnknown<response_apply_snapshot_chunk::Result>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
    pub refetch_chunks: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
    pub reject_senders: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ResponseApplySnapshotChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseApplySnapshotChunk {
    fn default() -> &'a ResponseApplySnapshotChunk {
        <ResponseApplySnapshotChunk as ::protobuf::Message>::default_instance()
    }
}

impl ResponseApplySnapshotChunk {
    pub fn new() -> ResponseApplySnapshotChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &ResponseApplySnapshotChunk| { &m.result },
            |m: &mut ResponseApplySnapshotChunk| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "refetch_chunks",
            |m: &ResponseApplySnapshotChunk| { &m.refetch_chunks },
            |m: &mut ResponseApplySnapshotChunk| { &mut m.refetch_chunks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reject_senders",
            |m: &ResponseApplySnapshotChunk| { &m.reject_senders },
            |m: &mut ResponseApplySnapshotChunk| { &mut m.reject_senders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseApplySnapshotChunk>(
            "ResponseApplySnapshotChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseApplySnapshotChunk {
    const NAME: &'static str = "ResponseApplySnapshotChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.refetch_chunks)?;
                },
                16 => {
                    self.refetch_chunks.push(is.read_uint32()?);
                },
                26 => {
                    self.reject_senders.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(response_apply_snapshot_chunk::Result::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        for value in &self.refetch_chunks {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.reject_senders {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(response_apply_snapshot_chunk::Result::UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        for v in &self.refetch_chunks {
            os.write_uint32(2, *v)?;
        };
        for v in &self.reject_senders {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseApplySnapshotChunk {
        ResponseApplySnapshotChunk::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(response_apply_snapshot_chunk::Result::UNKNOWN);
        self.refetch_chunks.clear();
        self.reject_senders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseApplySnapshotChunk {
        static instance: ResponseApplySnapshotChunk = ResponseApplySnapshotChunk {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            refetch_chunks: ::std::vec::Vec::new(),
            reject_senders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseApplySnapshotChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseApplySnapshotChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseApplySnapshotChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseApplySnapshotChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseApplySnapshotChunk`
pub mod response_apply_snapshot_chunk {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:tendermint.abci.ResponseApplySnapshotChunk.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseApplySnapshotChunk.Result.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseApplySnapshotChunk.Result.ACCEPT)
        ACCEPT = 1,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseApplySnapshotChunk.Result.ABORT)
        ABORT = 2,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseApplySnapshotChunk.Result.RETRY)
        RETRY = 3,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseApplySnapshotChunk.Result.RETRY_SNAPSHOT)
        RETRY_SNAPSHOT = 4,
        // @@protoc_insertion_point(enum_value:tendermint.abci.ResponseApplySnapshotChunk.Result.REJECT_SNAPSHOT)
        REJECT_SNAPSHOT = 5,
    }

    impl ::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::UNKNOWN),
                1 => ::std::option::Option::Some(Result::ACCEPT),
                2 => ::std::option::Option::Some(Result::ABORT),
                3 => ::std::option::Option::Some(Result::RETRY),
                4 => ::std::option::Option::Some(Result::RETRY_SNAPSHOT),
                5 => ::std::option::Option::Some(Result::REJECT_SNAPSHOT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::UNKNOWN,
            Result::ACCEPT,
            Result::ABORT,
            Result::RETRY,
            Result::RETRY_SNAPSHOT,
            Result::REJECT_SNAPSHOT,
        ];
    }

    impl ::protobuf::EnumFull for Result {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseApplySnapshotChunk.Result").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::UNKNOWN
        }
    }

    impl Result {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Result>("ResponseApplySnapshotChunk.Result")
        }
    }
}

///  ConsensusParams contains all consensus-relevant parameters
///  that can be adjusted by the abci app
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ConsensusParams)
pub struct ConsensusParams {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ConsensusParams.block)
    pub block: ::protobuf::MessageField<BlockParams>,
    // @@protoc_insertion_point(field:tendermint.abci.ConsensusParams.evidence)
    pub evidence: ::protobuf::MessageField<super::params::EvidenceParams>,
    // @@protoc_insertion_point(field:tendermint.abci.ConsensusParams.validator)
    pub validator: ::protobuf::MessageField<super::params::ValidatorParams>,
    // @@protoc_insertion_point(field:tendermint.abci.ConsensusParams.version)
    pub version: ::protobuf::MessageField<super::params::VersionParams>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ConsensusParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConsensusParams {
    fn default() -> &'a ConsensusParams {
        <ConsensusParams as ::protobuf::Message>::default_instance()
    }
}

impl ConsensusParams {
    pub fn new() -> ConsensusParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockParams>(
            "block",
            |m: &ConsensusParams| { &m.block },
            |m: &mut ConsensusParams| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::params::EvidenceParams>(
            "evidence",
            |m: &ConsensusParams| { &m.evidence },
            |m: &mut ConsensusParams| { &mut m.evidence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::params::ValidatorParams>(
            "validator",
            |m: &ConsensusParams| { &m.validator },
            |m: &mut ConsensusParams| { &mut m.validator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::params::VersionParams>(
            "version",
            |m: &ConsensusParams| { &m.version },
            |m: &mut ConsensusParams| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConsensusParams>(
            "ConsensusParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConsensusParams {
    const NAME: &'static str = "ConsensusParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.evidence)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.validator)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.evidence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.validator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.evidence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.validator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConsensusParams {
        ConsensusParams::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.evidence.clear();
        self.validator.clear();
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConsensusParams {
        static instance: ConsensusParams = ConsensusParams {
            block: ::protobuf::MessageField::none(),
            evidence: ::protobuf::MessageField::none(),
            validator: ::protobuf::MessageField::none(),
            version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConsensusParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConsensusParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConsensusParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BlockParams contains limits on the block size.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.BlockParams)
pub struct BlockParams {
    // message fields
    ///  Note: must be greater than 0
    // @@protoc_insertion_point(field:tendermint.abci.BlockParams.max_bytes)
    pub max_bytes: i64,
    ///  Note: must be greater or equal to -1
    // @@protoc_insertion_point(field:tendermint.abci.BlockParams.max_gas)
    pub max_gas: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.BlockParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockParams {
    fn default() -> &'a BlockParams {
        <BlockParams as ::protobuf::Message>::default_instance()
    }
}

impl BlockParams {
    pub fn new() -> BlockParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_bytes",
            |m: &BlockParams| { &m.max_bytes },
            |m: &mut BlockParams| { &mut m.max_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_gas",
            |m: &BlockParams| { &m.max_gas },
            |m: &mut BlockParams| { &mut m.max_gas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockParams>(
            "BlockParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockParams {
    const NAME: &'static str = "BlockParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_bytes = is.read_int64()?;
                },
                16 => {
                    self.max_gas = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.max_bytes != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.max_bytes);
        }
        if self.max_gas != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.max_gas);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.max_bytes != 0 {
            os.write_int64(1, self.max_bytes)?;
        }
        if self.max_gas != 0 {
            os.write_int64(2, self.max_gas)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockParams {
        BlockParams::new()
    }

    fn clear(&mut self) {
        self.max_bytes = 0;
        self.max_gas = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockParams {
        static instance: BlockParams = BlockParams {
            max_bytes: 0,
            max_gas: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.LastCommitInfo)
pub struct LastCommitInfo {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.LastCommitInfo.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.abci.LastCommitInfo.votes)
    pub votes: ::std::vec::Vec<VoteInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.LastCommitInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LastCommitInfo {
    fn default() -> &'a LastCommitInfo {
        <LastCommitInfo as ::protobuf::Message>::default_instance()
    }
}

impl LastCommitInfo {
    pub fn new() -> LastCommitInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &LastCommitInfo| { &m.round },
            |m: &mut LastCommitInfo| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "votes",
            |m: &LastCommitInfo| { &m.votes },
            |m: &mut LastCommitInfo| { &mut m.votes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LastCommitInfo>(
            "LastCommitInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LastCommitInfo {
    const NAME: &'static str = "LastCommitInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.round = is.read_int32()?;
                },
                18 => {
                    self.votes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.round);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.round != 0 {
            os.write_int32(1, self.round)?;
        }
        for v in &self.votes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LastCommitInfo {
        LastCommitInfo::new()
    }

    fn clear(&mut self) {
        self.round = 0;
        self.votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LastCommitInfo {
        static instance: LastCommitInfo = LastCommitInfo {
            round: 0,
            votes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LastCommitInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LastCommitInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LastCommitInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LastCommitInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Event allows application developers to attach additional information to
///  ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.
///  Later, transactions may be queried using these events.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.Event)
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.Event.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.abci.Event.attributes)
    pub attributes: ::std::vec::Vec<EventAttribute>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Event| { &m.type_ },
            |m: &mut Event| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &Event| { &m.attributes },
            |m: &mut Event| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
            "Event",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.attributes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            type_: ::std::string::String::new(),
            attributes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  EventAttribute is a single key-value pair, associated with an event.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.EventAttribute)
pub struct EventAttribute {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.EventAttribute.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.EventAttribute.value)
    pub value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.EventAttribute.index)
    pub index: bool,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.EventAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventAttribute {
    fn default() -> &'a EventAttribute {
        <EventAttribute as ::protobuf::Message>::default_instance()
    }
}

impl EventAttribute {
    pub fn new() -> EventAttribute {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &EventAttribute| { &m.key },
            |m: &mut EventAttribute| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &EventAttribute| { &m.value },
            |m: &mut EventAttribute| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &EventAttribute| { &m.index },
            |m: &mut EventAttribute| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventAttribute>(
            "EventAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventAttribute {
    const NAME: &'static str = "EventAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                24 => {
                    self.index = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.index != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.index != false {
            os.write_bool(3, self.index)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventAttribute {
        EventAttribute::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.index = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventAttribute {
        static instance: EventAttribute = EventAttribute {
            key: ::std::vec::Vec::new(),
            value: ::std::vec::Vec::new(),
            index: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TxResult contains results of executing the transaction.
///
///  One usage is indexing transaction results.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.TxResult)
pub struct TxResult {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.TxResult.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.abci.TxResult.index)
    pub index: u32,
    // @@protoc_insertion_point(field:tendermint.abci.TxResult.tx)
    pub tx: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.TxResult.result)
    pub result: ::protobuf::MessageField<ResponseDeliverTx>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.TxResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TxResult {
    fn default() -> &'a TxResult {
        <TxResult as ::protobuf::Message>::default_instance()
    }
}

impl TxResult {
    pub fn new() -> TxResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &TxResult| { &m.height },
            |m: &mut TxResult| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &TxResult| { &m.index },
            |m: &mut TxResult| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx",
            |m: &TxResult| { &m.tx },
            |m: &mut TxResult| { &mut m.tx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResponseDeliverTx>(
            "result",
            |m: &TxResult| { &m.result },
            |m: &mut TxResult| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TxResult>(
            "TxResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TxResult {
    const NAME: &'static str = "TxResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.index = is.read_uint32()?;
                },
                26 => {
                    self.tx = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.result)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.index);
        }
        if !self.tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.tx);
        }
        if let Some(v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.index != 0 {
            os.write_uint32(2, self.index)?;
        }
        if !self.tx.is_empty() {
            os.write_bytes(3, &self.tx)?;
        }
        if let Some(v) = self.result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TxResult {
        TxResult::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.index = 0;
        self.tx.clear();
        self.result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TxResult {
        static instance: TxResult = TxResult {
            height: 0,
            index: 0,
            tx: ::std::vec::Vec::new(),
            result: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TxResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TxResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TxResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Validator
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.Validator)
pub struct Validator {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.Validator.address)
    pub address: ::std::vec::Vec<u8>,
    ///  PubKey pub_key = 2 [(gogoproto.nullable)=false];
    // @@protoc_insertion_point(field:tendermint.abci.Validator.power)
    pub power: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.Validator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Validator| { &m.address },
            |m: &mut Validator| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "power",
            |m: &Validator| { &m.power },
            |m: &mut Validator| { &mut m.power },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Validator>(
            "Validator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Validator {
    const NAME: &'static str = "Validator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                24 => {
                    self.power = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.power != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.power);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.power != 0 {
            os.write_int64(3, self.power)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.power = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Validator {
        static instance: Validator = Validator {
            address: ::std::vec::Vec::new(),
            power: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Validator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Validator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValidatorUpdate
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.ValidatorUpdate)
pub struct ValidatorUpdate {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.ValidatorUpdate.pub_key)
    pub pub_key: ::protobuf::MessageField<super::keys::PublicKey>,
    // @@protoc_insertion_point(field:tendermint.abci.ValidatorUpdate.power)
    pub power: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.ValidatorUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorUpdate {
    fn default() -> &'a ValidatorUpdate {
        <ValidatorUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorUpdate {
    pub fn new() -> ValidatorUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::keys::PublicKey>(
            "pub_key",
            |m: &ValidatorUpdate| { &m.pub_key },
            |m: &mut ValidatorUpdate| { &mut m.pub_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "power",
            |m: &ValidatorUpdate| { &m.power },
            |m: &mut ValidatorUpdate| { &mut m.power },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorUpdate>(
            "ValidatorUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorUpdate {
    const NAME: &'static str = "ValidatorUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pub_key)?;
                },
                16 => {
                    self.power = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pub_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.power != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.power);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pub_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.power != 0 {
            os.write_int64(2, self.power)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorUpdate {
        ValidatorUpdate::new()
    }

    fn clear(&mut self) {
        self.pub_key.clear();
        self.power = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorUpdate {
        static instance: ValidatorUpdate = ValidatorUpdate {
            pub_key: ::protobuf::MessageField::none(),
            power: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  VoteInfo
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.VoteInfo)
pub struct VoteInfo {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.VoteInfo.validator)
    pub validator: ::protobuf::MessageField<Validator>,
    // @@protoc_insertion_point(field:tendermint.abci.VoteInfo.signed_last_block)
    pub signed_last_block: bool,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.VoteInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoteInfo {
    fn default() -> &'a VoteInfo {
        <VoteInfo as ::protobuf::Message>::default_instance()
    }
}

impl VoteInfo {
    pub fn new() -> VoteInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Validator>(
            "validator",
            |m: &VoteInfo| { &m.validator },
            |m: &mut VoteInfo| { &mut m.validator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signed_last_block",
            |m: &VoteInfo| { &m.signed_last_block },
            |m: &mut VoteInfo| { &mut m.signed_last_block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoteInfo>(
            "VoteInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoteInfo {
    const NAME: &'static str = "VoteInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.validator)?;
                },
                16 => {
                    self.signed_last_block = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.validator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.signed_last_block != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.validator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.signed_last_block != false {
            os.write_bool(2, self.signed_last_block)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoteInfo {
        VoteInfo::new()
    }

    fn clear(&mut self) {
        self.validator.clear();
        self.signed_last_block = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoteInfo {
        static instance: VoteInfo = VoteInfo {
            validator: ::protobuf::MessageField::none(),
            signed_last_block: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoteInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoteInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoteInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.Evidence)
pub struct Evidence {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.Evidence.type)
    pub type_: ::protobuf::EnumOrUnknown<EvidenceType>,
    ///  The offending validator
    // @@protoc_insertion_point(field:tendermint.abci.Evidence.validator)
    pub validator: ::protobuf::MessageField<Validator>,
    ///  The height when the offense occurred
    // @@protoc_insertion_point(field:tendermint.abci.Evidence.height)
    pub height: i64,
    ///  The corresponding time where the offense occurred
    // @@protoc_insertion_point(field:tendermint.abci.Evidence.time)
    pub time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Total voting power of the validator set in case the ABCI application does
    ///  not store historical validators.
    ///  https://github.com/tendermint/tendermint/issues/4581
    // @@protoc_insertion_point(field:tendermint.abci.Evidence.total_voting_power)
    pub total_voting_power: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.Evidence.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Evidence {
    fn default() -> &'a Evidence {
        <Evidence as ::protobuf::Message>::default_instance()
    }
}

impl Evidence {
    pub fn new() -> Evidence {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Evidence| { &m.type_ },
            |m: &mut Evidence| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Validator>(
            "validator",
            |m: &Evidence| { &m.validator },
            |m: &mut Evidence| { &mut m.validator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Evidence| { &m.height },
            |m: &mut Evidence| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            |m: &Evidence| { &m.time },
            |m: &mut Evidence| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_voting_power",
            |m: &Evidence| { &m.total_voting_power },
            |m: &mut Evidence| { &mut m.total_voting_power },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Evidence>(
            "Evidence",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Evidence {
    const NAME: &'static str = "Evidence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.validator)?;
                },
                24 => {
                    self.height = is.read_int64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                40 => {
                    self.total_voting_power = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(EvidenceType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.validator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.height);
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total_voting_power != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.total_voting_power);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(EvidenceType::UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.validator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.height != 0 {
            os.write_int64(3, self.height)?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.total_voting_power != 0 {
            os.write_int64(5, self.total_voting_power)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Evidence {
        Evidence::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(EvidenceType::UNKNOWN);
        self.validator.clear();
        self.height = 0;
        self.time.clear();
        self.total_voting_power = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Evidence {
        static instance: Evidence = Evidence {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            validator: ::protobuf::MessageField::none(),
            height: 0,
            time: ::protobuf::MessageField::none(),
            total_voting_power: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Evidence {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Evidence").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Evidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Evidence {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.abci.Snapshot)
pub struct Snapshot {
    // message fields
    // @@protoc_insertion_point(field:tendermint.abci.Snapshot.height)
    pub height: u64,
    // @@protoc_insertion_point(field:tendermint.abci.Snapshot.format)
    pub format: u32,
    // @@protoc_insertion_point(field:tendermint.abci.Snapshot.chunks)
    pub chunks: u32,
    // @@protoc_insertion_point(field:tendermint.abci.Snapshot.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.abci.Snapshot.metadata)
    pub metadata: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.abci.Snapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Snapshot {
    fn default() -> &'a Snapshot {
        <Snapshot as ::protobuf::Message>::default_instance()
    }
}

impl Snapshot {
    pub fn new() -> Snapshot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Snapshot| { &m.height },
            |m: &mut Snapshot| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &Snapshot| { &m.format },
            |m: &mut Snapshot| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chunks",
            |m: &Snapshot| { &m.chunks },
            |m: &mut Snapshot| { &mut m.chunks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Snapshot| { &m.hash },
            |m: &mut Snapshot| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metadata",
            |m: &Snapshot| { &m.metadata },
            |m: &mut Snapshot| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Snapshot>(
            "Snapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Snapshot {
    const NAME: &'static str = "Snapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_uint64()?;
                },
                16 => {
                    self.format = is.read_uint32()?;
                },
                24 => {
                    self.chunks = is.read_uint32()?;
                },
                34 => {
                    self.hash = is.read_bytes()?;
                },
                42 => {
                    self.metadata = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.height);
        }
        if self.format != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.format);
        }
        if self.chunks != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.chunks);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.hash);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_uint64(1, self.height)?;
        }
        if self.format != 0 {
            os.write_uint32(2, self.format)?;
        }
        if self.chunks != 0 {
            os.write_uint32(3, self.chunks)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(4, &self.hash)?;
        }
        if !self.metadata.is_empty() {
            os.write_bytes(5, &self.metadata)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Snapshot {
        Snapshot::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.format = 0;
        self.chunks = 0;
        self.hash.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Snapshot {
        static instance: Snapshot = Snapshot {
            height: 0,
            format: 0,
            chunks: 0,
            hash: ::std::vec::Vec::new(),
            metadata: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Snapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Snapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Snapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Snapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tendermint.abci.CheckTxType)
pub enum CheckTxType {
    // @@protoc_insertion_point(enum_value:tendermint.abci.CheckTxType.NEW)
    NEW = 0,
    // @@protoc_insertion_point(enum_value:tendermint.abci.CheckTxType.RECHECK)
    RECHECK = 1,
}

impl ::protobuf::Enum for CheckTxType {
    const NAME: &'static str = "CheckTxType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CheckTxType> {
        match value {
            0 => ::std::option::Option::Some(CheckTxType::NEW),
            1 => ::std::option::Option::Some(CheckTxType::RECHECK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CheckTxType] = &[
        CheckTxType::NEW,
        CheckTxType::RECHECK,
    ];
}

impl ::protobuf::EnumFull for CheckTxType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CheckTxType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CheckTxType {
    fn default() -> Self {
        CheckTxType::NEW
    }
}

impl CheckTxType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CheckTxType>("CheckTxType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tendermint.abci.EvidenceType)
pub enum EvidenceType {
    // @@protoc_insertion_point(enum_value:tendermint.abci.EvidenceType.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:tendermint.abci.EvidenceType.DUPLICATE_VOTE)
    DUPLICATE_VOTE = 1,
    // @@protoc_insertion_point(enum_value:tendermint.abci.EvidenceType.LIGHT_CLIENT_ATTACK)
    LIGHT_CLIENT_ATTACK = 2,
}

impl ::protobuf::Enum for EvidenceType {
    const NAME: &'static str = "EvidenceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EvidenceType> {
        match value {
            0 => ::std::option::Option::Some(EvidenceType::UNKNOWN),
            1 => ::std::option::Option::Some(EvidenceType::DUPLICATE_VOTE),
            2 => ::std::option::Option::Some(EvidenceType::LIGHT_CLIENT_ATTACK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EvidenceType] = &[
        EvidenceType::UNKNOWN,
        EvidenceType::DUPLICATE_VOTE,
        EvidenceType::LIGHT_CLIENT_ATTACK,
    ];
}

impl ::protobuf::EnumFull for EvidenceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EvidenceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EvidenceType {
    fn default() -> Self {
        EvidenceType::UNKNOWN
    }
}

impl EvidenceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EvidenceType>("EvidenceType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1btendermint/abci/types.proto\x12\x0ftendermint.abci\x1a\x1dtendermi\
    nt/crypto/proof.proto\x1a\x1ctendermint/types/types.proto\x1a\x1ctenderm\
    int/crypto/keys.proto\x1a\x1dtendermint/types/params.proto\x1a\x1fgoogle\
    /protobuf/timestamp.proto\x1a\x14gogoproto/gogo.proto\"\x91\x08\n\x07Req\
    uest\x122\n\x04echo\x18\x01\x20\x01(\x0b2\x1c.tendermint.abci.RequestEch\
    oH\0R\x04echo\x125\n\x05flush\x18\x02\x20\x01(\x0b2\x1d.tendermint.abci.\
    RequestFlushH\0R\x05flush\x122\n\x04info\x18\x03\x20\x01(\x0b2\x1c.tende\
    rmint.abci.RequestInfoH\0R\x04info\x12B\n\nset_option\x18\x04\x20\x01(\
    \x0b2!.tendermint.abci.RequestSetOptionH\0R\tsetOption\x12B\n\ninit_chai\
    n\x18\x05\x20\x01(\x0b2!.tendermint.abci.RequestInitChainH\0R\tinitChain\
    \x125\n\x05query\x18\x06\x20\x01(\x0b2\x1d.tendermint.abci.RequestQueryH\
    \0R\x05query\x12E\n\x0bbegin_block\x18\x07\x20\x01(\x0b2\".tendermint.ab\
    ci.RequestBeginBlockH\0R\nbeginBlock\x12<\n\x08check_tx\x18\x08\x20\x01(\
    \x0b2\x1f.tendermint.abci.RequestCheckTxH\0R\x07checkTx\x12B\n\ndeliver_\
    tx\x18\t\x20\x01(\x0b2!.tendermint.abci.RequestDeliverTxH\0R\tdeliverTx\
    \x12?\n\tend_block\x18\n\x20\x01(\x0b2\x20.tendermint.abci.RequestEndBlo\
    ckH\0R\x08endBlock\x128\n\x06commit\x18\x0b\x20\x01(\x0b2\x1e.tendermint\
    .abci.RequestCommitH\0R\x06commit\x12N\n\x0elist_snapshots\x18\x0c\x20\
    \x01(\x0b2%.tendermint.abci.RequestListSnapshotsH\0R\rlistSnapshots\x12N\
    \n\x0eoffer_snapshot\x18\r\x20\x01(\x0b2%.tendermint.abci.RequestOfferSn\
    apshotH\0R\rofferSnapshot\x12[\n\x13load_snapshot_chunk\x18\x0e\x20\x01(\
    \x0b2).tendermint.abci.RequestLoadSnapshotChunkH\0R\x11loadSnapshotChunk\
    \x12^\n\x14apply_snapshot_chunk\x18\x0f\x20\x01(\x0b2*.tendermint.abci.R\
    equestApplySnapshotChunkH\0R\x12applySnapshotChunkB\x07\n\x05value\"'\n\
    \x0bRequestEcho\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\
    \x0e\n\x0cRequestFlush\"m\n\x0bRequestInfo\x12\x18\n\x07version\x18\x01\
    \x20\x01(\tR\x07version\x12#\n\rblock_version\x18\x02\x20\x01(\x04R\x0cb\
    lockVersion\x12\x1f\n\x0bp2p_version\x18\x03\x20\x01(\x04R\np2pVersion\"\
    :\n\x10RequestSetOption\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\xcb\x02\n\x10RequestInitC\
    hain\x128\n\x04time\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x04timeB\x08\xc8\xde\x1f\0\x90\xdf\x1f\x01\x12\x19\n\x08chain_id\x18\
    \x02\x20\x01(\tR\x07chainId\x12K\n\x10consensus_params\x18\x03\x20\x01(\
    \x0b2\x20.tendermint.abci.ConsensusParamsR\x0fconsensusParams\x12F\n\nva\
    lidators\x18\x04\x20\x03(\x0b2\x20.tendermint.abci.ValidatorUpdateR\nval\
    idatorsB\x04\xc8\xde\x1f\0\x12&\n\x0fapp_state_bytes\x18\x05\x20\x01(\
    \x0cR\rappStateBytes\x12%\n\x0einitial_height\x18\x06\x20\x01(\x03R\rini\
    tialHeight\"d\n\x0cRequestQuery\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x16\n\x06heig\
    ht\x18\x03\x20\x01(\x03R\x06height\x12\x14\n\x05prove\x18\x04\x20\x01(\
    \x08R\x05prove\"\x84\x02\n\x11RequestBeginBlock\x12\x12\n\x04hash\x18\
    \x01\x20\x01(\x0cR\x04hash\x126\n\x06header\x18\x02\x20\x01(\x0b2\x18.te\
    ndermint.types.HeaderR\x06headerB\x04\xc8\xde\x1f\0\x12O\n\x10last_commi\
    t_info\x18\x03\x20\x01(\x0b2\x1f.tendermint.abci.LastCommitInfoR\x0elast\
    CommitInfoB\x04\xc8\xde\x1f\0\x12R\n\x14byzantine_validators\x18\x04\x20\
    \x03(\x0b2\x19.tendermint.abci.EvidenceR\x13byzantineValidatorsB\x04\xc8\
    \xde\x1f\0\"R\n\x0eRequestCheckTx\x12\x0e\n\x02tx\x18\x01\x20\x01(\x0cR\
    \x02tx\x120\n\x04type\x18\x02\x20\x01(\x0e2\x1c.tendermint.abci.CheckTxT\
    ypeR\x04type\"\"\n\x10RequestDeliverTx\x12\x0e\n\x02tx\x18\x01\x20\x01(\
    \x0cR\x02tx\")\n\x0fRequestEndBlock\x12\x16\n\x06height\x18\x01\x20\x01(\
    \x03R\x06height\"\x0f\n\rRequestCommit\"\x16\n\x14RequestListSnapshots\"\
    h\n\x14RequestOfferSnapshot\x125\n\x08snapshot\x18\x01\x20\x01(\x0b2\x19\
    .tendermint.abci.SnapshotR\x08snapshot\x12\x19\n\x08app_hash\x18\x02\x20\
    \x01(\x0cR\x07appHash\"`\n\x18RequestLoadSnapshotChunk\x12\x16\n\x06heig\
    ht\x18\x01\x20\x01(\x04R\x06height\x12\x16\n\x06format\x18\x02\x20\x01(\
    \rR\x06format\x12\x14\n\x05chunk\x18\x03\x20\x01(\rR\x05chunk\"_\n\x19Re\
    questApplySnapshotChunk\x12\x14\n\x05index\x18\x01\x20\x01(\rR\x05index\
    \x12\x14\n\x05chunk\x18\x02\x20\x01(\x0cR\x05chunk\x12\x16\n\x06sender\
    \x18\x03\x20\x01(\tR\x06sender\"\xe5\x08\n\x08Response\x12B\n\texception\
    \x18\x01\x20\x01(\x0b2\".tendermint.abci.ResponseExceptionH\0R\texceptio\
    n\x123\n\x04echo\x18\x02\x20\x01(\x0b2\x1d.tendermint.abci.ResponseEchoH\
    \0R\x04echo\x126\n\x05flush\x18\x03\x20\x01(\x0b2\x1e.tendermint.abci.Re\
    sponseFlushH\0R\x05flush\x123\n\x04info\x18\x04\x20\x01(\x0b2\x1d.tender\
    mint.abci.ResponseInfoH\0R\x04info\x12C\n\nset_option\x18\x05\x20\x01(\
    \x0b2\".tendermint.abci.ResponseSetOptionH\0R\tsetOption\x12C\n\ninit_ch\
    ain\x18\x06\x20\x01(\x0b2\".tendermint.abci.ResponseInitChainH\0R\tinitC\
    hain\x126\n\x05query\x18\x07\x20\x01(\x0b2\x1e.tendermint.abci.ResponseQ\
    ueryH\0R\x05query\x12F\n\x0bbegin_block\x18\x08\x20\x01(\x0b2#.tendermin\
    t.abci.ResponseBeginBlockH\0R\nbeginBlock\x12=\n\x08check_tx\x18\t\x20\
    \x01(\x0b2\x20.tendermint.abci.ResponseCheckTxH\0R\x07checkTx\x12C\n\nde\
    liver_tx\x18\n\x20\x01(\x0b2\".tendermint.abci.ResponseDeliverTxH\0R\tde\
    liverTx\x12@\n\tend_block\x18\x0b\x20\x01(\x0b2!.tendermint.abci.Respons\
    eEndBlockH\0R\x08endBlock\x129\n\x06commit\x18\x0c\x20\x01(\x0b2\x1f.ten\
    dermint.abci.ResponseCommitH\0R\x06commit\x12O\n\x0elist_snapshots\x18\r\
    \x20\x01(\x0b2&.tendermint.abci.ResponseListSnapshotsH\0R\rlistSnapshots\
    \x12O\n\x0eoffer_snapshot\x18\x0e\x20\x01(\x0b2&.tendermint.abci.Respons\
    eOfferSnapshotH\0R\rofferSnapshot\x12\\\n\x13load_snapshot_chunk\x18\x0f\
    \x20\x01(\x0b2*.tendermint.abci.ResponseLoadSnapshotChunkH\0R\x11loadSna\
    pshotChunk\x12_\n\x14apply_snapshot_chunk\x18\x10\x20\x01(\x0b2+.tenderm\
    int.abci.ResponseApplySnapshotChunkH\0R\x12applySnapshotChunkB\x07\n\x05\
    value\")\n\x11ResponseException\x12\x14\n\x05error\x18\x01\x20\x01(\tR\
    \x05error\"(\n\x0cResponseEcho\x12\x18\n\x07message\x18\x01\x20\x01(\tR\
    \x07message\"\x0f\n\rResponseFlush\"\xb8\x01\n\x0cResponseInfo\x12\x12\n\
    \x04data\x18\x01\x20\x01(\tR\x04data\x12\x18\n\x07version\x18\x02\x20\
    \x01(\tR\x07version\x12\x1f\n\x0bapp_version\x18\x03\x20\x01(\x04R\nappV\
    ersion\x12*\n\x11last_block_height\x18\x04\x20\x01(\x03R\x0flastBlockHei\
    ght\x12-\n\x13last_block_app_hash\x18\x05\x20\x01(\x0cR\x10lastBlockAppH\
    ash\"M\n\x11ResponseSetOption\x12\x12\n\x04code\x18\x01\x20\x01(\rR\x04c\
    ode\x12\x10\n\x03log\x18\x03\x20\x01(\tR\x03log\x12\x12\n\x04info\x18\
    \x04\x20\x01(\tR\x04info\"\xc3\x01\n\x11ResponseInitChain\x12K\n\x10cons\
    ensus_params\x18\x01\x20\x01(\x0b2\x20.tendermint.abci.ConsensusParamsR\
    \x0fconsensusParams\x12F\n\nvalidators\x18\x02\x20\x03(\x0b2\x20.tenderm\
    int.abci.ValidatorUpdateR\nvalidatorsB\x04\xc8\xde\x1f\0\x12\x19\n\x08ap\
    p_hash\x18\x03\x20\x01(\x0cR\x07appHash\"\xf7\x01\n\rResponseQuery\x12\
    \x12\n\x04code\x18\x01\x20\x01(\rR\x04code\x12\x10\n\x03log\x18\x03\x20\
    \x01(\tR\x03log\x12\x12\n\x04info\x18\x04\x20\x01(\tR\x04info\x12\x14\n\
    \x05index\x18\x05\x20\x01(\x03R\x05index\x12\x10\n\x03key\x18\x06\x20\
    \x01(\x0cR\x03key\x12\x14\n\x05value\x18\x07\x20\x01(\x0cR\x05value\x128\
    \n\tproof_ops\x18\x08\x20\x01(\x0b2\x1b.tendermint.crypto.ProofOpsR\x08p\
    roofOps\x12\x16\n\x06height\x18\t\x20\x01(\x03R\x06height\x12\x1c\n\tcod\
    espace\x18\n\x20\x01(\tR\tcodespace\"^\n\x12ResponseBeginBlock\x12H\n\
    \x06events\x18\x01\x20\x03(\x0b2\x16.tendermint.abci.EventR\x06eventsB\
    \x18\xc8\xde\x1f\0\xea\xde\x1f\x10events,omitempty\"\x83\x02\n\x0fRespon\
    seCheckTx\x12\x12\n\x04code\x18\x01\x20\x01(\rR\x04code\x12\x12\n\x04dat\
    a\x18\x02\x20\x01(\x0cR\x04data\x12\x10\n\x03log\x18\x03\x20\x01(\tR\x03\
    log\x12\x12\n\x04info\x18\x04\x20\x01(\tR\x04info\x12\x1e\n\ngas_wanted\
    \x18\x05\x20\x01(\x03R\ngas_wanted\x12\x1a\n\x08gas_used\x18\x06\x20\x01\
    (\x03R\x08gas_used\x12H\n\x06events\x18\x07\x20\x03(\x0b2\x16.tendermint\
    .abci.EventR\x06eventsB\x18\xc8\xde\x1f\0\xea\xde\x1f\x10events,omitempt\
    y\x12\x1c\n\tcodespace\x18\x08\x20\x01(\tR\tcodespace\"\x85\x02\n\x11Res\
    ponseDeliverTx\x12\x12\n\x04code\x18\x01\x20\x01(\rR\x04code\x12\x12\n\
    \x04data\x18\x02\x20\x01(\x0cR\x04data\x12\x10\n\x03log\x18\x03\x20\x01(\
    \tR\x03log\x12\x12\n\x04info\x18\x04\x20\x01(\tR\x04info\x12\x1e\n\ngas_\
    wanted\x18\x05\x20\x01(\x03R\ngas_wanted\x12\x1a\n\x08gas_used\x18\x06\
    \x20\x01(\x03R\x08gas_used\x12H\n\x06events\x18\x07\x20\x03(\x0b2\x16.te\
    ndermint.abci.EventR\x06eventsB\x18\xc8\xde\x1f\0\xea\xde\x1f\x10events,\
    omitempty\x12\x1c\n\tcodespace\x18\x08\x20\x01(\tR\tcodespace\"\x8b\x02\
    \n\x10ResponseEndBlock\x12S\n\x11validator_updates\x18\x01\x20\x03(\x0b2\
    \x20.tendermint.abci.ValidatorUpdateR\x10validatorUpdatesB\x04\xc8\xde\
    \x1f\0\x12X\n\x17consensus_param_updates\x18\x02\x20\x01(\x0b2\x20.tende\
    rmint.abci.ConsensusParamsR\x15consensusParamUpdates\x12H\n\x06events\
    \x18\x03\x20\x03(\x0b2\x16.tendermint.abci.EventR\x06eventsB\x18\xc8\xde\
    \x1f\0\xea\xde\x1f\x10events,omitempty\"I\n\x0eResponseCommit\x12\x12\n\
    \x04data\x18\x02\x20\x01(\x0cR\x04data\x12#\n\rretain_height\x18\x03\x20\
    \x01(\x03R\x0cretainHeight\"P\n\x15ResponseListSnapshots\x127\n\tsnapsho\
    ts\x18\x01\x20\x03(\x0b2\x19.tendermint.abci.SnapshotR\tsnapshots\"\xbe\
    \x01\n\x15ResponseOfferSnapshot\x12E\n\x06result\x18\x01\x20\x01(\x0e2-.\
    tendermint.abci.ResponseOfferSnapshot.ResultR\x06result\"^\n\x06Result\
    \x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06ACCEPT\x10\x01\x12\t\n\x05ABORT\
    \x10\x02\x12\n\n\x06REJECT\x10\x03\x12\x11\n\rREJECT_FORMAT\x10\x04\x12\
    \x11\n\rREJECT_SENDER\x10\x05\"1\n\x19ResponseLoadSnapshotChunk\x12\x14\
    \n\x05chunk\x18\x01\x20\x01(\x0cR\x05chunk\"\x98\x02\n\x1aResponseApplyS\
    napshotChunk\x12J\n\x06result\x18\x01\x20\x01(\x0e22.tendermint.abci.Res\
    ponseApplySnapshotChunk.ResultR\x06result\x12%\n\x0erefetch_chunks\x18\
    \x02\x20\x03(\rR\rrefetchChunks\x12%\n\x0ereject_senders\x18\x03\x20\x03\
    (\tR\rrejectSenders\"`\n\x06Result\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\
    \x06ACCEPT\x10\x01\x12\t\n\x05ABORT\x10\x02\x12\t\n\x05RETRY\x10\x03\x12\
    \x12\n\x0eRETRY_SNAPSHOT\x10\x04\x12\x13\n\x0fREJECT_SNAPSHOT\x10\x05\"\
    \xff\x01\n\x0fConsensusParams\x122\n\x05block\x18\x01\x20\x01(\x0b2\x1c.\
    tendermint.abci.BlockParamsR\x05block\x12<\n\x08evidence\x18\x02\x20\x01\
    (\x0b2\x20.tendermint.types.EvidenceParamsR\x08evidence\x12?\n\tvalidato\
    r\x18\x03\x20\x01(\x0b2!.tendermint.types.ValidatorParamsR\tvalidator\
    \x129\n\x07version\x18\x04\x20\x01(\x0b2\x1f.tendermint.types.VersionPar\
    amsR\x07version\"C\n\x0bBlockParams\x12\x1b\n\tmax_bytes\x18\x01\x20\x01\
    (\x03R\x08maxBytes\x12\x17\n\x07max_gas\x18\x02\x20\x01(\x03R\x06maxGas\
    \"]\n\x0eLastCommitInfo\x12\x14\n\x05round\x18\x01\x20\x01(\x05R\x05roun\
    d\x125\n\x05votes\x18\x02\x20\x03(\x0b2\x19.tendermint.abci.VoteInfoR\
    \x05votesB\x04\xc8\xde\x1f\0\"z\n\x05Event\x12\x12\n\x04type\x18\x01\x20\
    \x01(\tR\x04type\x12]\n\nattributes\x18\x02\x20\x03(\x0b2\x1f.tendermint\
    .abci.EventAttributeR\nattributesB\x1c\xc8\xde\x1f\0\xea\xde\x1f\x14attr\
    ibutes,omitempty\"N\n\x0eEventAttribute\x12\x10\n\x03key\x18\x01\x20\x01\
    (\x0cR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\x12\x14\
    \n\x05index\x18\x03\x20\x01(\x08R\x05index\"\x8a\x01\n\x08TxResult\x12\
    \x16\n\x06height\x18\x01\x20\x01(\x03R\x06height\x12\x14\n\x05index\x18\
    \x02\x20\x01(\rR\x05index\x12\x0e\n\x02tx\x18\x03\x20\x01(\x0cR\x02tx\
    \x12@\n\x06result\x18\x04\x20\x01(\x0b2\".tendermint.abci.ResponseDelive\
    rTxR\x06resultB\x04\xc8\xde\x1f\0\";\n\tValidator\x12\x18\n\x07address\
    \x18\x01\x20\x01(\x0cR\x07address\x12\x14\n\x05power\x18\x03\x20\x01(\
    \x03R\x05power\"d\n\x0fValidatorUpdate\x12;\n\x07pub_key\x18\x01\x20\x01\
    (\x0b2\x1c.tendermint.crypto.PublicKeyR\x06pubKeyB\x04\xc8\xde\x1f\0\x12\
    \x14\n\x05power\x18\x02\x20\x01(\x03R\x05power\"v\n\x08VoteInfo\x12>\n\t\
    validator\x18\x01\x20\x01(\x0b2\x1a.tendermint.abci.ValidatorR\tvalidato\
    rB\x04\xc8\xde\x1f\0\x12*\n\x11signed_last_block\x18\x02\x20\x01(\x08R\
    \x0fsignedLastBlock\"\xfd\x01\n\x08Evidence\x121\n\x04type\x18\x01\x20\
    \x01(\x0e2\x1d.tendermint.abci.EvidenceTypeR\x04type\x12>\n\tvalidator\
    \x18\x02\x20\x01(\x0b2\x1a.tendermint.abci.ValidatorR\tvalidatorB\x04\
    \xc8\xde\x1f\0\x12\x16\n\x06height\x18\x03\x20\x01(\x03R\x06height\x128\
    \n\x04time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x04timeB\
    \x08\xc8\xde\x1f\0\x90\xdf\x1f\x01\x12,\n\x12total_voting_power\x18\x05\
    \x20\x01(\x03R\x10totalVotingPower\"\x82\x01\n\x08Snapshot\x12\x16\n\x06\
    height\x18\x01\x20\x01(\x04R\x06height\x12\x16\n\x06format\x18\x02\x20\
    \x01(\rR\x06format\x12\x16\n\x06chunks\x18\x03\x20\x01(\rR\x06chunks\x12\
    \x12\n\x04hash\x18\x04\x20\x01(\x0cR\x04hash\x12\x1a\n\x08metadata\x18\
    \x05\x20\x01(\x0cR\x08metadata*9\n\x0bCheckTxType\x12\x10\n\x03NEW\x10\0\
    \x1a\x07\x8a\x9d\x20\x03New\x12\x18\n\x07RECHECK\x10\x01\x1a\x0b\x8a\x9d\
    \x20\x07Recheck*H\n\x0cEvidenceType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x12\n\
    \x0eDUPLICATE_VOTE\x10\x01\x12\x17\n\x13LIGHT_CLIENT_ATTACK\x10\x022\x83\
    \n\n\x0fABCIApplication\x12C\n\x04Echo\x12\x1c.tendermint.abci.RequestEc\
    ho\x1a\x1d.tendermint.abci.ResponseEcho\x12F\n\x05Flush\x12\x1d.tendermi\
    nt.abci.RequestFlush\x1a\x1e.tendermint.abci.ResponseFlush\x12C\n\x04Inf\
    o\x12\x1c.tendermint.abci.RequestInfo\x1a\x1d.tendermint.abci.ResponseIn\
    fo\x12R\n\tSetOption\x12!.tendermint.abci.RequestSetOption\x1a\".tenderm\
    int.abci.ResponseSetOption\x12R\n\tDeliverTx\x12!.tendermint.abci.Reques\
    tDeliverTx\x1a\".tendermint.abci.ResponseDeliverTx\x12L\n\x07CheckTx\x12\
    \x1f.tendermint.abci.RequestCheckTx\x1a\x20.tendermint.abci.ResponseChec\
    kTx\x12F\n\x05Query\x12\x1d.tendermint.abci.RequestQuery\x1a\x1e.tenderm\
    int.abci.ResponseQuery\x12I\n\x06Commit\x12\x1e.tendermint.abci.RequestC\
    ommit\x1a\x1f.tendermint.abci.ResponseCommit\x12R\n\tInitChain\x12!.tend\
    ermint.abci.RequestInitChain\x1a\".tendermint.abci.ResponseInitChain\x12\
    U\n\nBeginBlock\x12\".tendermint.abci.RequestBeginBlock\x1a#.tendermint.\
    abci.ResponseBeginBlock\x12O\n\x08EndBlock\x12\x20.tendermint.abci.Reque\
    stEndBlock\x1a!.tendermint.abci.ResponseEndBlock\x12^\n\rListSnapshots\
    \x12%.tendermint.abci.RequestListSnapshots\x1a&.tendermint.abci.Response\
    ListSnapshots\x12^\n\rOfferSnapshot\x12%.tendermint.abci.RequestOfferSna\
    pshot\x1a&.tendermint.abci.ResponseOfferSnapshot\x12j\n\x11LoadSnapshotC\
    hunk\x12).tendermint.abci.RequestLoadSnapshotChunk\x1a*.tendermint.abci.\
    ResponseLoadSnapshotChunk\x12m\n\x12ApplySnapshotChunk\x12*.tendermint.a\
    bci.RequestApplySnapshotChunk\x1a+.tendermint.abci.ResponseApplySnapshot\
    ChunkB-Z+github.com/tendermint/tendermint/abci/typesJ\x88{\n\x07\x12\x05\
    \0\0\x96\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\
    \x01\0\x18\n\x08\n\x01\x08\x12\x03\x03\0B\n\t\n\x02\x08\x0b\x12\x03\x03\
    \0B\nq\n\x02\x03\0\x12\x03\x07\0'\x1af\x20For\x20more\x20information\x20\
    on\x20gogo.proto,\x20see:\n\x20https://github.com/gogo/protobuf/blob/mas\
    ter/extensions.md\n\n\t\n\x02\x03\x01\x12\x03\x08\0&\n\t\n\x02\x03\x02\
    \x12\x03\t\0&\n\t\n\x02\x03\x03\x12\x03\n\0'\n\t\n\x02\x03\x04\x12\x03\
    \x0b\0)\n\t\n\x02\x03\x05\x12\x03\x0c\0\x1e\n\x88\x02\n\x02\x04\0\x12\
    \x04\x15\0'\x012\xc1\x01\x20This\x20file\x20is\x20copied\x20from\x20http\
    ://github.com/tendermint/abci\n\x20NOTE:\x20When\x20using\x20custom\x20t\
    ypes,\x20mind\x20the\x20warnings.\n\x20https://github.com/gogo/protobuf/\
    blob/master/custom_types.md#warnings-and-issues\n28---------------------\
    -------------------\n\x20Request\x20types\n\n\n\n\x03\x04\0\x01\x12\x03\
    \x15\x08\x0f\n\x0c\n\x04\x04\0\x08\0\x12\x04\x16\x02&\x03\n\x0c\n\x05\
    \x04\0\x08\0\x01\x12\x03\x16\x08\r\n\x0b\n\x04\x04\0\x02\0\x12\x03\x17\
    \x047\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x17\x04\x0f\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03\x17\x1e\"\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1756\n\
    \x0b\n\x04\x04\0\x02\x01\x12\x03\x18\x047\n\x0c\n\x05\x04\0\x02\x01\x06\
    \x12\x03\x18\x04\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x18\x1e#\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1856\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03\x19\x047\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x19\x04\x0f\n\x0c\n\
    \x05\x04\0\x02\x02\x01\x12\x03\x19\x1e\"\n\x0c\n\x05\x04\0\x02\x02\x03\
    \x12\x03\x1956\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x1a\x047\n\x0c\n\x05\
    \x04\0\x02\x03\x06\x12\x03\x1a\x04\x14\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03\x1a\x1e(\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x1a56\n\x0b\n\x04\
    \x04\0\x02\x04\x12\x03\x1b\x047\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\
    \x1b\x04\x14\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1b\x1e(\n\x0c\n\x05\
    \x04\0\x02\x04\x03\x12\x03\x1b56\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x1c\
    \x047\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\x1c\x04\x10\n\x0c\n\x05\x04\
    \0\x02\x05\x01\x12\x03\x1c\x1e#\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\
    \x1c56\n\x0b\n\x04\x04\0\x02\x06\x12\x03\x1d\x047\n\x0c\n\x05\x04\0\x02\
    \x06\x06\x12\x03\x1d\x04\x15\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x1d\
    \x1e)\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x1d56\n\x0b\n\x04\x04\0\x02\
    \x07\x12\x03\x1e\x047\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03\x1e\x04\x12\
    \n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x1e\x1e&\n\x0c\n\x05\x04\0\x02\
    \x07\x03\x12\x03\x1e56\n\x0b\n\x04\x04\0\x02\x08\x12\x03\x1f\x047\n\x0c\
    \n\x05\x04\0\x02\x08\x06\x12\x03\x1f\x04\x14\n\x0c\n\x05\x04\0\x02\x08\
    \x01\x12\x03\x1f\x1e(\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1f56\n\x0b\
    \n\x04\x04\0\x02\t\x12\x03\x20\x048\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03\
    \x20\x04\x13\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x20\x1e'\n\x0c\n\x05\
    \x04\0\x02\t\x03\x12\x03\x2057\n\x0b\n\x04\x04\0\x02\n\x12\x03!\x048\n\
    \x0c\n\x05\x04\0\x02\n\x06\x12\x03!\x04\x11\n\x0c\n\x05\x04\0\x02\n\x01\
    \x12\x03!\x1e$\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03!57\n\x0b\n\x04\x04\0\
    \x02\x0b\x12\x03\"\x048\n\x0c\n\x05\x04\0\x02\x0b\x06\x12\x03\"\x04\x18\
    \n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03\"\x1e,\n\x0c\n\x05\x04\0\x02\x0b\
    \x03\x12\x03\"57\n\x0b\n\x04\x04\0\x02\x0c\x12\x03#\x048\n\x0c\n\x05\x04\
    \0\x02\x0c\x06\x12\x03#\x04\x18\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03#\
    \x1e,\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03#57\n\x0b\n\x04\x04\0\x02\r\
    \x12\x03$\x048\n\x0c\n\x05\x04\0\x02\r\x06\x12\x03$\x04\x1c\n\x0c\n\x05\
    \x04\0\x02\r\x01\x12\x03$\x1e1\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03$57\n\
    \x0b\n\x04\x04\0\x02\x0e\x12\x03%\x048\n\x0c\n\x05\x04\0\x02\x0e\x06\x12\
    \x03%\x04\x1d\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03%\x1e2\n\x0c\n\x05\
    \x04\0\x02\x0e\x03\x12\x03%57\n\n\n\x02\x04\x01\x12\x04)\0+\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03)\x08\x13\n\x0b\n\x04\x04\x01\x02\0\x12\x03*\x02\
    \x15\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03*\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03*\t\x10\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03*\x13\x14\
    \n\t\n\x02\x04\x02\x12\x03-\0\x17\n\n\n\x03\x04\x02\x01\x12\x03-\x08\x14\
    \n\n\n\x02\x04\x03\x12\x04/\03\x01\n\n\n\x03\x04\x03\x01\x12\x03/\x08\
    \x13\n\x0b\n\x04\x04\x03\x02\0\x12\x030\x02\x1b\n\x0c\n\x05\x04\x03\x02\
    \0\x05\x12\x030\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x030\t\x10\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x030\x19\x1a\n\x0b\n\x04\x04\x03\x02\
    \x01\x12\x031\x02\x1b\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x031\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x031\t\x16\n\x0c\n\x05\x04\x03\x02\
    \x01\x03\x12\x031\x19\x1a\n\x0b\n\x04\x04\x03\x02\x02\x12\x032\x02\x1b\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x032\t\x14\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x032\x19\x1a\
    \n\x1e\n\x02\x04\x04\x12\x046\09\x01\x1a\x12\x20nondeterministic\n\n\n\n\
    \x03\x04\x04\x01\x12\x036\x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\x037\x02\
    \x13\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x037\x02\x08\n\x0c\n\x05\x04\x04\
    \x02\0\x01\x12\x037\t\x0c\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x037\x11\x12\
    \n\x0b\n\x04\x04\x04\x02\x01\x12\x038\x02\x13\n\x0c\n\x05\x04\x04\x02\
    \x01\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x038\t\x0e\
    \n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x038\x11\x12\n\n\n\x02\x04\x05\x12\
    \x04;\0C\x01\n\n\n\x03\x04\x05\x01\x12\x03;\x08\x18\n\x0c\n\x04\x04\x05\
    \x02\0\x12\x04<\x02=A\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03<\x02\x1b\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03<\x1c\x20\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03<#$\n\x0c\n\x05\x04\x05\x02\0\x08\x12\x03=\x06@\n\x0f\n\x08\
    \x04\x05\x02\0\x08\xe9\xfb\x03\x12\x03=\x07#\n\x0f\n\x08\x04\x05\x02\0\
    \x08\xf2\xfb\x03\x12\x03=%?\n\x0b\n\x04\x04\x05\x02\x01\x12\x03>\x020\n\
    \x0c\n\x05\x04\x05\x02\x01\x05\x12\x03>\x02\x08\n\x0c\n\x05\x04\x05\x02\
    \x01\x01\x12\x03>\x1b#\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03>./\n\x0b\
    \n\x04\x04\x05\x02\x02\x12\x03?\x020\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\
    \x03?\x02\x11\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03?\x1b+\n\x0c\n\x05\
    \x04\x05\x02\x02\x03\x12\x03?./\n\x0b\n\x04\x04\x05\x02\x03\x12\x03@\x02\
    O\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03@\x02\n\n\x0c\n\x05\x04\x05\x02\
    \x03\x06\x12\x03@\x0b\x1a\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03@\x1b%\
    \n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03@./\n\x0c\n\x05\x04\x05\x02\x03\
    \x08\x12\x03@0N\n\x0f\n\x08\x04\x05\x02\x03\x08\xe9\xfb\x03\x12\x03@1M\n\
    \x0b\n\x04\x04\x05\x02\x04\x12\x03A\x020\n\x0c\n\x05\x04\x05\x02\x04\x05\
    \x12\x03A\x02\x07\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03A\x1b*\n\x0c\n\
    \x05\x04\x05\x02\x04\x03\x12\x03A./\n\x0b\n\x04\x04\x05\x02\x05\x12\x03B\
    \x020\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x03B\x02\x07\n\x0c\n\x05\x04\
    \x05\x02\x05\x01\x12\x03B\x1b)\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03B.\
    /\n\n\n\x02\x04\x06\x12\x04E\0J\x01\n\n\n\x03\x04\x06\x01\x12\x03E\x08\
    \x14\n\x0b\n\x04\x04\x06\x02\0\x12\x03F\x02\x14\n\x0c\n\x05\x04\x06\x02\
    \0\x05\x12\x03F\x02\x07\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03F\t\r\n\x0c\
    \n\x05\x04\x06\x02\0\x03\x12\x03F\x12\x13\n\x0b\n\x04\x04\x06\x02\x01\
    \x12\x03G\x02\x14\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03G\x02\x08\n\x0c\
    \n\x05\x04\x06\x02\x01\x01\x12\x03G\t\r\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03G\x12\x13\n\x0b\n\x04\x04\x06\x02\x02\x12\x03H\x02\x14\n\x0c\n\
    \x05\x04\x06\x02\x02\x05\x12\x03H\x02\x07\n\x0c\n\x05\x04\x06\x02\x02\
    \x01\x12\x03H\t\x0f\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03H\x12\x13\n\
    \x0b\n\x04\x04\x06\x02\x03\x12\x03I\x02\x14\n\x0c\n\x05\x04\x06\x02\x03\
    \x05\x12\x03I\x02\x06\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03I\t\x0e\n\
    \x0c\n\x05\x04\x06\x02\x03\x03\x12\x03I\x12\x13\n\n\n\x02\x04\x07\x12\
    \x04L\0Q\x01\n\n\n\x03\x04\x07\x01\x12\x03L\x08\x19\n\x0b\n\x04\x04\x07\
    \x02\0\x12\x03M\x023\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03M\x02\x07\n\
    \x0c\n\x05\x04\x07\x02\0\x01\x12\x03M\x1a\x1e\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03M12\n\x0b\n\x04\x04\x07\x02\x01\x12\x03N\x02R\n\x0c\n\x05\
    \x04\x07\x02\x01\x06\x12\x03N\x02\x19\n\x0c\n\x05\x04\x07\x02\x01\x01\
    \x12\x03N\x1a\x20\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03N12\n\x0c\n\x05\
    \x04\x07\x02\x01\x08\x12\x03N3Q\n\x0f\n\x08\x04\x07\x02\x01\x08\xe9\xfb\
    \x03\x12\x03N4P\n\x0b\n\x04\x04\x07\x02\x02\x12\x03O\x02R\n\x0c\n\x05\
    \x04\x07\x02\x02\x06\x12\x03O\x02\x10\n\x0c\n\x05\x04\x07\x02\x02\x01\
    \x12\x03O\x1a*\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03O12\n\x0c\n\x05\
    \x04\x07\x02\x02\x08\x12\x03O3Q\n\x0f\n\x08\x04\x07\x02\x02\x08\xe9\xfb\
    \x03\x12\x03O4P\n\x0b\n\x04\x04\x07\x02\x03\x12\x03P\x02R\n\x0c\n\x05\
    \x04\x07\x02\x03\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\x07\x02\x03\x06\x12\
    \x03P\x0b\x13\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03P\x1a.\n\x0c\n\x05\
    \x04\x07\x02\x03\x03\x12\x03P12\n\x0c\n\x05\x04\x07\x02\x03\x08\x12\x03P\
    3Q\n\x0f\n\x08\x04\x07\x02\x03\x08\xe9\xfb\x03\x12\x03P4P\n\n\n\x02\x05\
    \0\x12\x04S\0V\x01\n\n\n\x03\x05\0\x01\x12\x03S\x05\x10\n\x0b\n\x04\x05\
    \0\x02\0\x12\x03T\x029\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03T\x02\x05\n\
    \x0c\n\x05\x05\0\x02\0\x02\x12\x03T\x0c\r\n\x0c\n\x05\x05\0\x02\0\x03\
    \x12\x03T\x0e8\n\x0f\n\x08\x05\0\x02\0\x03\xd1\x83\x04\x12\x03T\x0f7\n\
    \x0b\n\x04\x05\0\x02\x01\x12\x03U\x02=\n\x0c\n\x05\x05\0\x02\x01\x01\x12\
    \x03U\x02\t\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03U\x0c\r\n\x0c\n\x05\x05\
    \0\x02\x01\x03\x12\x03U\x0e<\n\x0f\n\x08\x05\0\x02\x01\x03\xd1\x83\x04\
    \x12\x03U\x0f;\n\n\n\x02\x04\x08\x12\x04X\0[\x01\n\n\n\x03\x04\x08\x01\
    \x12\x03X\x08\x16\n\x0b\n\x04\x04\x08\x02\0\x12\x03Y\x02\x17\n\x0c\n\x05\
    \x04\x08\x02\0\x05\x12\x03Y\x02\x07\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03Y\x0e\x10\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03Y\x15\x16\n\x0b\n\x04\
    \x04\x08\x02\x01\x12\x03Z\x02\x17\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\
    \x03Z\x02\r\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03Z\x0e\x12\n\x0c\n\x05\
    \x04\x08\x02\x01\x03\x12\x03Z\x15\x16\n\n\n\x02\x04\t\x12\x04]\0_\x01\n\
    \n\n\x03\x04\t\x01\x12\x03]\x08\x18\n\x0b\n\x04\x04\t\x02\0\x12\x03^\x02\
    \x0f\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03^\x02\x07\n\x0c\n\x05\x04\t\x02\
    \0\x01\x12\x03^\x08\n\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03^\r\x0e\n\n\n\
    \x02\x04\n\x12\x04a\0c\x01\n\n\n\x03\x04\n\x01\x12\x03a\x08\x17\n\x0b\n\
    \x04\x04\n\x02\0\x12\x03b\x02\x13\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03b\
    \x02\x07\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03b\x08\x0e\n\x0c\n\x05\x04\n\
    \x02\0\x03\x12\x03b\x11\x12\n\t\n\x02\x04\x0b\x12\x03e\0\x18\n\n\n\x03\
    \x04\x0b\x01\x12\x03e\x08\x15\n'\n\x02\x04\x0c\x12\x04h\0i\x01\x1a\x1b\
    \x20lists\x20available\x20snapshots\n\n\n\n\x03\x04\x0c\x01\x12\x03h\x08\
    \x1c\n2\n\x02\x04\r\x12\x04l\0o\x01\x1a&\x20offers\x20a\x20snapshot\x20t\
    o\x20the\x20application\n\n\n\n\x03\x04\r\x01\x12\x03l\x08\x1c\n(\n\x04\
    \x04\r\x02\0\x12\x03m\x02\x18\"\x1b\x20snapshot\x20offered\x20by\x20peer\
    s\n\n\x0c\n\x05\x04\r\x02\0\x06\x12\x03m\x02\n\n\x0c\n\x05\x04\r\x02\0\
    \x01\x12\x03m\x0b\x13\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03m\x16\x17\nA\n\
    \x04\x04\r\x02\x01\x12\x03n\x02\x18\"4\x20light\x20client-verified\x20ap\
    p\x20hash\x20for\x20snapshot\x20height\n\n\x0c\n\x05\x04\r\x02\x01\x05\
    \x12\x03n\x02\x07\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03n\x0b\x13\n\x0c\n\
    \x05\x04\r\x02\x01\x03\x12\x03n\x16\x17\n$\n\x02\x04\x0e\x12\x04r\0v\x01\
    \x1a\x18\x20loads\x20a\x20snapshot\x20chunk\n\n\n\n\x03\x04\x0e\x01\x12\
    \x03r\x08\x20\n\x0b\n\x04\x04\x0e\x02\0\x12\x03s\x02\x14\n\x0c\n\x05\x04\
    \x0e\x02\0\x05\x12\x03s\x02\x08\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03s\t\
    \x0f\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03s\x12\x13\n\x0b\n\x04\x04\x0e\
    \x02\x01\x12\x03t\x02\x14\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03t\x02\
    \x08\n\x0c\n\x05\x04\x0e\x02\x01\x01\x12\x03t\t\x0f\n\x0c\n\x05\x04\x0e\
    \x02\x01\x03\x12\x03t\x12\x13\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03u\x02\
    \x14\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\x03u\x02\x08\n\x0c\n\x05\x04\
    \x0e\x02\x02\x01\x12\x03u\t\x0e\n\x0c\n\x05\x04\x0e\x02\x02\x03\x12\x03u\
    \x12\x13\n&\n\x02\x04\x0f\x12\x04y\0}\x01\x1a\x1a\x20Applies\x20a\x20sna\
    pshot\x20chunk\n\n\n\n\x03\x04\x0f\x01\x12\x03y\x08!\n\x0b\n\x04\x04\x0f\
    \x02\0\x12\x03z\x02\x14\n\x0c\n\x05\x04\x0f\x02\0\x05\x12\x03z\x02\x08\n\
    \x0c\n\x05\x04\x0f\x02\0\x01\x12\x03z\t\x0e\n\x0c\n\x05\x04\x0f\x02\0\
    \x03\x12\x03z\x12\x13\n\x0b\n\x04\x04\x0f\x02\x01\x12\x03{\x02\x14\n\x0c\
    \n\x05\x04\x0f\x02\x01\x05\x12\x03{\x02\x07\n\x0c\n\x05\x04\x0f\x02\x01\
    \x01\x12\x03{\t\x0e\n\x0c\n\x05\x04\x0f\x02\x01\x03\x12\x03{\x12\x13\n\
    \x0b\n\x04\x04\x0f\x02\x02\x12\x03|\x02\x14\n\x0c\n\x05\x04\x0f\x02\x02\
    \x05\x12\x03|\x02\x08\n\x0c\n\x05\x04\x0f\x02\x02\x01\x12\x03|\t\x0f\n\
    \x0c\n\x05\x04\x0f\x02\x02\x03\x12\x03|\x12\x13\nG\n\x02\x04\x10\x12\x06\
    \x82\x01\0\x95\x01\x0129----------------------------------------\n\x20Re\
    sponse\x20types\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x82\x01\x08\x10\n\x0e\
    \n\x04\x04\x10\x08\0\x12\x06\x83\x01\x02\x94\x01\x03\n\r\n\x05\x04\x10\
    \x08\0\x01\x12\x04\x83\x01\x08\r\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x84\
    \x01\x048\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\x84\x01\x04\x15\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\x84\x01\x1f(\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\x84\x0167\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x85\x01\x048\n\r\n\
    \x05\x04\x10\x02\x01\x06\x12\x04\x85\x01\x04\x10\n\r\n\x05\x04\x10\x02\
    \x01\x01\x12\x04\x85\x01\x1f#\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x85\
    \x0167\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\x86\x01\x048\n\r\n\x05\x04\
    \x10\x02\x02\x06\x12\x04\x86\x01\x04\x11\n\r\n\x05\x04\x10\x02\x02\x01\
    \x12\x04\x86\x01\x1f$\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x86\x0167\n\
    \x0c\n\x04\x04\x10\x02\x03\x12\x04\x87\x01\x048\n\r\n\x05\x04\x10\x02\
    \x03\x06\x12\x04\x87\x01\x04\x10\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\
    \x87\x01\x1f#\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\x87\x0167\n\x0c\n\
    \x04\x04\x10\x02\x04\x12\x04\x88\x01\x048\n\r\n\x05\x04\x10\x02\x04\x06\
    \x12\x04\x88\x01\x04\x15\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\x88\x01\
    \x1f)\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\x88\x0167\n\x0c\n\x04\x04\
    \x10\x02\x05\x12\x04\x89\x01\x048\n\r\n\x05\x04\x10\x02\x05\x06\x12\x04\
    \x89\x01\x04\x15\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\x89\x01\x1f)\n\r\
    \n\x05\x04\x10\x02\x05\x03\x12\x04\x89\x0167\n\x0c\n\x04\x04\x10\x02\x06\
    \x12\x04\x8a\x01\x048\n\r\n\x05\x04\x10\x02\x06\x06\x12\x04\x8a\x01\x04\
    \x11\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\x8a\x01\x1f$\n\r\n\x05\x04\
    \x10\x02\x06\x03\x12\x04\x8a\x0167\n\x0c\n\x04\x04\x10\x02\x07\x12\x04\
    \x8b\x01\x048\n\r\n\x05\x04\x10\x02\x07\x06\x12\x04\x8b\x01\x04\x16\n\r\
    \n\x05\x04\x10\x02\x07\x01\x12\x04\x8b\x01\x1f*\n\r\n\x05\x04\x10\x02\
    \x07\x03\x12\x04\x8b\x0167\n\x0c\n\x04\x04\x10\x02\x08\x12\x04\x8c\x01\
    \x048\n\r\n\x05\x04\x10\x02\x08\x06\x12\x04\x8c\x01\x04\x13\n\r\n\x05\
    \x04\x10\x02\x08\x01\x12\x04\x8c\x01\x1f'\n\r\n\x05\x04\x10\x02\x08\x03\
    \x12\x04\x8c\x0167\n\x0c\n\x04\x04\x10\x02\t\x12\x04\x8d\x01\x049\n\r\n\
    \x05\x04\x10\x02\t\x06\x12\x04\x8d\x01\x04\x15\n\r\n\x05\x04\x10\x02\t\
    \x01\x12\x04\x8d\x01\x1f)\n\r\n\x05\x04\x10\x02\t\x03\x12\x04\x8d\x0168\
    \n\x0c\n\x04\x04\x10\x02\n\x12\x04\x8e\x01\x049\n\r\n\x05\x04\x10\x02\n\
    \x06\x12\x04\x8e\x01\x04\x14\n\r\n\x05\x04\x10\x02\n\x01\x12\x04\x8e\x01\
    \x1f(\n\r\n\x05\x04\x10\x02\n\x03\x12\x04\x8e\x0168\n\x0c\n\x04\x04\x10\
    \x02\x0b\x12\x04\x8f\x01\x049\n\r\n\x05\x04\x10\x02\x0b\x06\x12\x04\x8f\
    \x01\x04\x12\n\r\n\x05\x04\x10\x02\x0b\x01\x12\x04\x8f\x01\x1f%\n\r\n\
    \x05\x04\x10\x02\x0b\x03\x12\x04\x8f\x0168\n\x0c\n\x04\x04\x10\x02\x0c\
    \x12\x04\x90\x01\x049\n\r\n\x05\x04\x10\x02\x0c\x06\x12\x04\x90\x01\x04\
    \x19\n\r\n\x05\x04\x10\x02\x0c\x01\x12\x04\x90\x01\x1f-\n\r\n\x05\x04\
    \x10\x02\x0c\x03\x12\x04\x90\x0168\n\x0c\n\x04\x04\x10\x02\r\x12\x04\x91\
    \x01\x049\n\r\n\x05\x04\x10\x02\r\x06\x12\x04\x91\x01\x04\x19\n\r\n\x05\
    \x04\x10\x02\r\x01\x12\x04\x91\x01\x1f-\n\r\n\x05\x04\x10\x02\r\x03\x12\
    \x04\x91\x0168\n\x0c\n\x04\x04\x10\x02\x0e\x12\x04\x92\x01\x049\n\r\n\
    \x05\x04\x10\x02\x0e\x06\x12\x04\x92\x01\x04\x1d\n\r\n\x05\x04\x10\x02\
    \x0e\x01\x12\x04\x92\x01\x1f2\n\r\n\x05\x04\x10\x02\x0e\x03\x12\x04\x92\
    \x0168\n\x0c\n\x04\x04\x10\x02\x0f\x12\x04\x93\x01\x049\n\r\n\x05\x04\
    \x10\x02\x0f\x06\x12\x04\x93\x01\x04\x1e\n\r\n\x05\x04\x10\x02\x0f\x01\
    \x12\x04\x93\x01\x1f3\n\r\n\x05\x04\x10\x02\x0f\x03\x12\x04\x93\x0168\n\
    \x20\n\x02\x04\x11\x12\x06\x98\x01\0\x9a\x01\x01\x1a\x12\x20nondetermini\
    stic\n\n\x0b\n\x03\x04\x11\x01\x12\x04\x98\x01\x08\x19\n\x0c\n\x04\x04\
    \x11\x02\0\x12\x04\x99\x01\x02\x13\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\
    \x99\x01\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x99\x01\t\x0e\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\x99\x01\x11\x12\n\x0c\n\x02\x04\x12\x12\
    \x06\x9c\x01\0\x9e\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x9c\x01\x08\
    \x14\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x9d\x01\x02\x15\n\r\n\x05\x04\x12\
    \x02\0\x05\x12\x04\x9d\x01\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \x9d\x01\t\x10\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x9d\x01\x13\x14\n\n\n\
    \x02\x04\x13\x12\x04\xa0\x01\0\x18\n\x0b\n\x03\x04\x13\x01\x12\x04\xa0\
    \x01\x08\x15\n\x0c\n\x02\x04\x14\x12\x06\xa2\x01\0\xaa\x01\x01\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xa2\x01\x08\x14\n\x0c\n\x04\x04\x14\x02\0\x12\
    \x04\xa3\x01\x02\x12\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xa3\x01\x02\x08\
    \n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xa3\x01\t\r\n\r\n\x05\x04\x14\x02\0\
    \x03\x12\x04\xa3\x01\x10\x11\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xa5\x01\
    \x02\x19\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xa5\x01\x02\x08\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\xa5\x01\t\x10\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\xa5\x01\x17\x18\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xa6\x01\x02\
    \x19\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xa6\x01\x02\x08\n\r\n\x05\x04\
    \x14\x02\x02\x01\x12\x04\xa6\x01\t\x14\n\r\n\x05\x04\x14\x02\x02\x03\x12\
    \x04\xa6\x01\x17\x18\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xa8\x01\x02\x20\
    \n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\xa8\x01\x02\x07\n\r\n\x05\x04\x14\
    \x02\x03\x01\x12\x04\xa8\x01\x08\x19\n\r\n\x05\x04\x14\x02\x03\x03\x12\
    \x04\xa8\x01\x1e\x1f\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xa9\x01\x02\x20\
    \n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\xa9\x01\x02\x07\n\r\n\x05\x04\x14\
    \x02\x04\x01\x12\x04\xa9\x01\x08\x1b\n\r\n\x05\x04\x14\x02\x04\x03\x12\
    \x04\xa9\x01\x1e\x1f\n\x20\n\x02\x04\x15\x12\x06\xad\x01\0\xb2\x01\x01\
    \x1a\x12\x20nondeterministic\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xad\x01\
    \x08\x19\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xae\x01\x02\x12\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\xae\x01\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xae\x01\t\r\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xae\x01\x10\x11\n\
    \x1f\n\x04\x04\x15\x02\x01\x12\x04\xb0\x01\x02\x12\x1a\x11\x20bytes\x20d\
    ata\x20=\x202;\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xb0\x01\x02\x08\n\
    \r\n\x05\x04\x15\x02\x01\x01\x12\x04\xb0\x01\t\x0c\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\xb0\x01\x10\x11\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xb1\
    \x01\x02\x12\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xb1\x01\x02\x08\n\r\n\
    \x05\x04\x15\x02\x02\x01\x12\x04\xb1\x01\t\r\n\r\n\x05\x04\x15\x02\x02\
    \x03\x12\x04\xb1\x01\x10\x11\n\x0c\n\x02\x04\x16\x12\x06\xb4\x01\0\xb8\
    \x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xb4\x01\x08\x19\n\x0c\n\x04\x04\
    \x16\x02\0\x12\x04\xb5\x01\x020\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xb5\
    \x01\x02\x11\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb5\x01\x1b+\n\r\n\x05\
    \x04\x16\x02\0\x03\x12\x04\xb5\x01./\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\
    \xb6\x01\x02O\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xb6\x01\x02\n\n\r\n\
    \x05\x04\x16\x02\x01\x06\x12\x04\xb6\x01\x0b\x1a\n\r\n\x05\x04\x16\x02\
    \x01\x01\x12\x04\xb6\x01\x1b%\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xb6\
    \x01./\n\r\n\x05\x04\x16\x02\x01\x08\x12\x04\xb6\x010N\n\x10\n\x08\x04\
    \x16\x02\x01\x08\xe9\xfb\x03\x12\x04\xb6\x011M\n\x0c\n\x04\x04\x16\x02\
    \x02\x12\x04\xb7\x01\x020\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xb7\x01\
    \x02\x07\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xb7\x01\x1b#\n\r\n\x05\
    \x04\x16\x02\x02\x03\x12\x04\xb7\x01./\n\x0c\n\x02\x04\x17\x12\x06\xba\
    \x01\0\xc5\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xba\x01\x08\x15\n\x0c\
    \n\x04\x04\x17\x02\0\x12\x04\xbb\x01\x02\x12\n\r\n\x05\x04\x17\x02\0\x05\
    \x12\x04\xbb\x01\x02\x08\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xbb\x01\t\r\
    \n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xbb\x01\x10\x11\nK\n\x04\x04\x17\
    \x02\x01\x12\x04\xbd\x01\x02+\x1a)\x20bytes\x20data\x20=\x202;\x20//\x20\
    use\x20\"value\"\x20instead.\n\"\x12\x20nondeterministic\n\n\r\n\x05\x04\
    \x17\x02\x01\x05\x12\x04\xbd\x01\x02\x08\n\r\n\x05\x04\x17\x02\x01\x01\
    \x12\x04\xbd\x01\x1d\x20\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xbd\x01)*\
    \n\x20\n\x04\x04\x17\x02\x02\x12\x04\xbe\x01\x02+\"\x12\x20nondeterminis\
    tic\n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xbe\x01\x02\x08\n\r\n\x05\
    \x04\x17\x02\x02\x01\x12\x04\xbe\x01\x1d!\n\r\n\x05\x04\x17\x02\x02\x03\
    \x12\x04\xbe\x01)*\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\xbf\x01\x02+\n\r\
    \n\x05\x04\x17\x02\x03\x05\x12\x04\xbf\x01\x02\x07\n\r\n\x05\x04\x17\x02\
    \x03\x01\x12\x04\xbf\x01\x1d\"\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xbf\
    \x01)*\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\xc0\x01\x02+\n\r\n\x05\x04\
    \x17\x02\x04\x05\x12\x04\xc0\x01\x02\x07\n\r\n\x05\x04\x17\x02\x04\x01\
    \x12\x04\xc0\x01\x1d\x20\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\xc0\x01)*\
    \n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xc1\x01\x02+\n\r\n\x05\x04\x17\x02\
    \x05\x05\x12\x04\xc1\x01\x02\x07\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\
    \xc1\x01\x1d\"\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\xc1\x01)*\n\x0c\n\
    \x04\x04\x17\x02\x06\x12\x04\xc2\x01\x02+\n\r\n\x05\x04\x17\x02\x06\x06\
    \x12\x04\xc2\x01\x02\x1c\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\xc2\x01\
    \x1d&\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\xc2\x01)*\n\x0c\n\x04\x04\
    \x17\x02\x07\x12\x04\xc3\x01\x02+\n\r\n\x05\x04\x17\x02\x07\x05\x12\x04\
    \xc3\x01\x02\x07\n\r\n\x05\x04\x17\x02\x07\x01\x12\x04\xc3\x01\x1d#\n\r\
    \n\x05\x04\x17\x02\x07\x03\x12\x04\xc3\x01)*\n\x0c\n\x04\x04\x17\x02\x08\
    \x12\x04\xc4\x01\x02,\n\r\n\x05\x04\x17\x02\x08\x05\x12\x04\xc4\x01\x02\
    \x08\n\r\n\x05\x04\x17\x02\x08\x01\x12\x04\xc4\x01\x1d&\n\r\n\x05\x04\
    \x17\x02\x08\x03\x12\x04\xc4\x01)+\n\x0c\n\x02\x04\x18\x12\x06\xc7\x01\0\
    \xca\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xc7\x01\x08\x1a\n\x0e\n\x04\
    \x04\x18\x02\0\x12\x06\xc8\x01\x02\xc9\x01O\n\r\n\x05\x04\x18\x02\0\x04\
    \x12\x04\xc8\x01\x02\n\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xc8\x01\x0b\
    \x10\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xc8\x01\x11\x17\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\xc8\x01\x1a\x1b\n\r\n\x05\x04\x18\x02\0\x08\x12\
    \x04\xc9\x01\x06N\n\x10\n\x08\x04\x18\x02\0\x08\xe9\xfb\x03\x12\x04\xc9\
    \x01\x07#\n\x10\n\x08\x04\x18\x02\0\x08\xed\xfb\x03\x12\x04\xc9\x01%M\n\
    \x0c\n\x02\x04\x19\x12\x06\xcc\x01\0\xd6\x01\x01\n\x0b\n\x03\x04\x19\x01\
    \x12\x04\xcc\x01\x08\x17\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xcd\x01\x02\
    \x20\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xcd\x01\x02\x08\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\xcd\x01\x11\x15\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\xcd\x01\x1e\x1f\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xce\x01\x02\x20\
    \n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xce\x01\x02\x07\n\r\n\x05\x04\x19\
    \x02\x01\x01\x12\x04\xce\x01\x11\x15\n\r\n\x05\x04\x19\x02\x01\x03\x12\
    \x04\xce\x01\x1e\x1f\n\x20\n\x04\x04\x19\x02\x02\x12\x04\xcf\x01\x02\x20\
    \"\x12\x20nondeterministic\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xcf\
    \x01\x02\x08\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xcf\x01\x11\x14\n\r\n\
    \x05\x04\x19\x02\x02\x03\x12\x04\xcf\x01\x1e\x1f\n\x20\n\x04\x04\x19\x02\
    \x03\x12\x04\xd0\x01\x02\x20\"\x12\x20nondeterministic\n\n\r\n\x05\x04\
    \x19\x02\x03\x05\x12\x04\xd0\x01\x02\x08\n\r\n\x05\x04\x19\x02\x03\x01\
    \x12\x04\xd0\x01\x11\x15\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xd0\x01\
    \x1e\x1f\n\x0c\n\x04\x04\x19\x02\x04\x12\x04\xd1\x01\x02;\n\r\n\x05\x04\
    \x19\x02\x04\x05\x12\x04\xd1\x01\x02\x07\n\r\n\x05\x04\x19\x02\x04\x01\
    \x12\x04\xd1\x01\x11\x1b\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\xd1\x01\
    \x1e\x1f\n\r\n\x05\x04\x19\x02\x04\x08\x12\x04\xd1\x01\x20:\n\r\n\x05\
    \x04\x19\x02\x04\n\x12\x04\xd1\x01!9\n\r\n\x05\x04\x19\x02\x04\n\x12\x04\
    \xd1\x01-9\n\x0c\n\x04\x04\x19\x02\x05\x12\x04\xd2\x01\x029\n\r\n\x05\
    \x04\x19\x02\x05\x05\x12\x04\xd2\x01\x02\x07\n\r\n\x05\x04\x19\x02\x05\
    \x01\x12\x04\xd2\x01\x11\x19\n\r\n\x05\x04\x19\x02\x05\x03\x12\x04\xd2\
    \x01\x1e\x1f\n\r\n\x05\x04\x19\x02\x05\x08\x12\x04\xd2\x01\x208\n\r\n\
    \x05\x04\x19\x02\x05\n\x12\x04\xd2\x01!7\n\r\n\x05\x04\x19\x02\x05\n\x12\
    \x04\xd2\x01-7\n\x0e\n\x04\x04\x19\x02\x06\x12\x06\xd3\x01\x02\xd4\x01O\
    \n\r\n\x05\x04\x19\x02\x06\x04\x12\x04\xd3\x01\x02\n\n\r\n\x05\x04\x19\
    \x02\x06\x06\x12\x04\xd3\x01\x0b\x10\n\r\n\x05\x04\x19\x02\x06\x01\x12\
    \x04\xd3\x01\x11\x17\n\r\n\x05\x04\x19\x02\x06\x03\x12\x04\xd3\x01\x1e\
    \x1f\n\r\n\x05\x04\x19\x02\x06\x08\x12\x04\xd4\x01\x06N\n\x10\n\x08\x04\
    \x19\x02\x06\x08\xe9\xfb\x03\x12\x04\xd4\x01\x07#\n\x10\n\x08\x04\x19\
    \x02\x06\x08\xed\xfb\x03\x12\x04\xd4\x01%M\n\x0c\n\x04\x04\x19\x02\x07\
    \x12\x04\xd5\x01\x02\x17\n\r\n\x05\x04\x19\x02\x07\x05\x12\x04\xd5\x01\
    \x02\x08\n\r\n\x05\x04\x19\x02\x07\x01\x12\x04\xd5\x01\t\x12\n\r\n\x05\
    \x04\x19\x02\x07\x03\x12\x04\xd5\x01\x15\x16\n\x0c\n\x02\x04\x1a\x12\x06\
    \xd8\x01\0\xe2\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd8\x01\x08\x19\n\
    \x0c\n\x04\x04\x1a\x02\0\x12\x04\xd9\x01\x02\x20\n\r\n\x05\x04\x1a\x02\0\
    \x05\x12\x04\xd9\x01\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd9\x01\
    \x11\x15\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd9\x01\x1e\x1f\n\x0c\n\x04\
    \x04\x1a\x02\x01\x12\x04\xda\x01\x02\x20\n\r\n\x05\x04\x1a\x02\x01\x05\
    \x12\x04\xda\x01\x02\x07\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xda\x01\
    \x11\x15\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xda\x01\x1e\x1f\n\x20\n\
    \x04\x04\x1a\x02\x02\x12\x04\xdb\x01\x02\x20\"\x12\x20nondeterministic\n\
    \n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xdb\x01\x02\x08\n\r\n\x05\x04\x1a\
    \x02\x02\x01\x12\x04\xdb\x01\x11\x14\n\r\n\x05\x04\x1a\x02\x02\x03\x12\
    \x04\xdb\x01\x1e\x1f\n\x20\n\x04\x04\x1a\x02\x03\x12\x04\xdc\x01\x02\x20\
    \"\x12\x20nondeterministic\n\n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\xdc\
    \x01\x02\x08\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xdc\x01\x11\x15\n\r\n\
    \x05\x04\x1a\x02\x03\x03\x12\x04\xdc\x01\x1e\x1f\n\x0c\n\x04\x04\x1a\x02\
    \x04\x12\x04\xdd\x01\x02;\n\r\n\x05\x04\x1a\x02\x04\x05\x12\x04\xdd\x01\
    \x02\x07\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xdd\x01\x11\x1b\n\r\n\x05\
    \x04\x1a\x02\x04\x03\x12\x04\xdd\x01\x1e\x1f\n\r\n\x05\x04\x1a\x02\x04\
    \x08\x12\x04\xdd\x01\x20:\n\r\n\x05\x04\x1a\x02\x04\n\x12\x04\xdd\x01!9\
    \n\r\n\x05\x04\x1a\x02\x04\n\x12\x04\xdd\x01-9\n\x0c\n\x04\x04\x1a\x02\
    \x05\x12\x04\xde\x01\x029\n\r\n\x05\x04\x1a\x02\x05\x05\x12\x04\xde\x01\
    \x02\x07\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xde\x01\x11\x19\n\r\n\x05\
    \x04\x1a\x02\x05\x03\x12\x04\xde\x01\x1e\x1f\n\r\n\x05\x04\x1a\x02\x05\
    \x08\x12\x04\xde\x01\x208\n\r\n\x05\x04\x1a\x02\x05\n\x12\x04\xde\x01!7\
    \n\r\n\x05\x04\x1a\x02\x05\n\x12\x04\xde\x01-7\n\"\n\x04\x04\x1a\x02\x06\
    \x12\x06\xdf\x01\x02\xe0\x01O\"\x12\x20nondeterministic\n\n\r\n\x05\x04\
    \x1a\x02\x06\x04\x12\x04\xdf\x01\x02\n\n\r\n\x05\x04\x1a\x02\x06\x06\x12\
    \x04\xdf\x01\x0b\x10\n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\xdf\x01\x11\
    \x17\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xdf\x01\x1e\x1f\n\r\n\x05\x04\
    \x1a\x02\x06\x08\x12\x04\xe0\x01\x06N\n\x10\n\x08\x04\x1a\x02\x06\x08\
    \xe9\xfb\x03\x12\x04\xe0\x01\x07#\n\x10\n\x08\x04\x1a\x02\x06\x08\xed\
    \xfb\x03\x12\x04\xe0\x01%M\n\x0c\n\x04\x04\x1a\x02\x07\x12\x04\xe1\x01\
    \x02\x17\n\r\n\x05\x04\x1a\x02\x07\x05\x12\x04\xe1\x01\x02\x08\n\r\n\x05\
    \x04\x1a\x02\x07\x01\x12\x04\xe1\x01\t\x12\n\r\n\x05\x04\x1a\x02\x07\x03\
    \x12\x04\xe1\x01\x15\x16\n\x0c\n\x02\x04\x1b\x12\x06\xe4\x01\0\xea\x01\
    \x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xe4\x01\x08\x18\n\x0e\n\x04\x04\x1b\
    \x02\0\x12\x06\xe5\x01\x02\xe6\x01%\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\
    \xe5\x01\x02\n\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xe5\x01\x0b\x1a\n\r\n\
    \x05\x04\x1b\x02\0\x01\x12\x04\xe5\x01\x1b,\n\r\n\x05\x04\x1b\x02\0\x03\
    \x12\x04\xe5\x01/0\n\r\n\x05\x04\x1b\x02\0\x08\x12\x04\xe6\x01\x06$\n\
    \x10\n\x08\x04\x1b\x02\0\x08\xe9\xfb\x03\x12\x04\xe6\x01\x07#\n\x0c\n\
    \x04\x04\x1b\x02\x01\x12\x04\xe7\x01\x02.\n\r\n\x05\x04\x1b\x02\x01\x06\
    \x12\x04\xe7\x01\x02\x11\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xe7\x01\
    \x12)\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xe7\x01,-\n\x0e\n\x04\x04\
    \x1b\x02\x02\x12\x06\xe8\x01\x02\xe9\x01O\n\r\n\x05\x04\x1b\x02\x02\x04\
    \x12\x04\xe8\x01\x02\n\n\r\n\x05\x04\x1b\x02\x02\x06\x12\x04\xe8\x01\x0b\
    \x10\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xe8\x01\x12\x18\n\r\n\x05\x04\
    \x1b\x02\x02\x03\x12\x04\xe8\x01,-\n\r\n\x05\x04\x1b\x02\x02\x08\x12\x04\
    \xe9\x01\x06N\n\x10\n\x08\x04\x1b\x02\x02\x08\xe9\xfb\x03\x12\x04\xe9\
    \x01\x07#\n\x10\n\x08\x04\x1b\x02\x02\x08\xed\xfb\x03\x12\x04\xe9\x01%M\
    \n\x0c\n\x02\x04\x1c\x12\x06\xec\x01\0\xf0\x01\x01\n\x0b\n\x03\x04\x1c\
    \x01\x12\x04\xec\x01\x08\x16\n\x19\n\x04\x04\x1c\x02\0\x12\x04\xee\x01\
    \x02\x1a\x1a\x0b\x20reserve\x201\n\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\
    \xee\x01\x02\x07\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xee\x01\x08\x0c\n\r\
    \n\x05\x04\x1c\x02\0\x03\x12\x04\xee\x01\x18\x19\n\x0c\n\x04\x04\x1c\x02\
    \x01\x12\x04\xef\x01\x02\x1a\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xef\
    \x01\x02\x07\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xef\x01\x08\x15\n\r\n\
    \x05\x04\x1c\x02\x01\x03\x12\x04\xef\x01\x18\x19\n\x0c\n\x02\x04\x1d\x12\
    \x06\xf2\x01\0\xf4\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xf2\x01\x08\
    \x1d\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xf3\x01\x02\"\n\r\n\x05\x04\x1d\
    \x02\0\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xf3\
    \x01\x0b\x13\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xf3\x01\x14\x1d\n\r\n\
    \x05\x04\x1d\x02\0\x03\x12\x04\xf3\x01\x20!\n\x0c\n\x02\x04\x1e\x12\x06\
    \xf6\x01\0\x81\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xf6\x01\x08\x1d\n\
    \x0c\n\x04\x04\x1e\x02\0\x12\x04\xf7\x01\x02\x14\n\r\n\x05\x04\x1e\x02\0\
    \x06\x12\x04\xf7\x01\x02\x08\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xf7\x01\
    \t\x0f\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xf7\x01\x12\x13\n\x0e\n\x04\
    \x04\x1e\x04\0\x12\x06\xf9\x01\x02\x80\x02\x03\n\r\n\x05\x04\x1e\x04\0\
    \x01\x12\x04\xf9\x01\x07\r\n@\n\x06\x04\x1e\x04\0\x02\0\x12\x04\xfa\x01\
    \x04\x16\"0\x20Unknown\x20result,\x20abort\x20all\x20snapshot\x20restora\
    tion\n\n\x0f\n\x07\x04\x1e\x04\0\x02\0\x01\x12\x04\xfa\x01\x04\x0b\n\x0f\
    \n\x07\x04\x1e\x04\0\x02\0\x02\x12\x04\xfa\x01\x14\x15\n1\n\x06\x04\x1e\
    \x04\0\x02\x01\x12\x04\xfb\x01\x04\x16\"!\x20Snapshot\x20accepted,\x20ap\
    ply\x20chunks\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x01\x01\x12\x04\xfb\x01\
    \x04\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x01\x02\x12\x04\xfb\x01\x14\x15\n0\
    \n\x06\x04\x1e\x04\0\x02\x02\x12\x04\xfc\x01\x04\x16\"\x20\x20Abort\x20a\
    ll\x20snapshot\x20restoration\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x02\x01\
    \x12\x04\xfc\x01\x04\t\n\x0f\n\x07\x04\x1e\x04\0\x02\x02\x02\x12\x04\xfc\
    \x01\x14\x15\n;\n\x06\x04\x1e\x04\0\x02\x03\x12\x04\xfd\x01\x04\x16\"+\
    \x20Reject\x20this\x20specific\x20snapshot,\x20try\x20others\n\n\x0f\n\
    \x07\x04\x1e\x04\0\x02\x03\x01\x12\x04\xfd\x01\x04\n\n\x0f\n\x07\x04\x1e\
    \x04\0\x02\x03\x02\x12\x04\xfd\x01\x14\x15\nA\n\x06\x04\x1e\x04\0\x02\
    \x04\x12\x04\xfe\x01\x04\x16\"1\x20Reject\x20all\x20snapshots\x20of\x20t\
    his\x20format,\x20try\x20others\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\x01\
    \x12\x04\xfe\x01\x04\x11\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\x02\x12\x04\
    \xfe\x01\x14\x15\nE\n\x06\x04\x1e\x04\0\x02\x05\x12\x04\xff\x01\x04\x16\
    \"5\x20Reject\x20all\x20snapshots\x20from\x20the\x20sender(s),\x20try\
    \x20others\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x05\x01\x12\x04\xff\x01\x04\
    \x11\n\x0f\n\x07\x04\x1e\x04\0\x02\x05\x02\x12\x04\xff\x01\x14\x15\n\x0c\
    \n\x02\x04\x1f\x12\x06\x83\x02\0\x85\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\
    \x04\x83\x02\x08!\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x84\x02\x02\x12\n\r\
    \n\x05\x04\x1f\x02\0\x05\x12\x04\x84\x02\x02\x07\n\r\n\x05\x04\x1f\x02\0\
    \x01\x12\x04\x84\x02\x08\r\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x84\x02\
    \x10\x11\n\x0c\n\x02\x04\x20\x12\x06\x87\x02\0\x94\x02\x01\n\x0b\n\x03\
    \x04\x20\x01\x12\x04\x87\x02\x08\"\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x88\
    \x02\x02%\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\x88\x02\x02\x08\n\r\n\x05\
    \x04\x20\x02\0\x01\x12\x04\x88\x02\x12\x18\n\r\n\x05\x04\x20\x02\0\x03\
    \x12\x04\x88\x02#$\n-\n\x04\x04\x20\x02\x01\x12\x04\x89\x02\x02%\"\x1f\
    \x20Chunks\x20to\x20refetch\x20and\x20reapply\n\n\r\n\x05\x04\x20\x02\
    \x01\x04\x12\x04\x89\x02\x02\n\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x89\
    \x02\x0b\x11\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x89\x02\x12\x20\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\x89\x02#$\n/\n\x04\x04\x20\x02\x02\x12\
    \x04\x8a\x02\x02%\"!\x20Chunk\x20senders\x20to\x20reject\x20and\x20ban\n\
    \n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\x8a\x02\x02\n\n\r\n\x05\x04\x20\
    \x02\x02\x05\x12\x04\x8a\x02\x0b\x11\n\r\n\x05\x04\x20\x02\x02\x01\x12\
    \x04\x8a\x02\x12\x20\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x8a\x02#$\n\
    \x0e\n\x04\x04\x20\x04\0\x12\x06\x8c\x02\x02\x93\x02\x03\n\r\n\x05\x04\
    \x20\x04\0\x01\x12\x04\x8c\x02\x07\r\n@\n\x06\x04\x20\x04\0\x02\0\x12\
    \x04\x8d\x02\x04\x18\"0\x20Unknown\x20result,\x20abort\x20all\x20snapsho\
    t\x20restoration\n\n\x0f\n\x07\x04\x20\x04\0\x02\0\x01\x12\x04\x8d\x02\
    \x04\x0b\n\x0f\n\x07\x04\x20\x04\0\x02\0\x02\x12\x04\x8d\x02\x16\x17\n-\
    \n\x06\x04\x20\x04\0\x02\x01\x12\x04\x8e\x02\x04\x18\"\x1d\x20Chunk\x20s\
    uccessfully\x20accepted\n\n\x0f\n\x07\x04\x20\x04\0\x02\x01\x01\x12\x04\
    \x8e\x02\x04\n\n\x0f\n\x07\x04\x20\x04\0\x02\x01\x02\x12\x04\x8e\x02\x16\
    \x17\n0\n\x06\x04\x20\x04\0\x02\x02\x12\x04\x8f\x02\x04\x18\"\x20\x20Abo\
    rt\x20all\x20snapshot\x20restoration\n\n\x0f\n\x07\x04\x20\x04\0\x02\x02\
    \x01\x12\x04\x8f\x02\x04\t\n\x0f\n\x07\x04\x20\x04\0\x02\x02\x02\x12\x04\
    \x8f\x02\x16\x17\n?\n\x06\x04\x20\x04\0\x02\x03\x12\x04\x90\x02\x04\x18\
    \"/\x20Retry\x20chunk\x20(combine\x20with\x20refetch\x20and\x20reject)\n\
    \n\x0f\n\x07\x04\x20\x04\0\x02\x03\x01\x12\x04\x90\x02\x04\t\n\x0f\n\x07\
    \x04\x20\x04\0\x02\x03\x02\x12\x04\x90\x02\x16\x17\nB\n\x06\x04\x20\x04\
    \0\x02\x04\x12\x04\x91\x02\x04\x18\"2\x20Retry\x20snapshot\x20(combine\
    \x20with\x20refetch\x20and\x20reject)\n\n\x0f\n\x07\x04\x20\x04\0\x02\
    \x04\x01\x12\x04\x91\x02\x04\x12\n\x0f\n\x07\x04\x20\x04\0\x02\x04\x02\
    \x12\x04\x91\x02\x16\x17\n2\n\x06\x04\x20\x04\0\x02\x05\x12\x04\x92\x02\
    \x04\x18\"\"\x20Reject\x20this\x20snapshot,\x20try\x20others\n\n\x0f\n\
    \x07\x04\x20\x04\0\x02\x05\x01\x12\x04\x92\x02\x04\x13\n\x0f\n\x07\x04\
    \x20\x04\0\x02\x05\x02\x12\x04\x92\x02\x16\x17\n\xa2\x01\n\x02\x04!\x12\
    \x06\x9b\x02\0\xa0\x02\x01\x1ab\x20ConsensusParams\x20contains\x20all\
    \x20consensus-relevant\x20parameters\n\x20that\x20can\x20be\x20adjusted\
    \x20by\x20the\x20abci\x20app\n20----------------------------------------\
    \n\x20Misc.\n\n\x0b\n\x03\x04!\x01\x12\x04\x9b\x02\x08\x17\n\x0c\n\x04\
    \x04!\x02\0\x12\x04\x9c\x02\x021\n\r\n\x05\x04!\x02\0\x06\x12\x04\x9c\
    \x02\x02\r\n\r\n\x05\x04!\x02\0\x01\x12\x04\x9c\x02#(\n\r\n\x05\x04!\x02\
    \0\x03\x12\x04\x9c\x02/0\n\x0c\n\x04\x04!\x02\x01\x12\x04\x9d\x02\x021\n\
    \r\n\x05\x04!\x02\x01\x06\x12\x04\x9d\x02\x02!\n\r\n\x05\x04!\x02\x01\
    \x01\x12\x04\x9d\x02#+\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x9d\x02/0\n\
    \x0c\n\x04\x04!\x02\x02\x12\x04\x9e\x02\x021\n\r\n\x05\x04!\x02\x02\x06\
    \x12\x04\x9e\x02\x02\"\n\r\n\x05\x04!\x02\x02\x01\x12\x04\x9e\x02#,\n\r\
    \n\x05\x04!\x02\x02\x03\x12\x04\x9e\x02/0\n\x0c\n\x04\x04!\x02\x03\x12\
    \x04\x9f\x02\x021\n\r\n\x05\x04!\x02\x03\x06\x12\x04\x9f\x02\x02\x20\n\r\
    \n\x05\x04!\x02\x03\x01\x12\x04\x9f\x02#*\n\r\n\x05\x04!\x02\x03\x03\x12\
    \x04\x9f\x02/0\n>\n\x02\x04\"\x12\x06\xa3\x02\0\xa8\x02\x01\x1a0\x20Bloc\
    kParams\x20contains\x20limits\x20on\x20the\x20block\x20size.\n\n\x0b\n\
    \x03\x04\"\x01\x12\x04\xa3\x02\x08\x13\n,\n\x04\x04\"\x02\0\x12\x04\xa5\
    \x02\x02\x16\x1a\x1e\x20Note:\x20must\x20be\x20greater\x20than\x200\n\n\
    \r\n\x05\x04\"\x02\0\x05\x12\x04\xa5\x02\x02\x07\n\r\n\x05\x04\"\x02\0\
    \x01\x12\x04\xa5\x02\x08\x11\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xa5\x02\
    \x14\x15\n4\n\x04\x04\"\x02\x01\x12\x04\xa7\x02\x02\x14\x1a&\x20Note:\
    \x20must\x20be\x20greater\x20or\x20equal\x20to\x20-1\n\n\r\n\x05\x04\"\
    \x02\x01\x05\x12\x04\xa7\x02\x02\x07\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\
    \xa7\x02\x08\x0f\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xa7\x02\x12\x13\n\
    \x0c\n\x02\x04#\x12\x06\xaa\x02\0\xad\x02\x01\n\x0b\n\x03\x04#\x01\x12\
    \x04\xaa\x02\x08\x16\n\x0c\n\x04\x04#\x02\0\x12\x04\xab\x02\x02\x1e\n\r\
    \n\x05\x04#\x02\0\x05\x12\x04\xab\x02\x02\x07\n\r\n\x05\x04#\x02\0\x01\
    \x12\x04\xab\x02\x14\x19\n\r\n\x05\x04#\x02\0\x03\x12\x04\xab\x02\x1c\
    \x1d\n\x0c\n\x04\x04#\x02\x01\x12\x04\xac\x02\x02=\n\r\n\x05\x04#\x02\
    \x01\x04\x12\x04\xac\x02\x02\n\n\r\n\x05\x04#\x02\x01\x06\x12\x04\xac\
    \x02\x0b\x13\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xac\x02\x14\x19\n\r\n\
    \x05\x04#\x02\x01\x03\x12\x04\xac\x02\x1c\x1d\n\r\n\x05\x04#\x02\x01\x08\
    \x12\x04\xac\x02\x1e<\n\x10\n\x08\x04#\x02\x01\x08\xe9\xfb\x03\x12\x04\
    \xac\x02\x1f;\n\xde\x01\n\x02\x04$\x12\x06\xb2\x02\0\xb8\x02\x01\x1a\xcf\
    \x01\x20Event\x20allows\x20application\x20developers\x20to\x20attach\x20\
    additional\x20information\x20to\n\x20ResponseBeginBlock,\x20ResponseEndB\
    lock,\x20ResponseCheckTx\x20and\x20ResponseDeliverTx.\n\x20Later,\x20tra\
    nsactions\x20may\x20be\x20queried\x20using\x20these\x20events.\n\n\x0b\n\
    \x03\x04$\x01\x12\x04\xb2\x02\x08\r\n\x0c\n\x04\x04$\x02\0\x12\x04\xb3\
    \x02\x02)\n\r\n\x05\x04$\x02\0\x05\x12\x04\xb3\x02\x02\x08\n\r\n\x05\x04\
    $\x02\0\x01\x12\x04\xb3\x02\x1a\x1e\n\r\n\x05\x04$\x02\0\x03\x12\x04\xb3\
    \x02'(\n\x0e\n\x04\x04$\x02\x01\x12\x06\xb4\x02\x02\xb7\x02\x04\n\r\n\
    \x05\x04$\x02\x01\x04\x12\x04\xb4\x02\x02\n\n\r\n\x05\x04$\x02\x01\x06\
    \x12\x04\xb4\x02\x0b\x19\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xb4\x02\x1a$\
    \n\r\n\x05\x04$\x02\x01\x03\x12\x04\xb4\x02'(\n\x0f\n\x05\x04$\x02\x01\
    \x08\x12\x06\xb4\x02)\xb7\x02\x03\n\x10\n\x08\x04$\x02\x01\x08\xe9\xfb\
    \x03\x12\x04\xb5\x02\x04\x20\n\x10\n\x08\x04$\x02\x01\x08\xed\xfb\x03\
    \x12\x04\xb6\x02\x041\nT\n\x02\x04%\x12\x06\xbb\x02\0\xbf\x02\x01\x1aF\
    \x20EventAttribute\x20is\x20a\x20single\x20key-value\x20pair,\x20associa\
    ted\x20with\x20an\x20event.\n\n\x0b\n\x03\x04%\x01\x12\x04\xbb\x02\x08\
    \x16\n\x0c\n\x04\x04%\x02\0\x12\x04\xbc\x02\x02\x12\n\r\n\x05\x04%\x02\0\
    \x05\x12\x04\xbc\x02\x02\x07\n\r\n\x05\x04%\x02\0\x01\x12\x04\xbc\x02\
    \x08\x0b\n\r\n\x05\x04%\x02\0\x03\x12\x04\xbc\x02\x10\x11\n\x0c\n\x04\
    \x04%\x02\x01\x12\x04\xbd\x02\x02\x12\n\r\n\x05\x04%\x02\x01\x05\x12\x04\
    \xbd\x02\x02\x07\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xbd\x02\x08\r\n\r\n\
    \x05\x04%\x02\x01\x03\x12\x04\xbd\x02\x10\x11\n\x20\n\x04\x04%\x02\x02\
    \x12\x04\xbe\x02\x02\x12\"\x12\x20nondeterministic\n\n\r\n\x05\x04%\x02\
    \x02\x05\x12\x04\xbe\x02\x02\x06\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xbe\
    \x02\x08\r\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xbe\x02\x10\x11\nt\n\x02\
    \x04&\x12\x06\xc4\x02\0\xc9\x02\x01\x1af\x20TxResult\x20contains\x20resu\
    lts\x20of\x20executing\x20the\x20transaction.\n\n\x20One\x20usage\x20is\
    \x20indexing\x20transaction\x20results.\n\n\x0b\n\x03\x04&\x01\x12\x04\
    \xc4\x02\x08\x10\n\x0c\n\x04\x04&\x02\0\x12\x04\xc5\x02\x02\x1f\n\r\n\
    \x05\x04&\x02\0\x05\x12\x04\xc5\x02\x02\x07\n\r\n\x05\x04&\x02\0\x01\x12\
    \x04\xc5\x02\x14\x1a\n\r\n\x05\x04&\x02\0\x03\x12\x04\xc5\x02\x1d\x1e\n\
    \x0c\n\x04\x04&\x02\x01\x12\x04\xc6\x02\x02\x1f\n\r\n\x05\x04&\x02\x01\
    \x05\x12\x04\xc6\x02\x02\x08\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xc6\x02\
    \x14\x19\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xc6\x02\x1d\x1e\n\x0c\n\x04\
    \x04&\x02\x02\x12\x04\xc7\x02\x02\x1f\n\r\n\x05\x04&\x02\x02\x05\x12\x04\
    \xc7\x02\x02\x07\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xc7\x02\x14\x16\n\r\
    \n\x05\x04&\x02\x02\x03\x12\x04\xc7\x02\x1d\x1e\n\x0c\n\x04\x04&\x02\x03\
    \x12\x04\xc8\x02\x02>\n\r\n\x05\x04&\x02\x03\x06\x12\x04\xc8\x02\x02\x13\
    \n\r\n\x05\x04&\x02\x03\x01\x12\x04\xc8\x02\x14\x1a\n\r\n\x05\x04&\x02\
    \x03\x03\x12\x04\xc8\x02\x1d\x1e\n\r\n\x05\x04&\x02\x03\x08\x12\x04\xc8\
    \x02\x1f=\n\x10\n\x08\x04&\x02\x03\x08\xe9\xfb\x03\x12\x04\xc8\x02\x20<\
    \nV\n\x02\x04'\x12\x06\xcf\x02\0\xd3\x02\x01\x1a\x0b\x20Validator\n2;---\
    -------------------------------------\n\x20Blockchain\x20Types\n\n\x0b\n\
    \x03\x04'\x01\x12\x04\xcf\x02\x08\x11\n8\n\x04\x04'\x02\0\x12\x04\xd0\
    \x02\x02\x14\"*\x20The\x20first\x2020\x20bytes\x20of\x20SHA256(public\
    \x20key)\n\n\r\n\x05\x04'\x02\0\x05\x12\x04\xd0\x02\x02\x07\n\r\n\x05\
    \x04'\x02\0\x01\x12\x04\xd0\x02\x08\x0f\n\r\n\x05\x04'\x02\0\x03\x12\x04\
    \xd0\x02\x12\x13\nT\n\x04\x04'\x02\x01\x12\x04\xd2\x02\x02\x12\x1a2\x20P\
    ubKey\x20pub_key\x20=\x202\x20[(gogoproto.nullable)=false];\n\"\x12\x20T\
    he\x20voting\x20power\n\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xd2\x02\x02\
    \x07\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xd2\x02\x08\r\n\r\n\x05\x04'\x02\
    \x01\x03\x12\x04\xd2\x02\x10\x11\n\x1f\n\x02\x04(\x12\x06\xd6\x02\0\xd9\
    \x02\x01\x1a\x11\x20ValidatorUpdate\n\n\x0b\n\x03\x04(\x01\x12\x04\xd6\
    \x02\x08\x17\n\x0c\n\x04\x04(\x02\0\x12\x04\xd7\x02\x02I\n\r\n\x05\x04(\
    \x02\0\x06\x12\x04\xd7\x02\x02\x1d\n\r\n\x05\x04(\x02\0\x01\x12\x04\xd7\
    \x02\x1e%\n\r\n\x05\x04(\x02\0\x03\x12\x04\xd7\x02()\n\r\n\x05\x04(\x02\
    \0\x08\x12\x04\xd7\x02*H\n\x10\n\x08\x04(\x02\0\x08\xe9\xfb\x03\x12\x04\
    \xd7\x02+G\n\x0c\n\x04\x04(\x02\x01\x12\x04\xd8\x02\x02*\n\r\n\x05\x04(\
    \x02\x01\x05\x12\x04\xd8\x02\x02\x07\n\r\n\x05\x04(\x02\x01\x01\x12\x04\
    \xd8\x02\x1e#\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xd8\x02()\n\x18\n\x02\
    \x04)\x12\x06\xdc\x02\0\xdf\x02\x01\x1a\n\x20VoteInfo\n\n\x0b\n\x03\x04)\
    \x01\x12\x04\xdc\x02\x08\x10\n\x0c\n\x04\x04)\x02\0\x12\x04\xdd\x02\x02A\
    \n\r\n\x05\x04)\x02\0\x06\x12\x04\xdd\x02\x02\x0b\n\r\n\x05\x04)\x02\0\
    \x01\x12\x04\xdd\x02\x0c\x15\n\r\n\x05\x04)\x02\0\x03\x12\x04\xdd\x02\
    \x20!\n\r\n\x05\x04)\x02\0\x08\x12\x04\xdd\x02\"@\n\x10\n\x08\x04)\x02\0\
    \x08\xe9\xfb\x03\x12\x04\xdd\x02#?\n\x0c\n\x04\x04)\x02\x01\x12\x04\xde\
    \x02\x02\"\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xde\x02\x02\x06\n\r\n\x05\
    \x04)\x02\x01\x01\x12\x04\xde\x02\x0c\x1d\n\r\n\x05\x04)\x02\x01\x03\x12\
    \x04\xde\x02\x20!\n\x0c\n\x02\x05\x01\x12\x06\xe1\x02\0\xe5\x02\x01\n\
    \x0b\n\x03\x05\x01\x01\x12\x04\xe1\x02\x05\x11\n\x0c\n\x04\x05\x01\x02\0\
    \x12\x04\xe2\x02\x02\x1a\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xe2\x02\x02\
    \t\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xe2\x02\x18\x19\n\x0c\n\x04\x05\
    \x01\x02\x01\x12\x04\xe3\x02\x02\x1a\n\r\n\x05\x05\x01\x02\x01\x01\x12\
    \x04\xe3\x02\x02\x10\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xe3\x02\x18\
    \x19\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\xe4\x02\x02\x1a\n\r\n\x05\x05\
    \x01\x02\x02\x01\x12\x04\xe4\x02\x02\x15\n\r\n\x05\x05\x01\x02\x02\x02\
    \x12\x04\xe4\x02\x18\x19\n\x0c\n\x02\x04*\x12\x06\xe7\x02\0\xf6\x02\x01\
    \n\x0b\n\x03\x04*\x01\x12\x04\xe7\x02\x08\x10\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\xe8\x02\x02\x18\n\r\n\x05\x04*\x02\0\x06\x12\x04\xe8\x02\x02\x0e\n\
    \r\n\x05\x04*\x02\0\x01\x12\x04\xe8\x02\x0f\x13\n\r\n\x05\x04*\x02\0\x03\
    \x12\x04\xe8\x02\x16\x17\n'\n\x04\x04*\x02\x01\x12\x04\xea\x02\x029\x1a\
    \x19\x20The\x20offending\x20validator\n\n\r\n\x05\x04*\x02\x01\x06\x12\
    \x04\xea\x02\x02\x0b\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xea\x02\x0c\x15\
    \n\r\n\x05\x04*\x02\x01\x03\x12\x04\xea\x02\x18\x19\n\r\n\x05\x04*\x02\
    \x01\x08\x12\x04\xea\x02\x1a8\n\x10\n\x08\x04*\x02\x01\x08\xe9\xfb\x03\
    \x12\x04\xea\x02\x1b7\n4\n\x04\x04*\x02\x02\x12\x04\xec\x02\x02\x13\x1a&\
    \x20The\x20height\x20when\x20the\x20offense\x20occurred\n\n\r\n\x05\x04*\
    \x02\x02\x05\x12\x04\xec\x02\x02\x07\n\r\n\x05\x04*\x02\x02\x01\x12\x04\
    \xec\x02\x08\x0e\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xec\x02\x11\x12\nC\n\
    \x04\x04*\x02\x03\x12\x06\xee\x02\x02\xf1\x02\x04\x1a3\x20The\x20corresp\
    onding\x20time\x20where\x20the\x20offense\x20occurred\n\n\r\n\x05\x04*\
    \x02\x03\x06\x12\x04\xee\x02\x02\x1b\n\r\n\x05\x04*\x02\x03\x01\x12\x04\
    \xee\x02\x1c\x20\n\r\n\x05\x04*\x02\x03\x03\x12\x04\xee\x02#$\n\x0f\n\
    \x05\x04*\x02\x03\x08\x12\x06\xee\x02%\xf1\x02\x03\n\x10\n\x08\x04*\x02\
    \x03\x08\xe9\xfb\x03\x12\x04\xef\x02\x04\x20\n\x10\n\x08\x04*\x02\x03\
    \x08\xf2\xfb\x03\x12\x04\xf0\x02\x04\x1f\n\xb2\x01\n\x04\x04*\x02\x04\
    \x12\x04\xf5\x02\x02\x1f\x1a\xa3\x01\x20Total\x20voting\x20power\x20of\
    \x20the\x20validator\x20set\x20in\x20case\x20the\x20ABCI\x20application\
    \x20does\n\x20not\x20store\x20historical\x20validators.\n\x20https://git\
    hub.com/tendermint/tendermint/issues/4581\n\n\r\n\x05\x04*\x02\x04\x05\
    \x12\x04\xf5\x02\x02\x07\n\r\n\x05\x04*\x02\x04\x01\x12\x04\xf5\x02\x08\
    \x1a\n\r\n\x05\x04*\x02\x04\x03\x12\x04\xf5\x02\x1d\x1e\nI\n\x02\x04+\
    \x12\x06\xfb\x02\0\x81\x03\x012;----------------------------------------\
    \n\x20State\x20Sync\x20Types\n\n\x0b\n\x03\x04+\x01\x12\x04\xfb\x02\x08\
    \x10\n:\n\x04\x04+\x02\0\x12\x04\xfc\x02\x02\x16\",\x20The\x20height\x20\
    at\x20which\x20the\x20snapshot\x20was\x20taken\n\n\r\n\x05\x04+\x02\0\
    \x05\x12\x04\xfc\x02\x02\x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\xfc\x02\t\
    \x0f\n\r\n\x05\x04+\x02\0\x03\x12\x04\xfc\x02\x14\x15\n8\n\x04\x04+\x02\
    \x01\x12\x04\xfd\x02\x02\x16\"*\x20The\x20application-specific\x20snapsh\
    ot\x20format\n\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xfd\x02\x02\x08\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\xfd\x02\t\x0f\n\r\n\x05\x04+\x02\x01\x03\
    \x12\x04\xfd\x02\x14\x15\n0\n\x04\x04+\x02\x02\x12\x04\xfe\x02\x02\x16\"\
    \"\x20Number\x20of\x20chunks\x20in\x20the\x20snapshot\n\n\r\n\x05\x04+\
    \x02\x02\x05\x12\x04\xfe\x02\x02\x08\n\r\n\x05\x04+\x02\x02\x01\x12\x04\
    \xfe\x02\t\x0f\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xfe\x02\x14\x15\n@\n\
    \x04\x04+\x02\x03\x12\x04\xff\x02\x02\x16\"2\x20Arbitrary\x20snapshot\
    \x20hash,\x20equal\x20only\x20if\x20identical\n\n\r\n\x05\x04+\x02\x03\
    \x05\x12\x04\xff\x02\x02\x07\n\r\n\x05\x04+\x02\x03\x01\x12\x04\xff\x02\
    \t\r\n\r\n\x05\x04+\x02\x03\x03\x12\x04\xff\x02\x14\x15\n.\n\x04\x04+\
    \x02\x04\x12\x04\x80\x03\x02\x16\"\x20\x20Arbitrary\x20application\x20me\
    tadata\n\n\r\n\x05\x04+\x02\x04\x05\x12\x04\x80\x03\x02\x07\n\r\n\x05\
    \x04+\x02\x04\x01\x12\x04\x80\x03\t\x11\n\r\n\x05\x04+\x02\x04\x03\x12\
    \x04\x80\x03\x14\x15\nK\n\x02\x06\0\x12\x06\x86\x03\0\x96\x03\x012=-----\
    -----------------------------------\n\x20Service\x20Definition\n\n\x0b\n\
    \x03\x06\0\x01\x12\x04\x86\x03\x08\x17\n\x0c\n\x04\x06\0\x02\0\x12\x04\
    \x87\x03\x02/\n\r\n\x05\x06\0\x02\0\x01\x12\x04\x87\x03\x06\n\n\r\n\x05\
    \x06\0\x02\0\x02\x12\x04\x87\x03\x0b\x16\n\r\n\x05\x06\0\x02\0\x03\x12\
    \x04\x87\x03!-\n\x0c\n\x04\x06\0\x02\x01\x12\x04\x88\x03\x022\n\r\n\x05\
    \x06\0\x02\x01\x01\x12\x04\x88\x03\x06\x0b\n\r\n\x05\x06\0\x02\x01\x02\
    \x12\x04\x88\x03\x0c\x18\n\r\n\x05\x06\0\x02\x01\x03\x12\x04\x88\x03#0\n\
    \x0c\n\x04\x06\0\x02\x02\x12\x04\x89\x03\x02/\n\r\n\x05\x06\0\x02\x02\
    \x01\x12\x04\x89\x03\x06\n\n\r\n\x05\x06\0\x02\x02\x02\x12\x04\x89\x03\
    \x0b\x16\n\r\n\x05\x06\0\x02\x02\x03\x12\x04\x89\x03!-\n\x0c\n\x04\x06\0\
    \x02\x03\x12\x04\x8a\x03\x02>\n\r\n\x05\x06\0\x02\x03\x01\x12\x04\x8a\
    \x03\x06\x0f\n\r\n\x05\x06\0\x02\x03\x02\x12\x04\x8a\x03\x10\x20\n\r\n\
    \x05\x06\0\x02\x03\x03\x12\x04\x8a\x03+<\n\x0c\n\x04\x06\0\x02\x04\x12\
    \x04\x8b\x03\x02>\n\r\n\x05\x06\0\x02\x04\x01\x12\x04\x8b\x03\x06\x0f\n\
    \r\n\x05\x06\0\x02\x04\x02\x12\x04\x8b\x03\x10\x20\n\r\n\x05\x06\0\x02\
    \x04\x03\x12\x04\x8b\x03+<\n\x0c\n\x04\x06\0\x02\x05\x12\x04\x8c\x03\x02\
    8\n\r\n\x05\x06\0\x02\x05\x01\x12\x04\x8c\x03\x06\r\n\r\n\x05\x06\0\x02\
    \x05\x02\x12\x04\x8c\x03\x0e\x1c\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\x8c\
    \x03'6\n\x0c\n\x04\x06\0\x02\x06\x12\x04\x8d\x03\x022\n\r\n\x05\x06\0\
    \x02\x06\x01\x12\x04\x8d\x03\x06\x0b\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\
    \x8d\x03\x0c\x18\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\x8d\x03#0\n\x0c\n\
    \x04\x06\0\x02\x07\x12\x04\x8e\x03\x025\n\r\n\x05\x06\0\x02\x07\x01\x12\
    \x04\x8e\x03\x06\x0c\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\x8e\x03\r\x1a\n\
    \r\n\x05\x06\0\x02\x07\x03\x12\x04\x8e\x03%3\n\x0c\n\x04\x06\0\x02\x08\
    \x12\x04\x8f\x03\x02>\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\x8f\x03\x06\
    \x0f\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\x8f\x03\x10\x20\n\r\n\x05\x06\0\
    \x02\x08\x03\x12\x04\x8f\x03+<\n\x0c\n\x04\x06\0\x02\t\x12\x04\x90\x03\
    \x02A\n\r\n\x05\x06\0\x02\t\x01\x12\x04\x90\x03\x06\x10\n\r\n\x05\x06\0\
    \x02\t\x02\x12\x04\x90\x03\x11\"\n\r\n\x05\x06\0\x02\t\x03\x12\x04\x90\
    \x03-?\n\x0c\n\x04\x06\0\x02\n\x12\x04\x91\x03\x02;\n\r\n\x05\x06\0\x02\
    \n\x01\x12\x04\x91\x03\x06\x0e\n\r\n\x05\x06\0\x02\n\x02\x12\x04\x91\x03\
    \x0f\x1e\n\r\n\x05\x06\0\x02\n\x03\x12\x04\x91\x03)9\n\x0c\n\x04\x06\0\
    \x02\x0b\x12\x04\x92\x03\x02J\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\x92\
    \x03\x06\x13\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\x92\x03\x14(\n\r\n\x05\
    \x06\0\x02\x0b\x03\x12\x04\x92\x033H\n\x0c\n\x04\x06\0\x02\x0c\x12\x04\
    \x93\x03\x02J\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\x93\x03\x06\x13\n\r\n\
    \x05\x06\0\x02\x0c\x02\x12\x04\x93\x03\x14(\n\r\n\x05\x06\0\x02\x0c\x03\
    \x12\x04\x93\x033H\n\x0c\n\x04\x06\0\x02\r\x12\x04\x94\x03\x02V\n\r\n\
    \x05\x06\0\x02\r\x01\x12\x04\x94\x03\x06\x17\n\r\n\x05\x06\0\x02\r\x02\
    \x12\x04\x94\x03\x180\n\r\n\x05\x06\0\x02\r\x03\x12\x04\x94\x03;T\n\x0c\
    \n\x04\x06\0\x02\x0e\x12\x04\x95\x03\x02Y\n\r\n\x05\x06\0\x02\x0e\x01\
    \x12\x04\x95\x03\x06\x18\n\r\n\x05\x06\0\x02\x0e\x02\x12\x04\x95\x03\x19\
    2\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\x95\x03=Wb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::proof::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(super::keys::file_descriptor().clone());
            deps.push(super::params::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(44);
            messages.push(Request::generated_message_descriptor_data());
            messages.push(RequestEcho::generated_message_descriptor_data());
            messages.push(RequestFlush::generated_message_descriptor_data());
            messages.push(RequestInfo::generated_message_descriptor_data());
            messages.push(RequestSetOption::generated_message_descriptor_data());
            messages.push(RequestInitChain::generated_message_descriptor_data());
            messages.push(RequestQuery::generated_message_descriptor_data());
            messages.push(RequestBeginBlock::generated_message_descriptor_data());
            messages.push(RequestCheckTx::generated_message_descriptor_data());
            messages.push(RequestDeliverTx::generated_message_descriptor_data());
            messages.push(RequestEndBlock::generated_message_descriptor_data());
            messages.push(RequestCommit::generated_message_descriptor_data());
            messages.push(RequestListSnapshots::generated_message_descriptor_data());
            messages.push(RequestOfferSnapshot::generated_message_descriptor_data());
            messages.push(RequestLoadSnapshotChunk::generated_message_descriptor_data());
            messages.push(RequestApplySnapshotChunk::generated_message_descriptor_data());
            messages.push(Response::generated_message_descriptor_data());
            messages.push(ResponseException::generated_message_descriptor_data());
            messages.push(ResponseEcho::generated_message_descriptor_data());
            messages.push(ResponseFlush::generated_message_descriptor_data());
            messages.push(ResponseInfo::generated_message_descriptor_data());
            messages.push(ResponseSetOption::generated_message_descriptor_data());
            messages.push(ResponseInitChain::generated_message_descriptor_data());
            messages.push(ResponseQuery::generated_message_descriptor_data());
            messages.push(ResponseBeginBlock::generated_message_descriptor_data());
            messages.push(ResponseCheckTx::generated_message_descriptor_data());
            messages.push(ResponseDeliverTx::generated_message_descriptor_data());
            messages.push(ResponseEndBlock::generated_message_descriptor_data());
            messages.push(ResponseCommit::generated_message_descriptor_data());
            messages.push(ResponseListSnapshots::generated_message_descriptor_data());
            messages.push(ResponseOfferSnapshot::generated_message_descriptor_data());
            messages.push(ResponseLoadSnapshotChunk::generated_message_descriptor_data());
            messages.push(ResponseApplySnapshotChunk::generated_message_descriptor_data());
            messages.push(ConsensusParams::generated_message_descriptor_data());
            messages.push(BlockParams::generated_message_descriptor_data());
            messages.push(LastCommitInfo::generated_message_descriptor_data());
            messages.push(Event::generated_message_descriptor_data());
            messages.push(EventAttribute::generated_message_descriptor_data());
            messages.push(TxResult::generated_message_descriptor_data());
            messages.push(Validator::generated_message_descriptor_data());
            messages.push(ValidatorUpdate::generated_message_descriptor_data());
            messages.push(VoteInfo::generated_message_descriptor_data());
            messages.push(Evidence::generated_message_descriptor_data());
            messages.push(Snapshot::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(CheckTxType::generated_enum_descriptor_data());
            enums.push(EvidenceType::generated_enum_descriptor_data());
            enums.push(response_offer_snapshot::Result::generated_enum_descriptor_data());
            enums.push(response_apply_snapshot_chunk::Result::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
