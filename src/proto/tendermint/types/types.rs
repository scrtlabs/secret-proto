// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tendermint/types/types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  PartsetHeader
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.PartSetHeader)
pub struct PartSetHeader {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.PartSetHeader.total)
    pub total: u32,
    // @@protoc_insertion_point(field:tendermint.types.PartSetHeader.hash)
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.PartSetHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartSetHeader {
    fn default() -> &'a PartSetHeader {
        <PartSetHeader as ::protobuf::Message>::default_instance()
    }
}

impl PartSetHeader {
    pub fn new() -> PartSetHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &PartSetHeader| { &m.total },
            |m: &mut PartSetHeader| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &PartSetHeader| { &m.hash },
            |m: &mut PartSetHeader| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartSetHeader>(
            "PartSetHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartSetHeader {
    const NAME: &'static str = "PartSetHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.total = is.read_uint32()?;
                },
                18 => {
                    self.hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.total);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.total != 0 {
            os.write_uint32(1, self.total)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartSetHeader {
        PartSetHeader::new()
    }

    fn clear(&mut self) {
        self.total = 0;
        self.hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartSetHeader {
        static instance: PartSetHeader = PartSetHeader {
            total: 0,
            hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartSetHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartSetHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartSetHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartSetHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.Part)
pub struct Part {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.Part.index)
    pub index: u32,
    // @@protoc_insertion_point(field:tendermint.types.Part.bytes)
    pub bytes: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Part.proof)
    pub proof: ::protobuf::MessageField<super::proof::Proof>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.Part.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Part {
    fn default() -> &'a Part {
        <Part as ::protobuf::Message>::default_instance()
    }
}

impl Part {
    pub fn new() -> Part {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &Part| { &m.index },
            |m: &mut Part| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bytes",
            |m: &Part| { &m.bytes },
            |m: &mut Part| { &mut m.bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::proof::Proof>(
            "proof",
            |m: &Part| { &m.proof },
            |m: &mut Part| { &mut m.proof },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Part>(
            "Part",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Part {
    const NAME: &'static str = "Part";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = is.read_uint32()?;
                },
                18 => {
                    self.bytes = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.index);
        }
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.bytes);
        }
        if let Some(v) = self.proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if !self.bytes.is_empty() {
            os.write_bytes(2, &self.bytes)?;
        }
        if let Some(v) = self.proof.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Part {
        Part::new()
    }

    fn clear(&mut self) {
        self.index = 0;
        self.bytes.clear();
        self.proof.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Part {
        static instance: Part = Part {
            index: 0,
            bytes: ::std::vec::Vec::new(),
            proof: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Part {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Part").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Part {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Part {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BlockID
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.BlockID)
pub struct BlockID {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.BlockID.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.BlockID.part_set_header)
    pub part_set_header: ::protobuf::MessageField<PartSetHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.BlockID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockID {
    fn default() -> &'a BlockID {
        <BlockID as ::protobuf::Message>::default_instance()
    }
}

impl BlockID {
    pub fn new() -> BlockID {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &BlockID| { &m.hash },
            |m: &mut BlockID| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PartSetHeader>(
            "part_set_header",
            |m: &BlockID| { &m.part_set_header },
            |m: &mut BlockID| { &mut m.part_set_header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockID>(
            "BlockID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockID {
    const NAME: &'static str = "BlockID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.part_set_header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if let Some(v) = self.part_set_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if let Some(v) = self.part_set_header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockID {
        BlockID::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.part_set_header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockID {
        static instance: BlockID = BlockID {
            hash: ::std::vec::Vec::new(),
            part_set_header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Header defines the structure of a Tendermint block header.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.Header)
pub struct Header {
    // message fields
    ///  basic block info
    // @@protoc_insertion_point(field:tendermint.types.Header.version)
    pub version: ::protobuf::MessageField<super::types::Consensus>,
    // @@protoc_insertion_point(field:tendermint.types.Header.chain_id)
    pub chain_id: ::std::string::String,
    // @@protoc_insertion_point(field:tendermint.types.Header.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.types.Header.time)
    pub time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  prev block info
    // @@protoc_insertion_point(field:tendermint.types.Header.last_block_id)
    pub last_block_id: ::protobuf::MessageField<BlockID>,
    ///  hashes of block data
    // @@protoc_insertion_point(field:tendermint.types.Header.last_commit_hash)
    pub last_commit_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Header.data_hash)
    pub data_hash: ::std::vec::Vec<u8>,
    ///  hashes from the app output from the prev block
    // @@protoc_insertion_point(field:tendermint.types.Header.validators_hash)
    pub validators_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Header.next_validators_hash)
    pub next_validators_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Header.consensus_hash)
    pub consensus_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Header.app_hash)
    pub app_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Header.last_results_hash)
    pub last_results_hash: ::std::vec::Vec<u8>,
    ///  consensus info
    // @@protoc_insertion_point(field:tendermint.types.Header.evidence_hash)
    pub evidence_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Header.proposer_address)
    pub proposer_address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Consensus>(
            "version",
            |m: &Header| { &m.version },
            |m: &mut Header| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &Header| { &m.chain_id },
            |m: &mut Header| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Header| { &m.height },
            |m: &mut Header| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            |m: &Header| { &m.time },
            |m: &mut Header| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "last_block_id",
            |m: &Header| { &m.last_block_id },
            |m: &mut Header| { &mut m.last_block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_commit_hash",
            |m: &Header| { &m.last_commit_hash },
            |m: &mut Header| { &mut m.last_commit_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_hash",
            |m: &Header| { &m.data_hash },
            |m: &mut Header| { &mut m.data_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validators_hash",
            |m: &Header| { &m.validators_hash },
            |m: &mut Header| { &mut m.validators_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_validators_hash",
            |m: &Header| { &m.next_validators_hash },
            |m: &mut Header| { &mut m.next_validators_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "consensus_hash",
            |m: &Header| { &m.consensus_hash },
            |m: &mut Header| { &mut m.consensus_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_hash",
            |m: &Header| { &m.app_hash },
            |m: &mut Header| { &mut m.app_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_results_hash",
            |m: &Header| { &m.last_results_hash },
            |m: &mut Header| { &mut m.last_results_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evidence_hash",
            |m: &Header| { &m.evidence_hash },
            |m: &mut Header| { &mut m.evidence_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposer_address",
            |m: &Header| { &m.proposer_address },
            |m: &mut Header| { &mut m.proposer_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
            "Header",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                18 => {
                    self.chain_id = is.read_string()?;
                },
                24 => {
                    self.height = is.read_int64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_block_id)?;
                },
                50 => {
                    self.last_commit_hash = is.read_bytes()?;
                },
                58 => {
                    self.data_hash = is.read_bytes()?;
                },
                66 => {
                    self.validators_hash = is.read_bytes()?;
                },
                74 => {
                    self.next_validators_hash = is.read_bytes()?;
                },
                82 => {
                    self.consensus_hash = is.read_bytes()?;
                },
                90 => {
                    self.app_hash = is.read_bytes()?;
                },
                98 => {
                    self.last_results_hash = is.read_bytes()?;
                },
                106 => {
                    self.evidence_hash = is.read_bytes()?;
                },
                114 => {
                    self.proposer_address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chain_id);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.height);
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.last_commit_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.last_commit_hash);
        }
        if !self.data_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.data_hash);
        }
        if !self.validators_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.validators_hash);
        }
        if !self.next_validators_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.next_validators_hash);
        }
        if !self.consensus_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.consensus_hash);
        }
        if !self.app_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.app_hash);
        }
        if !self.last_results_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.last_results_hash);
        }
        if !self.evidence_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.evidence_hash);
        }
        if !self.proposer_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.proposer_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(2, &self.chain_id)?;
        }
        if self.height != 0 {
            os.write_int64(3, self.height)?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.last_block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.last_commit_hash.is_empty() {
            os.write_bytes(6, &self.last_commit_hash)?;
        }
        if !self.data_hash.is_empty() {
            os.write_bytes(7, &self.data_hash)?;
        }
        if !self.validators_hash.is_empty() {
            os.write_bytes(8, &self.validators_hash)?;
        }
        if !self.next_validators_hash.is_empty() {
            os.write_bytes(9, &self.next_validators_hash)?;
        }
        if !self.consensus_hash.is_empty() {
            os.write_bytes(10, &self.consensus_hash)?;
        }
        if !self.app_hash.is_empty() {
            os.write_bytes(11, &self.app_hash)?;
        }
        if !self.last_results_hash.is_empty() {
            os.write_bytes(12, &self.last_results_hash)?;
        }
        if !self.evidence_hash.is_empty() {
            os.write_bytes(13, &self.evidence_hash)?;
        }
        if !self.proposer_address.is_empty() {
            os.write_bytes(14, &self.proposer_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.chain_id.clear();
        self.height = 0;
        self.time.clear();
        self.last_block_id.clear();
        self.last_commit_hash.clear();
        self.data_hash.clear();
        self.validators_hash.clear();
        self.next_validators_hash.clear();
        self.consensus_hash.clear();
        self.app_hash.clear();
        self.last_results_hash.clear();
        self.evidence_hash.clear();
        self.proposer_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            version: ::protobuf::MessageField::none(),
            chain_id: ::std::string::String::new(),
            height: 0,
            time: ::protobuf::MessageField::none(),
            last_block_id: ::protobuf::MessageField::none(),
            last_commit_hash: ::std::vec::Vec::new(),
            data_hash: ::std::vec::Vec::new(),
            validators_hash: ::std::vec::Vec::new(),
            next_validators_hash: ::std::vec::Vec::new(),
            consensus_hash: ::std::vec::Vec::new(),
            app_hash: ::std::vec::Vec::new(),
            last_results_hash: ::std::vec::Vec::new(),
            evidence_hash: ::std::vec::Vec::new(),
            proposer_address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Header {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Header").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Data contains the set of transactions included in the block
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.Data)
pub struct Data {
    // message fields
    ///  Txs that will be applied by state @ block.Height+1.
    ///  NOTE: not all txs here are valid.  We're just agreeing on the order first.
    ///  This means that block.AppHash does not include these txs.
    // @@protoc_insertion_point(field:tendermint.types.Data.txs)
    pub txs: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.Data.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Data {
    fn default() -> &'a Data {
        <Data as ::protobuf::Message>::default_instance()
    }
}

impl Data {
    pub fn new() -> Data {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "txs",
            |m: &Data| { &m.txs },
            |m: &mut Data| { &mut m.txs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Data>(
            "Data",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Data {
    const NAME: &'static str = "Data";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.txs.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.txs {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.txs {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Data {
        Data::new()
    }

    fn clear(&mut self) {
        self.txs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Data {
        static instance: Data = Data {
            txs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Data {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Data").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Data {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Data {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Vote represents a prevote, precommit, or commit vote from validators for
///  consensus.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.Vote)
pub struct Vote {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.Vote.type)
    pub type_: ::protobuf::EnumOrUnknown<SignedMsgType>,
    // @@protoc_insertion_point(field:tendermint.types.Vote.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.types.Vote.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.types.Vote.block_id)
    pub block_id: ::protobuf::MessageField<BlockID>,
    // @@protoc_insertion_point(field:tendermint.types.Vote.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:tendermint.types.Vote.validator_address)
    pub validator_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.Vote.validator_index)
    pub validator_index: i32,
    // @@protoc_insertion_point(field:tendermint.types.Vote.signature)
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.Vote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Vote| { &m.type_ },
            |m: &mut Vote| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Vote| { &m.height },
            |m: &mut Vote| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &Vote| { &m.round },
            |m: &mut Vote| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "block_id",
            |m: &Vote| { &m.block_id },
            |m: &mut Vote| { &mut m.block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &Vote| { &m.timestamp },
            |m: &mut Vote| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &Vote| { &m.validator_address },
            |m: &mut Vote| { &mut m.validator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_index",
            |m: &Vote| { &m.validator_index },
            |m: &mut Vote| { &mut m.validator_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &Vote| { &m.signature },
            |m: &mut Vote| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vote>(
            "Vote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vote {
    const NAME: &'static str = "Vote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.height = is.read_int64()?;
                },
                24 => {
                    self.round = is.read_int32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                50 => {
                    self.validator_address = is.read_bytes()?;
                },
                56 => {
                    self.validator_index = is.read_int32()?;
                },
                66 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.round);
        }
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.validator_address);
        }
        if self.validator_index != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.validator_index);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.height != 0 {
            os.write_int64(2, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(3, self.round)?;
        }
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.validator_address.is_empty() {
            os.write_bytes(6, &self.validator_address)?;
        }
        if self.validator_index != 0 {
            os.write_int32(7, self.validator_index)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(8, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN);
        self.height = 0;
        self.round = 0;
        self.block_id.clear();
        self.timestamp.clear();
        self.validator_address.clear();
        self.validator_index = 0;
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vote {
        static instance: Vote = Vote {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            height: 0,
            round: 0,
            block_id: ::protobuf::MessageField::none(),
            timestamp: ::protobuf::MessageField::none(),
            validator_address: ::std::vec::Vec::new(),
            validator_index: 0,
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Commit contains the evidence that a block was committed by a set of validators.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.Commit)
pub struct Commit {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.Commit.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.types.Commit.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.types.Commit.block_id)
    pub block_id: ::protobuf::MessageField<BlockID>,
    // @@protoc_insertion_point(field:tendermint.types.Commit.signatures)
    pub signatures: ::std::vec::Vec<CommitSig>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.Commit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Commit {
    fn default() -> &'a Commit {
        <Commit as ::protobuf::Message>::default_instance()
    }
}

impl Commit {
    pub fn new() -> Commit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Commit| { &m.height },
            |m: &mut Commit| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &Commit| { &m.round },
            |m: &mut Commit| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "block_id",
            |m: &Commit| { &m.block_id },
            |m: &mut Commit| { &mut m.block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &Commit| { &m.signatures },
            |m: &mut Commit| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Commit>(
            "Commit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Commit {
    const NAME: &'static str = "Commit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.round = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                34 => {
                    self.signatures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.round);
        }
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(2, self.round)?;
        }
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.signatures {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Commit {
        Commit::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.round = 0;
        self.block_id.clear();
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Commit {
        static instance: Commit = Commit {
            height: 0,
            round: 0,
            block_id: ::protobuf::MessageField::none(),
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Commit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Commit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Commit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Commit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CommitSig is a part of the Vote included in a Commit.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.CommitSig)
pub struct CommitSig {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.CommitSig.block_id_flag)
    pub block_id_flag: ::protobuf::EnumOrUnknown<BlockIDFlag>,
    // @@protoc_insertion_point(field:tendermint.types.CommitSig.validator_address)
    pub validator_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.CommitSig.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:tendermint.types.CommitSig.signature)
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.CommitSig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommitSig {
    fn default() -> &'a CommitSig {
        <CommitSig as ::protobuf::Message>::default_instance()
    }
}

impl CommitSig {
    pub fn new() -> CommitSig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_id_flag",
            |m: &CommitSig| { &m.block_id_flag },
            |m: &mut CommitSig| { &mut m.block_id_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "validator_address",
            |m: &CommitSig| { &m.validator_address },
            |m: &mut CommitSig| { &mut m.validator_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &CommitSig| { &m.timestamp },
            |m: &mut CommitSig| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &CommitSig| { &m.signature },
            |m: &mut CommitSig| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommitSig>(
            "CommitSig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommitSig {
    const NAME: &'static str = "CommitSig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.block_id_flag = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.validator_address = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                34 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.block_id_flag != ::protobuf::EnumOrUnknown::new(BlockIDFlag::BLOCK_ID_FLAG_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.block_id_flag.value());
        }
        if !self.validator_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.validator_address);
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.block_id_flag != ::protobuf::EnumOrUnknown::new(BlockIDFlag::BLOCK_ID_FLAG_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.block_id_flag))?;
        }
        if !self.validator_address.is_empty() {
            os.write_bytes(2, &self.validator_address)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(4, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommitSig {
        CommitSig::new()
    }

    fn clear(&mut self) {
        self.block_id_flag = ::protobuf::EnumOrUnknown::new(BlockIDFlag::BLOCK_ID_FLAG_UNKNOWN);
        self.validator_address.clear();
        self.timestamp.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommitSig {
        static instance: CommitSig = CommitSig {
            block_id_flag: ::protobuf::EnumOrUnknown::from_i32(0),
            validator_address: ::std::vec::Vec::new(),
            timestamp: ::protobuf::MessageField::none(),
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommitSig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommitSig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommitSig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitSig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.Proposal)
pub struct Proposal {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.Proposal.type)
    pub type_: ::protobuf::EnumOrUnknown<SignedMsgType>,
    // @@protoc_insertion_point(field:tendermint.types.Proposal.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.types.Proposal.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.types.Proposal.pol_round)
    pub pol_round: i32,
    // @@protoc_insertion_point(field:tendermint.types.Proposal.block_id)
    pub block_id: ::protobuf::MessageField<BlockID>,
    // @@protoc_insertion_point(field:tendermint.types.Proposal.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:tendermint.types.Proposal.signature)
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.Proposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Proposal| { &m.type_ },
            |m: &mut Proposal| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Proposal| { &m.height },
            |m: &mut Proposal| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &Proposal| { &m.round },
            |m: &mut Proposal| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pol_round",
            |m: &Proposal| { &m.pol_round },
            |m: &mut Proposal| { &mut m.pol_round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "block_id",
            |m: &Proposal| { &m.block_id },
            |m: &mut Proposal| { &mut m.block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &Proposal| { &m.timestamp },
            |m: &mut Proposal| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &Proposal| { &m.signature },
            |m: &mut Proposal| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Proposal>(
            "Proposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Proposal {
    const NAME: &'static str = "Proposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.height = is.read_int64()?;
                },
                24 => {
                    self.round = is.read_int32()?;
                },
                32 => {
                    self.pol_round = is.read_int32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                58 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.round);
        }
        if self.pol_round != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.pol_round);
        }
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.height != 0 {
            os.write_int64(2, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(3, self.round)?;
        }
        if self.pol_round != 0 {
            os.write_int32(4, self.pol_round)?;
        }
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(7, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN);
        self.height = 0;
        self.round = 0;
        self.pol_round = 0;
        self.block_id.clear();
        self.timestamp.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Proposal {
        static instance: Proposal = Proposal {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            height: 0,
            round: 0,
            pol_round: 0,
            block_id: ::protobuf::MessageField::none(),
            timestamp: ::protobuf::MessageField::none(),
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Proposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Proposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.SignedHeader)
pub struct SignedHeader {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.SignedHeader.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:tendermint.types.SignedHeader.commit)
    pub commit: ::protobuf::MessageField<Commit>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.SignedHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignedHeader {
    fn default() -> &'a SignedHeader {
        <SignedHeader as ::protobuf::Message>::default_instance()
    }
}

impl SignedHeader {
    pub fn new() -> SignedHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &SignedHeader| { &m.header },
            |m: &mut SignedHeader| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Commit>(
            "commit",
            |m: &SignedHeader| { &m.commit },
            |m: &mut SignedHeader| { &mut m.commit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedHeader>(
            "SignedHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignedHeader {
    const NAME: &'static str = "SignedHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commit)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.commit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.commit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignedHeader {
        SignedHeader::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.commit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignedHeader {
        static instance: SignedHeader = SignedHeader {
            header: ::protobuf::MessageField::none(),
            commit: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignedHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignedHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignedHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.LightBlock)
pub struct LightBlock {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.LightBlock.signed_header)
    pub signed_header: ::protobuf::MessageField<SignedHeader>,
    // @@protoc_insertion_point(field:tendermint.types.LightBlock.validator_set)
    pub validator_set: ::protobuf::MessageField<super::validator::ValidatorSet>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.LightBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LightBlock {
    fn default() -> &'a LightBlock {
        <LightBlock as ::protobuf::Message>::default_instance()
    }
}

impl LightBlock {
    pub fn new() -> LightBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SignedHeader>(
            "signed_header",
            |m: &LightBlock| { &m.signed_header },
            |m: &mut LightBlock| { &mut m.signed_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::validator::ValidatorSet>(
            "validator_set",
            |m: &LightBlock| { &m.validator_set },
            |m: &mut LightBlock| { &mut m.validator_set },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LightBlock>(
            "LightBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LightBlock {
    const NAME: &'static str = "LightBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.signed_header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.validator_set)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signed_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.validator_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signed_header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.validator_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LightBlock {
        LightBlock::new()
    }

    fn clear(&mut self) {
        self.signed_header.clear();
        self.validator_set.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LightBlock {
        static instance: LightBlock = LightBlock {
            signed_header: ::protobuf::MessageField::none(),
            validator_set: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LightBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LightBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LightBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.BlockMeta)
pub struct BlockMeta {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.BlockMeta.block_id)
    pub block_id: ::protobuf::MessageField<BlockID>,
    // @@protoc_insertion_point(field:tendermint.types.BlockMeta.block_size)
    pub block_size: i64,
    // @@protoc_insertion_point(field:tendermint.types.BlockMeta.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:tendermint.types.BlockMeta.num_txs)
    pub num_txs: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.BlockMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockMeta {
    fn default() -> &'a BlockMeta {
        <BlockMeta as ::protobuf::Message>::default_instance()
    }
}

impl BlockMeta {
    pub fn new() -> BlockMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "block_id",
            |m: &BlockMeta| { &m.block_id },
            |m: &mut BlockMeta| { &mut m.block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_size",
            |m: &BlockMeta| { &m.block_size },
            |m: &mut BlockMeta| { &mut m.block_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &BlockMeta| { &m.header },
            |m: &mut BlockMeta| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_txs",
            |m: &BlockMeta| { &m.num_txs },
            |m: &mut BlockMeta| { &mut m.num_txs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockMeta>(
            "BlockMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockMeta {
    const NAME: &'static str = "BlockMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                16 => {
                    self.block_size = is.read_int64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                32 => {
                    self.num_txs = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.block_size != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.block_size);
        }
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.num_txs != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.num_txs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.block_size != 0 {
            os.write_int64(2, self.block_size)?;
        }
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.num_txs != 0 {
            os.write_int64(4, self.num_txs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockMeta {
        BlockMeta::new()
    }

    fn clear(&mut self) {
        self.block_id.clear();
        self.block_size = 0;
        self.header.clear();
        self.num_txs = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockMeta {
        static instance: BlockMeta = BlockMeta {
            block_id: ::protobuf::MessageField::none(),
            block_size: 0,
            header: ::protobuf::MessageField::none(),
            num_txs: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TxProof represents a Merkle proof of the presence of a transaction in the Merkle tree.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.TxProof)
pub struct TxProof {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.TxProof.root_hash)
    pub root_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.TxProof.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:tendermint.types.TxProof.proof)
    pub proof: ::protobuf::MessageField<super::proof::Proof>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.TxProof.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TxProof {
    fn default() -> &'a TxProof {
        <TxProof as ::protobuf::Message>::default_instance()
    }
}

impl TxProof {
    pub fn new() -> TxProof {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "root_hash",
            |m: &TxProof| { &m.root_hash },
            |m: &mut TxProof| { &mut m.root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &TxProof| { &m.data },
            |m: &mut TxProof| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::proof::Proof>(
            "proof",
            |m: &TxProof| { &m.proof },
            |m: &mut TxProof| { &mut m.proof },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TxProof>(
            "TxProof",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TxProof {
    const NAME: &'static str = "TxProof";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.root_hash = is.read_bytes()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proof)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.root_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.root_hash);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if let Some(v) = self.proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.root_hash.is_empty() {
            os.write_bytes(1, &self.root_hash)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if let Some(v) = self.proof.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TxProof {
        TxProof::new()
    }

    fn clear(&mut self) {
        self.root_hash.clear();
        self.data.clear();
        self.proof.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TxProof {
        static instance: TxProof = TxProof {
            root_hash: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            proof: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TxProof {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TxProof").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TxProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxProof {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BlockIdFlag indicates which BlcokID the signature is for
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tendermint.types.BlockIDFlag)
pub enum BlockIDFlag {
    // @@protoc_insertion_point(enum_value:tendermint.types.BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN)
    BLOCK_ID_FLAG_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:tendermint.types.BlockIDFlag.BLOCK_ID_FLAG_ABSENT)
    BLOCK_ID_FLAG_ABSENT = 1,
    // @@protoc_insertion_point(enum_value:tendermint.types.BlockIDFlag.BLOCK_ID_FLAG_COMMIT)
    BLOCK_ID_FLAG_COMMIT = 2,
    // @@protoc_insertion_point(enum_value:tendermint.types.BlockIDFlag.BLOCK_ID_FLAG_NIL)
    BLOCK_ID_FLAG_NIL = 3,
}

impl ::protobuf::Enum for BlockIDFlag {
    const NAME: &'static str = "BlockIDFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockIDFlag> {
        match value {
            0 => ::std::option::Option::Some(BlockIDFlag::BLOCK_ID_FLAG_UNKNOWN),
            1 => ::std::option::Option::Some(BlockIDFlag::BLOCK_ID_FLAG_ABSENT),
            2 => ::std::option::Option::Some(BlockIDFlag::BLOCK_ID_FLAG_COMMIT),
            3 => ::std::option::Option::Some(BlockIDFlag::BLOCK_ID_FLAG_NIL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BlockIDFlag] = &[
        BlockIDFlag::BLOCK_ID_FLAG_UNKNOWN,
        BlockIDFlag::BLOCK_ID_FLAG_ABSENT,
        BlockIDFlag::BLOCK_ID_FLAG_COMMIT,
        BlockIDFlag::BLOCK_ID_FLAG_NIL,
    ];
}

impl ::protobuf::EnumFull for BlockIDFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BlockIDFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BlockIDFlag {
    fn default() -> Self {
        BlockIDFlag::BLOCK_ID_FLAG_UNKNOWN
    }
}

impl BlockIDFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BlockIDFlag>("BlockIDFlag")
    }
}

///  SignedMsgType is a type of signed message in the consensus.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tendermint.types.SignedMsgType)
pub enum SignedMsgType {
    // @@protoc_insertion_point(enum_value:tendermint.types.SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN)
    SIGNED_MSG_TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:tendermint.types.SignedMsgType.SIGNED_MSG_TYPE_PREVOTE)
    SIGNED_MSG_TYPE_PREVOTE = 1,
    // @@protoc_insertion_point(enum_value:tendermint.types.SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT)
    SIGNED_MSG_TYPE_PRECOMMIT = 2,
    // @@protoc_insertion_point(enum_value:tendermint.types.SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL)
    SIGNED_MSG_TYPE_PROPOSAL = 32,
}

impl ::protobuf::Enum for SignedMsgType {
    const NAME: &'static str = "SignedMsgType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SignedMsgType> {
        match value {
            0 => ::std::option::Option::Some(SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(SignedMsgType::SIGNED_MSG_TYPE_PREVOTE),
            2 => ::std::option::Option::Some(SignedMsgType::SIGNED_MSG_TYPE_PRECOMMIT),
            32 => ::std::option::Option::Some(SignedMsgType::SIGNED_MSG_TYPE_PROPOSAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SignedMsgType] = &[
        SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN,
        SignedMsgType::SIGNED_MSG_TYPE_PREVOTE,
        SignedMsgType::SIGNED_MSG_TYPE_PRECOMMIT,
        SignedMsgType::SIGNED_MSG_TYPE_PROPOSAL,
    ];
}

impl ::protobuf::EnumFull for SignedMsgType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SignedMsgType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN => 0,
            SignedMsgType::SIGNED_MSG_TYPE_PREVOTE => 1,
            SignedMsgType::SIGNED_MSG_TYPE_PRECOMMIT => 2,
            SignedMsgType::SIGNED_MSG_TYPE_PROPOSAL => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SignedMsgType {
    fn default() -> Self {
        SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN
    }
}

impl SignedMsgType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SignedMsgType>("SignedMsgType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ctendermint/types/types.proto\x12\x10tendermint.types\x1a\x14gogopr\
    oto/gogo.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1dtendermint/\
    crypto/proof.proto\x1a\x1etendermint/version/types.proto\x1a\x20tendermi\
    nt/types/validator.proto\"9\n\rPartSetHeader\x12\x14\n\x05total\x18\x01\
    \x20\x01(\rR\x05total\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\"h\
    \n\x04Part\x12\x14\n\x05index\x18\x01\x20\x01(\rR\x05index\x12\x14\n\x05\
    bytes\x18\x02\x20\x01(\x0cR\x05bytes\x124\n\x05proof\x18\x03\x20\x01(\
    \x0b2\x18.tendermint.crypto.ProofR\x05proofB\x04\xc8\xde\x1f\0\"l\n\x07B\
    lockID\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12M\n\x0fpart_se\
    t_header\x18\x02\x20\x01(\x0b2\x1f.tendermint.types.PartSetHeaderR\rpart\
    SetHeaderB\x04\xc8\xde\x1f\0\"\xe6\x04\n\x06Header\x12=\n\x07version\x18\
    \x01\x20\x01(\x0b2\x1d.tendermint.version.ConsensusR\x07versionB\x04\xc8\
    \xde\x1f\0\x12&\n\x08chain_id\x18\x02\x20\x01(\tR\x07chainIdB\x0b\xe2\
    \xde\x1f\x07ChainID\x12\x16\n\x06height\x18\x03\x20\x01(\x03R\x06height\
    \x128\n\x04time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x04\
    timeB\x08\xc8\xde\x1f\0\x90\xdf\x1f\x01\x12C\n\rlast_block_id\x18\x05\
    \x20\x01(\x0b2\x19.tendermint.types.BlockIDR\x0blastBlockIdB\x04\xc8\xde\
    \x1f\0\x12(\n\x10last_commit_hash\x18\x06\x20\x01(\x0cR\x0elastCommitHas\
    h\x12\x1b\n\tdata_hash\x18\x07\x20\x01(\x0cR\x08dataHash\x12'\n\x0fvalid\
    ators_hash\x18\x08\x20\x01(\x0cR\x0evalidatorsHash\x120\n\x14next_valida\
    tors_hash\x18\t\x20\x01(\x0cR\x12nextValidatorsHash\x12%\n\x0econsensus_\
    hash\x18\n\x20\x01(\x0cR\rconsensusHash\x12\x19\n\x08app_hash\x18\x0b\
    \x20\x01(\x0cR\x07appHash\x12*\n\x11last_results_hash\x18\x0c\x20\x01(\
    \x0cR\x0flastResultsHash\x12#\n\revidence_hash\x18\r\x20\x01(\x0cR\x0cev\
    idenceHash\x12)\n\x10proposer_address\x18\x0e\x20\x01(\x0cR\x0fproposerA\
    ddress\"\x18\n\x04Data\x12\x10\n\x03txs\x18\x01\x20\x03(\x0cR\x03txs\"\
    \xe8\x02\n\x04Vote\x123\n\x04type\x18\x01\x20\x01(\x0e2\x1f.tendermint.t\
    ypes.SignedMsgTypeR\x04type\x12\x16\n\x06height\x18\x02\x20\x01(\x03R\
    \x06height\x12\x14\n\x05round\x18\x03\x20\x01(\x05R\x05round\x12E\n\x08b\
    lock_id\x18\x04\x20\x01(\x0b2\x19.tendermint.types.BlockIDR\x07blockIdB\
    \x0f\xc8\xde\x1f\0\xe2\xde\x1f\x07BlockID\x12B\n\ttimestamp\x18\x05\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\ttimestampB\x08\xc8\xde\x1f\0\
    \x90\xdf\x1f\x01\x12+\n\x11validator_address\x18\x06\x20\x01(\x0cR\x10va\
    lidatorAddress\x12'\n\x0fvalidator_index\x18\x07\x20\x01(\x05R\x0evalida\
    torIndex\x12\x1c\n\tsignature\x18\x08\x20\x01(\x0cR\tsignature\"\xc0\x01\
    \n\x06Commit\x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06height\x12\x14\
    \n\x05round\x18\x02\x20\x01(\x05R\x05round\x12E\n\x08block_id\x18\x03\
    \x20\x01(\x0b2\x19.tendermint.types.BlockIDR\x07blockIdB\x0f\xc8\xde\x1f\
    \0\xe2\xde\x1f\x07BlockID\x12A\n\nsignatures\x18\x04\x20\x03(\x0b2\x1b.t\
    endermint.types.CommitSigR\nsignaturesB\x04\xc8\xde\x1f\0\"\xdd\x01\n\tC\
    ommitSig\x12A\n\rblock_id_flag\x18\x01\x20\x01(\x0e2\x1d.tendermint.type\
    s.BlockIDFlagR\x0bblockIdFlag\x12+\n\x11validator_address\x18\x02\x20\
    \x01(\x0cR\x10validatorAddress\x12B\n\ttimestamp\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\ttimestampB\x08\xc8\xde\x1f\0\x90\xdf\
    \x1f\x01\x12\x1c\n\tsignature\x18\x04\x20\x01(\x0cR\tsignature\"\xb3\x02\
    \n\x08Proposal\x123\n\x04type\x18\x01\x20\x01(\x0e2\x1f.tendermint.types\
    .SignedMsgTypeR\x04type\x12\x16\n\x06height\x18\x02\x20\x01(\x03R\x06hei\
    ght\x12\x14\n\x05round\x18\x03\x20\x01(\x05R\x05round\x12\x1b\n\tpol_rou\
    nd\x18\x04\x20\x01(\x05R\x08polRound\x12E\n\x08block_id\x18\x05\x20\x01(\
    \x0b2\x19.tendermint.types.BlockIDR\x07blockIdB\x0f\xc8\xde\x1f\0\xe2\
    \xde\x1f\x07BlockID\x12B\n\ttimestamp\x18\x06\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\ttimestampB\x08\xc8\xde\x1f\0\x90\xdf\x1f\x01\x12\x1c\
    \n\tsignature\x18\x07\x20\x01(\x0cR\tsignature\"r\n\x0cSignedHeader\x120\
    \n\x06header\x18\x01\x20\x01(\x0b2\x18.tendermint.types.HeaderR\x06heade\
    r\x120\n\x06commit\x18\x02\x20\x01(\x0b2\x18.tendermint.types.CommitR\
    \x06commit\"\x96\x01\n\nLightBlock\x12C\n\rsigned_header\x18\x01\x20\x01\
    (\x0b2\x1e.tendermint.types.SignedHeaderR\x0csignedHeader\x12C\n\rvalida\
    tor_set\x18\x02\x20\x01(\x0b2\x1e.tendermint.types.ValidatorSetR\x0cvali\
    datorSet\"\xc2\x01\n\tBlockMeta\x12E\n\x08block_id\x18\x01\x20\x01(\x0b2\
    \x19.tendermint.types.BlockIDR\x07blockIdB\x0f\xc8\xde\x1f\0\xe2\xde\x1f\
    \x07BlockID\x12\x1d\n\nblock_size\x18\x02\x20\x01(\x03R\tblockSize\x126\
    \n\x06header\x18\x03\x20\x01(\x0b2\x18.tendermint.types.HeaderR\x06heade\
    rB\x04\xc8\xde\x1f\0\x12\x17\n\x07num_txs\x18\x04\x20\x01(\x03R\x06numTx\
    s\"j\n\x07TxProof\x12\x1b\n\troot_hash\x18\x01\x20\x01(\x0cR\x08rootHash\
    \x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\x12.\n\x05proof\x18\x03\
    \x20\x01(\x0b2\x18.tendermint.crypto.ProofR\x05proof*\xd7\x01\n\x0bBlock\
    IDFlag\x121\n\x15BLOCK_ID_FLAG_UNKNOWN\x10\0\x1a\x16\x8a\x9d\x20\x12Bloc\
    kIDFlagUnknown\x12/\n\x14BLOCK_ID_FLAG_ABSENT\x10\x01\x1a\x15\x8a\x9d\
    \x20\x11BlockIDFlagAbsent\x12/\n\x14BLOCK_ID_FLAG_COMMIT\x10\x02\x1a\x15\
    \x8a\x9d\x20\x11BlockIDFlagCommit\x12)\n\x11BLOCK_ID_FLAG_NIL\x10\x03\
    \x1a\x12\x8a\x9d\x20\x0eBlockIDFlagNil\x1a\x08\x88\xa3\x1e\0\xa8\xa4\x1e\
    \x01*\xd7\x01\n\rSignedMsgType\x12,\n\x17SIGNED_MSG_TYPE_UNKNOWN\x10\0\
    \x1a\x0f\x8a\x9d\x20\x0bUnknownType\x12,\n\x17SIGNED_MSG_TYPE_PREVOTE\
    \x10\x01\x1a\x0f\x8a\x9d\x20\x0bPrevoteType\x120\n\x19SIGNED_MSG_TYPE_PR\
    ECOMMIT\x10\x02\x1a\x11\x8a\x9d\x20\rPrecommitType\x12.\n\x18SIGNED_MSG_\
    TYPE_PROPOSAL\x10\x20\x1a\x10\x8a\x9d\x20\x0cProposalType\x1a\x08\x88\
    \xa3\x1e\0\xa8\xa4\x1e\x01B9Z7github.com/tendermint/tendermint/proto/ten\
    dermint/typesJ\x8f1\n\x07\x12\x05\0\0\x9c\x01\x01\n\x08\n\x01\x0c\x12\
    \x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x19\n\x08\n\x01\x08\x12\x03\
    \x03\0N\n\t\n\x02\x08\x0b\x12\x03\x03\0N\n\t\n\x02\x03\0\x12\x03\x05\0\
    \x1e\n\t\n\x02\x03\x01\x12\x03\x06\0)\n\t\n\x02\x03\x02\x12\x03\x07\0'\n\
    \t\n\x02\x03\x03\x12\x03\x08\0(\n\t\n\x02\x03\x04\x12\x03\t\0*\nF\n\x02\
    \x05\0\x12\x04\x0c\0\x14\x01\x1a:\x20BlockIdFlag\x20indicates\x20which\
    \x20BlcokID\x20the\x20signature\x20is\x20for\n\n\n\n\x03\x05\0\x01\x12\
    \x03\x0c\x05\x10\n\n\n\x03\x05\0\x03\x12\x03\r\x022\n\r\n\x06\x05\0\x03\
    \xc5\xe4\x03\x12\x03\r\x022\n\n\n\x03\x05\0\x03\x12\x03\x0e\x023\n\r\n\
    \x06\x05\0\x03\xb1\xe4\x03\x12\x03\x0e\x023\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03\x10\x02V\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x10\x02\x17\n\x0c\n\
    \x05\x05\0\x02\0\x02\x12\x03\x10\x1a\x1b\n\x0c\n\x05\x05\0\x02\0\x03\x12\
    \x03\x10\x1cU\n\x0f\n\x08\x05\0\x02\0\x03\xd1\x83\x04\x12\x03\x10\x1dT\n\
    \x0b\n\x04\x05\0\x02\x01\x12\x03\x11\x02U\n\x0c\n\x05\x05\0\x02\x01\x01\
    \x12\x03\x11\x02\x16\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x11\x1a\x1b\n\
    \x0c\n\x05\x05\0\x02\x01\x03\x12\x03\x11\x1cT\n\x0f\n\x08\x05\0\x02\x01\
    \x03\xd1\x83\x04\x12\x03\x11\x1dS\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x12\
    \x02U\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x12\x02\x16\n\x0c\n\x05\x05\
    \0\x02\x02\x02\x12\x03\x12\x1a\x1b\n\x0c\n\x05\x05\0\x02\x02\x03\x12\x03\
    \x12\x1cT\n\x0f\n\x08\x05\0\x02\x02\x03\xd1\x83\x04\x12\x03\x12\x1dS\n\
    \x0b\n\x04\x05\0\x02\x03\x12\x03\x13\x02R\n\x0c\n\x05\x05\0\x02\x03\x01\
    \x12\x03\x13\x02\x13\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x13\x1a\x1b\n\
    \x0c\n\x05\x05\0\x02\x03\x03\x12\x03\x13\x1cQ\n\x0f\n\x08\x05\0\x02\x03\
    \x03\xd1\x83\x04\x12\x03\x13\x1dP\nI\n\x02\x05\x01\x12\x04\x17\0\"\x01\
    \x1a=\x20SignedMsgType\x20is\x20a\x20type\x20of\x20signed\x20message\x20\
    in\x20the\x20consensus.\n\n\n\n\x03\x05\x01\x01\x12\x03\x17\x05\x12\n\n\
    \n\x03\x05\x01\x03\x12\x03\x18\x022\n\r\n\x06\x05\x01\x03\xc5\xe4\x03\
    \x12\x03\x18\x022\n\n\n\x03\x05\x01\x03\x12\x03\x19\x023\n\r\n\x06\x05\
    \x01\x03\xb1\xe4\x03\x12\x03\x19\x023\n\x0b\n\x04\x05\x01\x02\0\x12\x03\
    \x1b\x02Q\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x1b\x02\x19\n\x0c\n\x05\
    \x05\x01\x02\0\x02\x12\x03\x1b\x1c\x1d\n\x0c\n\x05\x05\x01\x02\0\x03\x12\
    \x03\x1b\x1eP\n\x0f\n\x08\x05\x01\x02\0\x03\xd1\x83\x04\x12\x03\x1b\x1fO\
    \n\x14\n\x04\x05\x01\x02\x01\x12\x03\x1d\x02S\x1a\x07\x20Votes\n\n\x0c\n\
    \x05\x05\x01\x02\x01\x01\x12\x03\x1d\x02\x19\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03\x1d\x1e\x1f\n\x0c\n\x05\x05\x01\x02\x01\x03\x12\x03\x1d\x20\
    R\n\x0f\n\x08\x05\x01\x02\x01\x03\xd1\x83\x04\x12\x03\x1d!Q\n\x0b\n\x04\
    \x05\x01\x02\x02\x12\x03\x1e\x02U\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\
    \x03\x1e\x02\x1b\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x1e\x1e\x1f\n\
    \x0c\n\x05\x05\x01\x02\x02\x03\x12\x03\x1e\x20T\n\x0f\n\x08\x05\x01\x02\
    \x02\x03\xd1\x83\x04\x12\x03\x1e!S\n\x18\n\x04\x05\x01\x02\x03\x12\x03!\
    \x02T\x1a\x0b\x20Proposals\n\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03!\
    \x02\x1a\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03!\x1d\x1f\n\x0c\n\x05\
    \x05\x01\x02\x03\x03\x12\x03!\x20S\n\x0f\n\x08\x05\x01\x02\x03\x03\xd1\
    \x83\x04\x12\x03!!R\n\x1b\n\x02\x04\0\x12\x04%\0(\x01\x1a\x0f\x20Partset\
    Header\n\n\n\n\x03\x04\0\x01\x12\x03%\x08\x15\n\x0b\n\x04\x04\0\x02\0\
    \x12\x03&\x02\x13\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03&\x02\x08\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03&\t\x0e\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03&\
    \x11\x12\n\x0b\n\x04\x04\0\x02\x01\x12\x03'\x02\x13\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03'\x02\x07\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03'\t\r\
    \n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03'\x11\x12\n\n\n\x02\x04\x01\x12\
    \x04*\0.\x01\n\n\n\x03\x04\x01\x01\x12\x03*\x08\x0c\n\x0b\n\x04\x04\x01\
    \x02\0\x12\x03+\x02$\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03+\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03+\x1a\x1f\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03+\"#\n\x0b\n\x04\x04\x01\x02\x01\x12\x03,\x02$\n\x0c\n\x05\
    \x04\x01\x02\x01\x05\x12\x03,\x02\x07\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03,\x1a\x1f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03,\"#\n\x0b\n\
    \x04\x04\x01\x02\x02\x12\x03-\x02C\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\
    \x03-\x02\x19\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03-\x1a\x1f\n\x0c\n\
    \x05\x04\x01\x02\x02\x03\x12\x03-\"#\n\x0c\n\x05\x04\x01\x02\x02\x08\x12\
    \x03-$B\n\x0f\n\x08\x04\x01\x02\x02\x08\xe9\xfb\x03\x12\x03-%A\n\x15\n\
    \x02\x04\x02\x12\x041\04\x01\x1a\t\x20BlockID\n\n\n\n\x03\x04\x02\x01\
    \x12\x031\x08\x0f\n\x0b\n\x04\x04\x02\x02\0\x12\x032\x02$\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x032\x02\x07\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x032\x10\x14\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x032\"#\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x033\x02C\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x033\x02\
    \x0f\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x033\x10\x1f\n\x0c\n\x05\x04\
    \x02\x02\x01\x03\x12\x033\"#\n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x033$B\
    \n\x0f\n\x08\x04\x02\x02\x01\x08\xe9\xfb\x03\x12\x033%A\nl\n\x02\x04\x03\
    \x12\x049\0Q\x01\x1a<\x20Header\x20defines\x20the\x20structure\x20of\x20\
    a\x20Tendermint\x20block\x20header.\n2\"\x20----------------------------\
    ----\n\n\n\n\x03\x04\x03\x01\x12\x039\x08\x0e\n\x1f\n\x04\x04\x03\x02\0\
    \x12\x03;\x02K\x1a\x12\x20basic\x20block\x20info\n\n\x0c\n\x05\x04\x03\
    \x02\0\x06\x12\x03;\x02\x1e\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03;\x1f&\
    \n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03;*+\n\x0c\n\x05\x04\x03\x02\0\x08\
    \x12\x03;,J\n\x0f\n\x08\x04\x03\x02\0\x08\xe9\xfb\x03\x12\x03;-I\n\x0b\n\
    \x04\x04\x03\x02\x01\x12\x03<\x02Q\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\
    \x03<\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03<\x1f'\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x03<*+\n\x0c\n\x05\x04\x03\x02\x01\x08\x12\x03<\
    ,P\n\x0f\n\x08\x04\x03\x02\x01\x08\xec\xfb\x03\x12\x03<-O\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x03=\x02,\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03=\
    \x02\x07\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03=\x1f%\n\x0c\n\x05\x04\
    \x03\x02\x02\x03\x12\x03=*+\n\x0b\n\x04\x04\x03\x02\x03\x12\x03>\x02g\n\
    \x0c\n\x05\x04\x03\x02\x03\x06\x12\x03>\x02\x1b\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03>\x1f#\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03>*+\n\x0c\
    \n\x05\x04\x03\x02\x03\x08\x12\x03>,f\n\x0f\n\x08\x04\x03\x02\x03\x08\
    \xe9\xfb\x03\x12\x03>-I\n\x0f\n\x08\x04\x03\x02\x03\x08\xf2\xfb\x03\x12\
    \x03>Ke\n\x1e\n\x04\x04\x03\x02\x04\x12\x03A\x02;\x1a\x11\x20prev\x20blo\
    ck\x20info\n\n\x0c\n\x05\x04\x03\x02\x04\x06\x12\x03A\x02\t\n\x0c\n\x05\
    \x04\x03\x02\x04\x01\x12\x03A\n\x17\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\
    \x03A\x1a\x1b\n\x0c\n\x05\x04\x03\x02\x04\x08\x12\x03A\x1c:\n\x0f\n\x08\
    \x04\x03\x02\x04\x08\xe9\xfb\x03\x12\x03A\x1d9\nQ\n\x04\x04\x03\x02\x05\
    \x12\x03D\x02\x1d\x1a\x16\x20hashes\x20of\x20block\x20data\n\",\x20commi\
    t\x20from\x20validators\x20from\x20the\x20last\x20block\n\n\x0c\n\x05\
    \x04\x03\x02\x05\x05\x12\x03D\x02\x07\n\x0c\n\x05\x04\x03\x02\x05\x01\
    \x12\x03D\x08\x18\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03D\x1b\x1c\n\x1b\
    \n\x04\x04\x03\x02\x06\x12\x03E\x02\x1d\"\x0e\x20transactions\n\n\x0c\n\
    \x05\x04\x03\x02\x06\x05\x12\x03E\x02\x07\n\x0c\n\x05\x04\x03\x02\x06\
    \x01\x12\x03E\x08\x11\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03E\x1b\x1c\n\
    a\n\x04\x04\x03\x02\x07\x12\x03H\x02!\x1a0\x20hashes\x20from\x20the\x20a\
    pp\x20output\x20from\x20the\x20prev\x20block\n\"\"\x20validators\x20for\
    \x20the\x20current\x20block\n\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03H\
    \x02\x07\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03H\x08\x17\n\x0c\n\x05\
    \x04\x03\x02\x07\x03\x12\x03H\x1f\x20\n,\n\x04\x04\x03\x02\x08\x12\x03I\
    \x02!\"\x1f\x20validators\x20for\x20the\x20next\x20block\n\n\x0c\n\x05\
    \x04\x03\x02\x08\x05\x12\x03I\x02\x07\n\x0c\n\x05\x04\x03\x02\x08\x01\
    \x12\x03I\x08\x1c\n\x0c\n\x05\x04\x03\x02\x08\x03\x12\x03I\x1f\x20\n1\n\
    \x04\x04\x03\x02\t\x12\x03J\x02\"\"$\x20consensus\x20params\x20for\x20cu\
    rrent\x20block\n\n\x0c\n\x05\x04\x03\x02\t\x05\x12\x03J\x02\x07\n\x0c\n\
    \x05\x04\x03\x02\t\x01\x12\x03J\x08\x16\n\x0c\n\x05\x04\x03\x02\t\x03\
    \x12\x03J\x1f!\n6\n\x04\x04\x03\x02\n\x12\x03K\x02\"\")\x20state\x20afte\
    r\x20txs\x20from\x20the\x20previous\x20block\n\n\x0c\n\x05\x04\x03\x02\n\
    \x05\x12\x03K\x02\x07\n\x0c\n\x05\x04\x03\x02\n\x01\x12\x03K\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\n\x03\x12\x03K\x1f!\nL\n\x04\x04\x03\x02\x0b\x12\
    \x03L\x02\"\"?\x20root\x20hash\x20of\x20all\x20results\x20from\x20the\
    \x20txs\x20from\x20the\x20previous\x20block\n\n\x0c\n\x05\x04\x03\x02\
    \x0b\x05\x12\x03L\x02\x07\n\x0c\n\x05\x04\x03\x02\x0b\x01\x12\x03L\x08\
    \x19\n\x0c\n\x05\x04\x03\x02\x0b\x03\x12\x03L\x1f!\n?\n\x04\x04\x03\x02\
    \x0c\x12\x03O\x02\x1e\x1a\x10\x20consensus\x20info\n\"\x20\x20evidence\
    \x20included\x20in\x20the\x20block\n\n\x0c\n\x05\x04\x03\x02\x0c\x05\x12\
    \x03O\x02\x07\n\x0c\n\x05\x04\x03\x02\x0c\x01\x12\x03O\x08\x15\n\x0c\n\
    \x05\x04\x03\x02\x0c\x03\x12\x03O\x1b\x1d\n-\n\x04\x04\x03\x02\r\x12\x03\
    P\x02\x1e\"\x20\x20original\x20proposer\x20of\x20the\x20block\n\n\x0c\n\
    \x05\x04\x03\x02\r\x05\x12\x03P\x02\x07\n\x0c\n\x05\x04\x03\x02\r\x01\
    \x12\x03P\x08\x18\n\x0c\n\x05\x04\x03\x02\r\x03\x12\x03P\x1b\x1d\nI\n\
    \x02\x04\x04\x12\x04T\0Y\x01\x1a=\x20Data\x20contains\x20the\x20set\x20o\
    f\x20transactions\x20included\x20in\x20the\x20block\n\n\n\n\x03\x04\x04\
    \x01\x12\x03T\x08\x0c\n\xca\x01\n\x04\x04\x04\x02\0\x12\x03X\x02\x19\x1a\
    \xbc\x01\x20Txs\x20that\x20will\x20be\x20applied\x20by\x20state\x20@\x20\
    block.Height+1.\n\x20NOTE:\x20not\x20all\x20txs\x20here\x20are\x20valid.\
    \x20\x20We're\x20just\x20agreeing\x20on\x20the\x20order\x20first.\n\x20T\
    his\x20means\x20that\x20block.AppHash\x20does\x20not\x20include\x20these\
    \x20txs.\n\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03X\x02\n\n\x0c\n\x05\x04\
    \x04\x02\0\x05\x12\x03X\x0b\x10\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03X\
    \x11\x14\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03X\x17\x18\nb\n\x02\x04\x05\
    \x12\x04]\0h\x01\x1aV\x20Vote\x20represents\x20a\x20prevote,\x20precommi\
    t,\x20or\x20commit\x20vote\x20from\x20validators\x20for\n\x20consensus.\
    \n\n\n\n\x03\x04\x05\x01\x12\x03]\x08\x0c\n\x0b\n\x04\x04\x05\x02\0\x12\
    \x03^\x02\x1d\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03^\x02\x0f\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03^\x10\x14\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03^\x1b\x1c\n\x0b\n\x04\x04\x05\x02\x01\x12\x03_\x02\x1d\n\x0c\n\x05\
    \x04\x05\x02\x01\x05\x12\x03_\x02\x07\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03_\x10\x16\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03_\x1b\x1c\n\x0b\
    \n\x04\x04\x05\x02\x02\x12\x03`\x02\x1d\n\x0c\n\x05\x04\x05\x02\x02\x05\
    \x12\x03`\x02\x07\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03`\x10\x15\n\x0c\
    \n\x05\x04\x05\x02\x02\x03\x12\x03`\x1b\x1c\n$\n\x04\x04\x05\x02\x03\x12\
    \x04a\x02bI\"\x16\x20zero\x20if\x20vote\x20is\x20nil.\n\n\x0c\n\x05\x04\
    \x05\x02\x03\x06\x12\x03a\x02\t\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03a\
    \x10\x18\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03a\x1b\x1c\n\x0c\n\x05\
    \x04\x05\x02\x03\x08\x12\x03b\x06H\n\x0f\n\x08\x04\x05\x02\x03\x08\xe9\
    \xfb\x03\x12\x03b\x07#\n\x0f\n\x08\x04\x05\x02\x03\x08\xec\xfb\x03\x12\
    \x03b%G\n\x0c\n\x04\x04\x05\x02\x04\x12\x04c\x02dA\n\x0c\n\x05\x04\x05\
    \x02\x04\x06\x12\x03c\x02\x1b\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03c\
    \x1c%\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03c()\n\x0c\n\x05\x04\x05\x02\
    \x04\x08\x12\x03d\x06@\n\x0f\n\x08\x04\x05\x02\x04\x08\xe9\xfb\x03\x12\
    \x03d\x07#\n\x0f\n\x08\x04\x05\x02\x04\x08\xf2\xfb\x03\x12\x03d%?\n\x0b\
    \n\x04\x04\x05\x02\x05\x12\x03e\x02\x1e\n\x0c\n\x05\x04\x05\x02\x05\x05\
    \x12\x03e\x02\x07\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03e\x08\x19\n\x0c\
    \n\x05\x04\x05\x02\x05\x03\x12\x03e\x1c\x1d\n\x0b\n\x04\x04\x05\x02\x06\
    \x12\x03f\x02\x1e\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\x03f\x02\x07\n\x0c\
    \n\x05\x04\x05\x02\x06\x01\x12\x03f\x08\x17\n\x0c\n\x05\x04\x05\x02\x06\
    \x03\x12\x03f\x1c\x1d\n\x0b\n\x04\x04\x05\x02\x07\x12\x03g\x02\x1e\n\x0c\
    \n\x05\x04\x05\x02\x07\x05\x12\x03g\x02\x07\n\x0c\n\x05\x04\x05\x02\x07\
    \x01\x12\x03g\x08\x11\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03g\x1c\x1d\n\
    ]\n\x02\x04\x06\x12\x04k\0p\x01\x1aQ\x20Commit\x20contains\x20the\x20evi\
    dence\x20that\x20a\x20block\x20was\x20committed\x20by\x20a\x20set\x20of\
    \x20validators.\n\n\n\n\x03\x04\x06\x01\x12\x03k\x08\x0e\n\x0b\n\x04\x04\
    \x06\x02\0\x12\x03l\x02/\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03l\x02\x07\
    \n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03l\x20&\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03l-.\n\x0b\n\x04\x04\x06\x02\x01\x12\x03m\x02/\n\x0c\n\x05\
    \x04\x06\x02\x01\x05\x12\x03m\x02\x07\n\x0c\n\x05\x04\x06\x02\x01\x01\
    \x12\x03m\x20%\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03m-.\n\x0b\n\x04\
    \x04\x06\x02\x02\x12\x03n\x02r\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03n\
    \x02\t\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03n\x20(\n\x0c\n\x05\x04\x06\
    \x02\x02\x03\x12\x03n-.\n\x0c\n\x05\x04\x06\x02\x02\x08\x12\x03n/q\n\x0f\
    \n\x08\x04\x06\x02\x02\x08\xe9\xfb\x03\x12\x03n0L\n\x0f\n\x08\x04\x06\
    \x02\x02\x08\xec\xfb\x03\x12\x03nNp\n\x0b\n\x04\x04\x06\x02\x03\x12\x03o\
    \x02N\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\x06\
    \x02\x03\x06\x12\x03o\x0b\x14\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03o\
    \x20*\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03o-.\n\x0c\n\x05\x04\x06\x02\
    \x03\x08\x12\x03o/M\n\x0f\n\x08\x04\x06\x02\x03\x08\xe9\xfb\x03\x12\x03o\
    0L\nC\n\x02\x04\x07\x12\x04s\0y\x01\x1a7\x20CommitSig\x20is\x20a\x20part\
    \x20of\x20the\x20Vote\x20included\x20in\x20a\x20Commit.\n\n\n\n\x03\x04\
    \x07\x01\x12\x03s\x08\x11\n\x0b\n\x04\x04\x07\x02\0\x12\x03t\x022\n\x0c\
    \n\x05\x04\x07\x02\0\x06\x12\x03t\x02\r\n\x0c\n\x05\x04\x07\x02\0\x01\
    \x12\x03t\x1c)\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03t01\n\x0b\n\x04\x04\
    \x07\x02\x01\x12\x03u\x022\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03u\x02\
    \x07\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03u\x1c-\n\x0c\n\x05\x04\x07\
    \x02\x01\x03\x12\x03u01\n\x0c\n\x04\x04\x07\x02\x02\x12\x04v\x02wA\n\x0c\
    \n\x05\x04\x07\x02\x02\x06\x12\x03v\x02\x1b\n\x0c\n\x05\x04\x07\x02\x02\
    \x01\x12\x03v\x1c%\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03v01\n\x0c\n\
    \x05\x04\x07\x02\x02\x08\x12\x03w\x06@\n\x0f\n\x08\x04\x07\x02\x02\x08\
    \xe9\xfb\x03\x12\x03w\x07#\n\x0f\n\x08\x04\x07\x02\x02\x08\xf2\xfb\x03\
    \x12\x03w%?\n\x0b\n\x04\x04\x07\x02\x03\x12\x03x\x02\x16\n\x0c\n\x05\x04\
    \x07\x02\x03\x05\x12\x03x\x02\x07\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\
    \x03x\x08\x11\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03x\x14\x15\n\x0b\n\
    \x02\x04\x08\x12\x05{\0\x84\x01\x01\n\n\n\x03\x04\x08\x01\x12\x03{\x08\
    \x10\n\x0b\n\x04\x04\x08\x02\0\x12\x03|\x02*\n\x0c\n\x05\x04\x08\x02\0\
    \x06\x12\x03|\x02\x0f\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03|\x1c\x20\n\
    \x0c\n\x05\x04\x08\x02\0\x03\x12\x03|()\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03}\x02*\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03}\x02\x07\n\x0c\n\x05\
    \x04\x08\x02\x01\x01\x12\x03}\x1c\"\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\
    \x03}()\n\x0b\n\x04\x04\x08\x02\x02\x12\x03~\x02*\n\x0c\n\x05\x04\x08\
    \x02\x02\x05\x12\x03~\x02\x07\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03~\
    \x1c!\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03~()\n\x0b\n\x04\x04\x08\x02\
    \x03\x12\x03\x7f\x02*\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03\x7f\x02\
    \x07\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03\x7f\x1c%\n\x0c\n\x05\x04\
    \x08\x02\x03\x03\x12\x03\x7f()\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\x80\
    \x01\x02m\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\x80\x01\x02\t\n\r\n\x05\
    \x04\x08\x02\x04\x01\x12\x04\x80\x01\x1c$\n\r\n\x05\x04\x08\x02\x04\x03\
    \x12\x04\x80\x01()\n\r\n\x05\x04\x08\x02\x04\x08\x12\x04\x80\x01*l\n\x10\
    \n\x08\x04\x08\x02\x04\x08\xec\xfb\x03\x12\x04\x80\x01+M\n\x10\n\x08\x04\
    \x08\x02\x04\x08\xe9\xfb\x03\x12\x04\x80\x01Ok\n\x0e\n\x04\x04\x08\x02\
    \x05\x12\x06\x81\x01\x02\x82\x01A\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\
    \x81\x01\x02\x1b\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\x81\x01\x1c%\n\r\
    \n\x05\x04\x08\x02\x05\x03\x12\x04\x81\x01()\n\r\n\x05\x04\x08\x02\x05\
    \x08\x12\x04\x82\x01\x06@\n\x10\n\x08\x04\x08\x02\x05\x08\xe9\xfb\x03\
    \x12\x04\x82\x01\x07#\n\x10\n\x08\x04\x08\x02\x05\x08\xf2\xfb\x03\x12\
    \x04\x82\x01%?\n\x0c\n\x04\x04\x08\x02\x06\x12\x04\x83\x01\x02\x16\n\r\n\
    \x05\x04\x08\x02\x06\x05\x12\x04\x83\x01\x02\x07\n\r\n\x05\x04\x08\x02\
    \x06\x01\x12\x04\x83\x01\x08\x11\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\
    \x83\x01\x14\x15\n\x0c\n\x02\x04\t\x12\x06\x86\x01\0\x89\x01\x01\n\x0b\n\
    \x03\x04\t\x01\x12\x04\x86\x01\x08\x14\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \x87\x01\x02\x14\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x87\x01\x02\x08\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\x87\x01\t\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\x87\x01\x12\x13\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x88\x01\x02\x14\n\
    \r\n\x05\x04\t\x02\x01\x06\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\x88\x01\t\x0f\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x88\
    \x01\x12\x13\n\x0c\n\x02\x04\n\x12\x06\x8b\x01\0\x8e\x01\x01\n\x0b\n\x03\
    \x04\n\x01\x12\x04\x8b\x01\x08\x12\n\x0c\n\x04\x04\n\x02\0\x12\x04\x8c\
    \x01\x022\n\r\n\x05\x04\n\x02\0\x06\x12\x04\x8c\x01\x02\x0e\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\x8c\x01\x20-\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \x8c\x0101\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x8d\x01\x022\n\r\n\x05\x04\
    \n\x02\x01\x06\x12\x04\x8d\x01\x02\x1f\n\r\n\x05\x04\n\x02\x01\x01\x12\
    \x04\x8d\x01\x20-\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x8d\x0101\n\x0c\n\
    \x02\x04\x0b\x12\x06\x90\x01\0\x95\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\x90\x01\x08\x11\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x91\x01\x02\\\n\r\
    \n\x05\x04\x0b\x02\0\x06\x12\x04\x91\x01\x02\t\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\x91\x01\n\x12\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x91\x01\
    \x17\x18\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\x91\x01\x19[\n\x10\n\x08\
    \x04\x0b\x02\0\x08\xec\xfb\x03\x12\x04\x91\x01\x1a<\n\x10\n\x08\x04\x0b\
    \x02\0\x08\xe9\xfb\x03\x12\x04\x91\x01>Z\n\x0c\n\x04\x04\x0b\x02\x01\x12\
    \x04\x92\x01\x02\x19\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x92\x01\x02\
    \x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x92\x01\n\x14\n\r\n\x05\x04\
    \x0b\x02\x01\x03\x12\x04\x92\x01\x17\x18\n\x0c\n\x04\x04\x0b\x02\x02\x12\
    \x04\x93\x01\x028\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\x93\x01\x02\x08\
    \n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x93\x01\n\x10\n\r\n\x05\x04\x0b\
    \x02\x02\x03\x12\x04\x93\x01\x17\x18\n\r\n\x05\x04\x0b\x02\x02\x08\x12\
    \x04\x93\x01\x197\n\x10\n\x08\x04\x0b\x02\x02\x08\xe9\xfb\x03\x12\x04\
    \x93\x01\x1a6\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\x94\x01\x02\x19\n\r\n\
    \x05\x04\x0b\x02\x03\x05\x12\x04\x94\x01\x02\x07\n\r\n\x05\x04\x0b\x02\
    \x03\x01\x12\x04\x94\x01\n\x11\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x94\
    \x01\x17\x18\nf\n\x02\x04\x0c\x12\x06\x98\x01\0\x9c\x01\x01\x1aX\x20TxPr\
    oof\x20represents\x20a\x20Merkle\x20proof\x20of\x20the\x20presence\x20of\
    \x20a\x20transaction\x20in\x20the\x20Merkle\x20tree.\n\n\x0b\n\x03\x04\
    \x0c\x01\x12\x04\x98\x01\x08\x0f\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x99\
    \x01\x02(\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x99\x01\x02\x07\n\r\n\x05\
    \x04\x0c\x02\0\x01\x12\x04\x99\x01\x1a#\n\r\n\x05\x04\x0c\x02\0\x03\x12\
    \x04\x99\x01&'\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x9a\x01\x02(\n\r\n\
    \x05\x04\x0c\x02\x01\x05\x12\x04\x9a\x01\x02\x07\n\r\n\x05\x04\x0c\x02\
    \x01\x01\x12\x04\x9a\x01\x1a\x1e\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \x9a\x01&'\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\x9b\x01\x02(\n\r\n\x05\
    \x04\x0c\x02\x02\x06\x12\x04\x9b\x01\x02\x19\n\r\n\x05\x04\x0c\x02\x02\
    \x01\x12\x04\x9b\x01\x1a\x1f\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x9b\
    \x01&'b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::proof::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(super::validator::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(13);
            messages.push(PartSetHeader::generated_message_descriptor_data());
            messages.push(Part::generated_message_descriptor_data());
            messages.push(BlockID::generated_message_descriptor_data());
            messages.push(Header::generated_message_descriptor_data());
            messages.push(Data::generated_message_descriptor_data());
            messages.push(Vote::generated_message_descriptor_data());
            messages.push(Commit::generated_message_descriptor_data());
            messages.push(CommitSig::generated_message_descriptor_data());
            messages.push(Proposal::generated_message_descriptor_data());
            messages.push(SignedHeader::generated_message_descriptor_data());
            messages.push(LightBlock::generated_message_descriptor_data());
            messages.push(BlockMeta::generated_message_descriptor_data());
            messages.push(TxProof::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(BlockIDFlag::generated_enum_descriptor_data());
            enums.push(SignedMsgType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
