// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tendermint/types/params.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  ConsensusParams contains consensus critical parameters that determine the
///  validity of blocks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.ConsensusParams)
pub struct ConsensusParams {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.ConsensusParams.block)
    pub block: ::protobuf::MessageField<BlockParams>,
    // @@protoc_insertion_point(field:tendermint.types.ConsensusParams.evidence)
    pub evidence: ::protobuf::MessageField<EvidenceParams>,
    // @@protoc_insertion_point(field:tendermint.types.ConsensusParams.validator)
    pub validator: ::protobuf::MessageField<ValidatorParams>,
    // @@protoc_insertion_point(field:tendermint.types.ConsensusParams.version)
    pub version: ::protobuf::MessageField<VersionParams>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.ConsensusParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConsensusParams {
    fn default() -> &'a ConsensusParams {
        <ConsensusParams as ::protobuf::Message>::default_instance()
    }
}

impl ConsensusParams {
    pub fn new() -> ConsensusParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockParams>(
            "block",
            |m: &ConsensusParams| { &m.block },
            |m: &mut ConsensusParams| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EvidenceParams>(
            "evidence",
            |m: &ConsensusParams| { &m.evidence },
            |m: &mut ConsensusParams| { &mut m.evidence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatorParams>(
            "validator",
            |m: &ConsensusParams| { &m.validator },
            |m: &mut ConsensusParams| { &mut m.validator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VersionParams>(
            "version",
            |m: &ConsensusParams| { &m.version },
            |m: &mut ConsensusParams| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConsensusParams>(
            "ConsensusParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConsensusParams {
    const NAME: &'static str = "ConsensusParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.evidence)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.validator)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.evidence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.validator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.evidence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.validator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConsensusParams {
        ConsensusParams::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.evidence.clear();
        self.validator.clear();
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConsensusParams {
        static instance: ConsensusParams = ConsensusParams {
            block: ::protobuf::MessageField::none(),
            evidence: ::protobuf::MessageField::none(),
            validator: ::protobuf::MessageField::none(),
            version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConsensusParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConsensusParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConsensusParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BlockParams contains limits on the block size.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.BlockParams)
pub struct BlockParams {
    // message fields
    ///  Max block size, in bytes.
    ///  Note: must be greater than 0
    // @@protoc_insertion_point(field:tendermint.types.BlockParams.max_bytes)
    pub max_bytes: i64,
    ///  Max gas per block.
    ///  Note: must be greater or equal to -1
    // @@protoc_insertion_point(field:tendermint.types.BlockParams.max_gas)
    pub max_gas: i64,
    ///  Minimum time increment between consecutive blocks (in milliseconds) If the
    ///  block header timestamp is ahead of the system clock, decrease this value.
    ///
    ///  Not exposed to the application.
    // @@protoc_insertion_point(field:tendermint.types.BlockParams.time_iota_ms)
    pub time_iota_ms: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.BlockParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockParams {
    fn default() -> &'a BlockParams {
        <BlockParams as ::protobuf::Message>::default_instance()
    }
}

impl BlockParams {
    pub fn new() -> BlockParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_bytes",
            |m: &BlockParams| { &m.max_bytes },
            |m: &mut BlockParams| { &mut m.max_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_gas",
            |m: &BlockParams| { &m.max_gas },
            |m: &mut BlockParams| { &mut m.max_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_iota_ms",
            |m: &BlockParams| { &m.time_iota_ms },
            |m: &mut BlockParams| { &mut m.time_iota_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockParams>(
            "BlockParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockParams {
    const NAME: &'static str = "BlockParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_bytes = is.read_int64()?;
                },
                16 => {
                    self.max_gas = is.read_int64()?;
                },
                24 => {
                    self.time_iota_ms = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.max_bytes != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.max_bytes);
        }
        if self.max_gas != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.max_gas);
        }
        if self.time_iota_ms != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.time_iota_ms);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.max_bytes != 0 {
            os.write_int64(1, self.max_bytes)?;
        }
        if self.max_gas != 0 {
            os.write_int64(2, self.max_gas)?;
        }
        if self.time_iota_ms != 0 {
            os.write_int64(3, self.time_iota_ms)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockParams {
        BlockParams::new()
    }

    fn clear(&mut self) {
        self.max_bytes = 0;
        self.max_gas = 0;
        self.time_iota_ms = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockParams {
        static instance: BlockParams = BlockParams {
            max_bytes: 0,
            max_gas: 0,
            time_iota_ms: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  EvidenceParams determine how we handle evidence of malfeasance.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.EvidenceParams)
pub struct EvidenceParams {
    // message fields
    ///  Max age of evidence, in blocks.
    ///
    ///  The basic formula for calculating this is: MaxAgeDuration / {average block
    ///  time}.
    // @@protoc_insertion_point(field:tendermint.types.EvidenceParams.max_age_num_blocks)
    pub max_age_num_blocks: i64,
    ///  Max age of evidence, in time.
    ///
    ///  It should correspond with an app's "unbonding period" or other similar
    ///  mechanism for handling [Nothing-At-Stake
    ///  attacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed).
    // @@protoc_insertion_point(field:tendermint.types.EvidenceParams.max_age_duration)
    pub max_age_duration: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    ///  This sets the maximum size of total evidence in bytes that can be committed in a single block.
    ///  and should fall comfortably under the max block bytes.
    ///  Default is 1048576 or 1MB
    // @@protoc_insertion_point(field:tendermint.types.EvidenceParams.max_bytes)
    pub max_bytes: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.EvidenceParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvidenceParams {
    fn default() -> &'a EvidenceParams {
        <EvidenceParams as ::protobuf::Message>::default_instance()
    }
}

impl EvidenceParams {
    pub fn new() -> EvidenceParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_age_num_blocks",
            |m: &EvidenceParams| { &m.max_age_num_blocks },
            |m: &mut EvidenceParams| { &mut m.max_age_num_blocks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "max_age_duration",
            |m: &EvidenceParams| { &m.max_age_duration },
            |m: &mut EvidenceParams| { &mut m.max_age_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_bytes",
            |m: &EvidenceParams| { &m.max_bytes },
            |m: &mut EvidenceParams| { &mut m.max_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvidenceParams>(
            "EvidenceParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvidenceParams {
    const NAME: &'static str = "EvidenceParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_age_num_blocks = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_age_duration)?;
                },
                24 => {
                    self.max_bytes = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.max_age_num_blocks != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.max_age_num_blocks);
        }
        if let Some(v) = self.max_age_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.max_bytes != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.max_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.max_age_num_blocks != 0 {
            os.write_int64(1, self.max_age_num_blocks)?;
        }
        if let Some(v) = self.max_age_duration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.max_bytes != 0 {
            os.write_int64(3, self.max_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvidenceParams {
        EvidenceParams::new()
    }

    fn clear(&mut self) {
        self.max_age_num_blocks = 0;
        self.max_age_duration.clear();
        self.max_bytes = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvidenceParams {
        static instance: EvidenceParams = EvidenceParams {
            max_age_num_blocks: 0,
            max_age_duration: ::protobuf::MessageField::none(),
            max_bytes: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvidenceParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvidenceParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvidenceParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvidenceParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ValidatorParams restrict the public key types validators can use.
///  NOTE: uses ABCI pubkey naming, not Amino names.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.ValidatorParams)
pub struct ValidatorParams {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.ValidatorParams.pub_key_types)
    pub pub_key_types: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.ValidatorParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatorParams {
    fn default() -> &'a ValidatorParams {
        <ValidatorParams as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorParams {
    pub fn new() -> ValidatorParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pub_key_types",
            |m: &ValidatorParams| { &m.pub_key_types },
            |m: &mut ValidatorParams| { &mut m.pub_key_types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatorParams>(
            "ValidatorParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatorParams {
    const NAME: &'static str = "ValidatorParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pub_key_types.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pub_key_types {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pub_key_types {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatorParams {
        ValidatorParams::new()
    }

    fn clear(&mut self) {
        self.pub_key_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatorParams {
        static instance: ValidatorParams = ValidatorParams {
            pub_key_types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatorParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatorParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatorParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  VersionParams contains the ABCI application version.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.VersionParams)
pub struct VersionParams {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.VersionParams.app_version)
    pub app_version: u64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.VersionParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VersionParams {
    fn default() -> &'a VersionParams {
        <VersionParams as ::protobuf::Message>::default_instance()
    }
}

impl VersionParams {
    pub fn new() -> VersionParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_version",
            |m: &VersionParams| { &m.app_version },
            |m: &mut VersionParams| { &mut m.app_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionParams>(
            "VersionParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VersionParams {
    const NAME: &'static str = "VersionParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_version = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.app_version != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.app_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.app_version != 0 {
            os.write_uint64(1, self.app_version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VersionParams {
        VersionParams::new()
    }

    fn clear(&mut self) {
        self.app_version = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VersionParams {
        static instance: VersionParams = VersionParams {
            app_version: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VersionParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VersionParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VersionParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  HashedParams is a subset of ConsensusParams.
///
///  It is hashed into the Header.ConsensusHash.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.types.HashedParams)
pub struct HashedParams {
    // message fields
    // @@protoc_insertion_point(field:tendermint.types.HashedParams.block_max_bytes)
    pub block_max_bytes: i64,
    // @@protoc_insertion_point(field:tendermint.types.HashedParams.block_max_gas)
    pub block_max_gas: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.types.HashedParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HashedParams {
    fn default() -> &'a HashedParams {
        <HashedParams as ::protobuf::Message>::default_instance()
    }
}

impl HashedParams {
    pub fn new() -> HashedParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_max_bytes",
            |m: &HashedParams| { &m.block_max_bytes },
            |m: &mut HashedParams| { &mut m.block_max_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_max_gas",
            |m: &HashedParams| { &m.block_max_gas },
            |m: &mut HashedParams| { &mut m.block_max_gas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HashedParams>(
            "HashedParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HashedParams {
    const NAME: &'static str = "HashedParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.block_max_bytes = is.read_int64()?;
                },
                16 => {
                    self.block_max_gas = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.block_max_bytes != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.block_max_bytes);
        }
        if self.block_max_gas != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.block_max_gas);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.block_max_bytes != 0 {
            os.write_int64(1, self.block_max_bytes)?;
        }
        if self.block_max_gas != 0 {
            os.write_int64(2, self.block_max_gas)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HashedParams {
        HashedParams::new()
    }

    fn clear(&mut self) {
        self.block_max_bytes = 0;
        self.block_max_gas = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HashedParams {
        static instance: HashedParams = HashedParams {
            block_max_bytes: 0,
            block_max_gas: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HashedParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HashedParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HashedParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashedParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dtendermint/types/params.proto\x12\x10tendermint.types\x1a\x14gogop\
    roto/gogo.proto\x1a\x1egoogle/protobuf/duration.proto\"\x98\x02\n\x0fCon\
    sensusParams\x129\n\x05block\x18\x01\x20\x01(\x0b2\x1d.tendermint.types.\
    BlockParamsR\x05blockB\x04\xc8\xde\x1f\0\x12B\n\x08evidence\x18\x02\x20\
    \x01(\x0b2\x20.tendermint.types.EvidenceParamsR\x08evidenceB\x04\xc8\xde\
    \x1f\0\x12E\n\tvalidator\x18\x03\x20\x01(\x0b2!.tendermint.types.Validat\
    orParamsR\tvalidatorB\x04\xc8\xde\x1f\0\x12?\n\x07version\x18\x04\x20\
    \x01(\x0b2\x1f.tendermint.types.VersionParamsR\x07versionB\x04\xc8\xde\
    \x1f\0\"e\n\x0bBlockParams\x12\x1b\n\tmax_bytes\x18\x01\x20\x01(\x03R\
    \x08maxBytes\x12\x17\n\x07max_gas\x18\x02\x20\x01(\x03R\x06maxGas\x12\
    \x20\n\x0ctime_iota_ms\x18\x03\x20\x01(\x03R\ntimeIotaMs\"\xa9\x01\n\x0e\
    EvidenceParams\x12+\n\x12max_age_num_blocks\x18\x01\x20\x01(\x03R\x0fmax\
    AgeNumBlocks\x12M\n\x10max_age_duration\x18\x02\x20\x01(\x0b2\x19.google\
    .protobuf.DurationR\x0emaxAgeDurationB\x08\xc8\xde\x1f\0\x98\xdf\x1f\x01\
    \x12\x1b\n\tmax_bytes\x18\x03\x20\x01(\x03R\x08maxBytes\"?\n\x0fValidato\
    rParams\x12\"\n\rpub_key_types\x18\x01\x20\x03(\tR\x0bpubKeyTypes:\x08\
    \xe8\xa0\x1f\x01\xb8\xa0\x1f\x01\":\n\rVersionParams\x12\x1f\n\x0bapp_ve\
    rsion\x18\x01\x20\x01(\x04R\nappVersion:\x08\xe8\xa0\x1f\x01\xb8\xa0\x1f\
    \x01\"Z\n\x0cHashedParams\x12&\n\x0fblock_max_bytes\x18\x01\x20\x01(\x03\
    R\rblockMaxBytes\x12\"\n\rblock_max_gas\x18\x02\x20\x01(\x03R\x0bblockMa\
    xGasB=Z7github.com/tendermint/tendermint/proto/tendermint/types\xa8\xe2\
    \x1e\x01J\xf7\x14\n\x06\x12\x04\0\0O\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\
    \n\x08\n\x01\x02\x12\x03\x01\0\x19\n\x08\n\x01\x08\x12\x03\x03\0N\n\t\n\
    \x02\x08\x0b\x12\x03\x03\0N\n\t\n\x02\x03\0\x12\x03\x05\0\x1e\n\t\n\x02\
    \x03\x01\x12\x03\x06\0(\n\x08\n\x01\x08\x12\x03\x08\0$\n\x0b\n\x04\x08\
    \xa5\xec\x03\x12\x03\x08\0$\nl\n\x02\x04\0\x12\x04\x0c\0\x11\x01\x1a`\
    \x20ConsensusParams\x20contains\x20consensus\x20critical\x20parameters\
    \x20that\x20determine\x20the\n\x20validity\x20of\x20blocks.\n\n\n\n\x03\
    \x04\0\x01\x12\x03\x0c\x08\x17\n\x0b\n\x04\x04\0\x02\0\x12\x03\r\x02?\n\
    \x0c\n\x05\x04\0\x02\0\x06\x12\x03\r\x02\r\n\x0c\n\x05\x04\0\x02\0\x01\
    \x12\x03\r\x12\x17\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\r\x1e\x1f\n\x0c\n\
    \x05\x04\0\x02\0\x08\x12\x03\r\x20>\n\x0f\n\x08\x04\0\x02\0\x08\xe9\xfb\
    \x03\x12\x03\r!=\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x0e\x02?\n\x0c\n\x05\
    \x04\0\x02\x01\x06\x12\x03\x0e\x02\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\
    \x03\x0e\x12\x1a\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0e\x1e\x1f\n\x0c\
    \n\x05\x04\0\x02\x01\x08\x12\x03\x0e\x20>\n\x0f\n\x08\x04\0\x02\x01\x08\
    \xe9\xfb\x03\x12\x03\x0e!=\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x0f\x02?\n\
    \x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x0f\x02\x11\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03\x0f\x12\x1b\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x0f\
    \x1e\x1f\n\x0c\n\x05\x04\0\x02\x02\x08\x12\x03\x0f\x20>\n\x0f\n\x08\x04\
    \0\x02\x02\x08\xe9\xfb\x03\x12\x03\x0f!=\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03\x10\x02?\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x10\x02\x0f\n\x0c\n\
    \x05\x04\0\x02\x03\x01\x12\x03\x10\x12\x19\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x03\x10\x1e\x1f\n\x0c\n\x05\x04\0\x02\x03\x08\x12\x03\x10\x20>\n\
    \x0f\n\x08\x04\0\x02\x03\x08\xe9\xfb\x03\x12\x03\x10!=\n<\n\x02\x04\x01\
    \x12\x04\x14\0\x20\x01\x1a0\x20BlockParams\x20contains\x20limits\x20on\
    \x20the\x20block\x20size.\n\n\n\n\x03\x04\x01\x01\x12\x03\x14\x08\x13\nF\
    \n\x04\x04\x01\x02\0\x12\x03\x17\x02\x16\x1a9\x20Max\x20block\x20size,\
    \x20in\x20bytes.\n\x20Note:\x20must\x20be\x20greater\x20than\x200\n\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x17\x02\x07\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x17\x08\x11\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x17\x14\
    \x15\nG\n\x04\x04\x01\x02\x01\x12\x03\x1a\x02\x14\x1a:\x20Max\x20gas\x20\
    per\x20block.\n\x20Note:\x20must\x20be\x20greater\x20or\x20equal\x20to\
    \x20-1\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x1a\x02\x07\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03\x1a\x08\x0f\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03\x1a\x12\x13\n\xc7\x01\n\x04\x04\x01\x02\x02\x12\x03\x1f\x02\x19\
    \x1a\xb9\x01\x20Minimum\x20time\x20increment\x20between\x20consecutive\
    \x20blocks\x20(in\x20milliseconds)\x20If\x20the\n\x20block\x20header\x20\
    timestamp\x20is\x20ahead\x20of\x20the\x20system\x20clock,\x20decrease\
    \x20this\x20value.\n\n\x20Not\x20exposed\x20to\x20the\x20application.\n\
    \n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x1f\x02\x07\n\x0c\n\x05\x04\x01\
    \x02\x02\x01\x12\x03\x1f\x08\x14\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\
    \x1f\x17\x18\nM\n\x02\x04\x02\x12\x04#\06\x01\x1aA\x20EvidenceParams\x20\
    determine\x20how\x20we\x20handle\x20evidence\x20of\x20malfeasance.\n\n\n\
    \n\x03\x04\x02\x01\x12\x03#\x08\x16\n\x83\x01\n\x04\x04\x02\x02\0\x12\
    \x03(\x02\x1f\x1av\x20Max\x20age\x20of\x20evidence,\x20in\x20blocks.\n\n\
    \x20The\x20basic\x20formula\x20for\x20calculating\x20this\x20is:\x20MaxA\
    geDuration\x20/\x20{average\x20block\n\x20time}.\n\n\x0c\n\x05\x04\x02\
    \x02\0\x05\x12\x03(\x02\x07\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03(\x08\
    \x1a\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03(\x1d\x1e\n\xa3\x02\n\x04\x04\
    \x02\x02\x01\x12\x04/\x020E\x1a\x94\x02\x20Max\x20age\x20of\x20evidence,\
    \x20in\x20time.\n\n\x20It\x20should\x20correspond\x20with\x20an\x20app's\
    \x20\"unbonding\x20period\"\x20or\x20other\x20similar\n\x20mechanism\x20\
    for\x20handling\x20[Nothing-At-Stake\n\x20attacks](https://github.com/et\
    hereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem\
    -and-how-can-it-be-fixed).\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03/\
    \x02\x1a\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03/\x1b+\n\x0c\n\x05\x04\
    \x02\x02\x01\x03\x12\x03/./\n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x030\x06\
    D\n\x0f\n\x08\x04\x02\x02\x01\x08\xe9\xfb\x03\x12\x030\x07#\n\x0f\n\x08\
    \x04\x02\x02\x01\x08\xf3\xfb\x03\x12\x030%C\n\xc1\x01\n\x04\x04\x02\x02\
    \x02\x12\x035\x02\x16\x1a\xb3\x01\x20This\x20sets\x20the\x20maximum\x20s\
    ize\x20of\x20total\x20evidence\x20in\x20bytes\x20that\x20can\x20be\x20co\
    mmitted\x20in\x20a\x20single\x20block.\n\x20and\x20should\x20fall\x20com\
    fortably\x20under\x20the\x20max\x20block\x20bytes.\n\x20Default\x20is\
    \x201048576\x20or\x201MB\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x035\x02\
    \x07\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x035\x08\x11\n\x0c\n\x05\x04\
    \x02\x02\x02\x03\x12\x035\x14\x15\n\x80\x01\n\x02\x04\x03\x12\x04:\0?\
    \x01\x1at\x20ValidatorParams\x20restrict\x20the\x20public\x20key\x20type\
    s\x20validators\x20can\x20use.\n\x20NOTE:\x20uses\x20ABCI\x20pubkey\x20n\
    aming,\x20not\x20Amino\x20names.\n\n\n\n\x03\x04\x03\x01\x12\x03:\x08\
    \x17\n\n\n\x03\x04\x03\x07\x12\x03;\x02%\n\r\n\x06\x04\x03\x07\x87\xf4\
    \x03\x12\x03;\x02%\n\n\n\x03\x04\x03\x07\x12\x03<\x02%\n\r\n\x06\x04\x03\
    \x07\x8d\xf4\x03\x12\x03<\x02%\n\x0b\n\x04\x04\x03\x02\0\x12\x03>\x02$\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x03>\x02\n\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x03>\x0b\x11\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03>\x12\x1f\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03>\"#\nB\n\x02\x04\x04\x12\x04B\0G\
    \x01\x1a6\x20VersionParams\x20contains\x20the\x20ABCI\x20application\x20\
    version.\n\n\n\n\x03\x04\x04\x01\x12\x03B\x08\x15\n\n\n\x03\x04\x04\x07\
    \x12\x03C\x02%\n\r\n\x06\x04\x04\x07\x87\xf4\x03\x12\x03C\x02%\n\n\n\x03\
    \x04\x04\x07\x12\x03D\x02%\n\r\n\x06\x04\x04\x07\x8d\xf4\x03\x12\x03D\
    \x02%\n\x0b\n\x04\x04\x04\x02\0\x12\x03F\x02\x19\n\x0c\n\x05\x04\x04\x02\
    \0\x05\x12\x03F\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03F\t\x14\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03F\x17\x18\nh\n\x02\x04\x05\x12\x04L\
    \0O\x01\x1a\\\x20HashedParams\x20is\x20a\x20subset\x20of\x20ConsensusPar\
    ams.\n\n\x20It\x20is\x20hashed\x20into\x20the\x20Header.ConsensusHash.\n\
    \n\n\n\x03\x04\x05\x01\x12\x03L\x08\x14\n\x0b\n\x04\x04\x05\x02\0\x12\
    \x03M\x02\x1c\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03M\x02\x07\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03M\x08\x17\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03M\x1a\x1b\n\x0b\n\x04\x04\x05\x02\x01\x12\x03N\x02\x1c\n\x0c\n\x05\
    \x04\x05\x02\x01\x05\x12\x03N\x02\x07\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03N\x08\x15\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03N\x1a\x1bb\x06p\
    roto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(ConsensusParams::generated_message_descriptor_data());
            messages.push(BlockParams::generated_message_descriptor_data());
            messages.push(EvidenceParams::generated_message_descriptor_data());
            messages.push(ValidatorParams::generated_message_descriptor_data());
            messages.push(VersionParams::generated_message_descriptor_data());
            messages.push(HashedParams::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
