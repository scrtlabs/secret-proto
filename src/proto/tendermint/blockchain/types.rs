// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tendermint/blockchain/types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  BlockRequest requests a block for a specific height
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.blockchain.BlockRequest)
pub struct BlockRequest {
    // message fields
    // @@protoc_insertion_point(field:tendermint.blockchain.BlockRequest.height)
    pub height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.blockchain.BlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockRequest {
    fn default() -> &'a BlockRequest {
        <BlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockRequest {
    pub fn new() -> BlockRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &BlockRequest| { &m.height },
            |m: &mut BlockRequest| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockRequest>(
            "BlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockRequest {
    const NAME: &'static str = "BlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockRequest {
        BlockRequest::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockRequest {
        static instance: BlockRequest = BlockRequest {
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  NoBlockResponse informs the node that the peer does not have block at the requested height
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.blockchain.NoBlockResponse)
pub struct NoBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:tendermint.blockchain.NoBlockResponse.height)
    pub height: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.blockchain.NoBlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoBlockResponse {
    fn default() -> &'a NoBlockResponse {
        <NoBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl NoBlockResponse {
    pub fn new() -> NoBlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &NoBlockResponse| { &m.height },
            |m: &mut NoBlockResponse| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoBlockResponse>(
            "NoBlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoBlockResponse {
    const NAME: &'static str = "NoBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoBlockResponse {
        NoBlockResponse::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoBlockResponse {
        static instance: NoBlockResponse = NoBlockResponse {
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoBlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoBlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoBlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BlockResponse returns block to the requested
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.blockchain.BlockResponse)
pub struct BlockResponse {
    // message fields
    // @@protoc_insertion_point(field:tendermint.blockchain.BlockResponse.block)
    pub block: ::protobuf::MessageField<super::block::Block>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.blockchain.BlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockResponse {
    fn default() -> &'a BlockResponse {
        <BlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockResponse {
    pub fn new() -> BlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::block::Block>(
            "block",
            |m: &BlockResponse| { &m.block },
            |m: &mut BlockResponse| { &mut m.block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockResponse>(
            "BlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockResponse {
    const NAME: &'static str = "BlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockResponse {
        BlockResponse::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockResponse {
        static instance: BlockResponse = BlockResponse {
            block: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StatusRequest requests the status of a peer.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.blockchain.StatusRequest)
pub struct StatusRequest {
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.blockchain.StatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusRequest {
    fn default() -> &'a StatusRequest {
        <StatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatusRequest {
    pub fn new() -> StatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusRequest>(
            "StatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusRequest {
    const NAME: &'static str = "StatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusRequest {
        StatusRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusRequest {
        static instance: StatusRequest = StatusRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StatusResponse is a peer response to inform their status.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.blockchain.StatusResponse)
pub struct StatusResponse {
    // message fields
    // @@protoc_insertion_point(field:tendermint.blockchain.StatusResponse.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.blockchain.StatusResponse.base)
    pub base: i64,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.blockchain.StatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusResponse {
    fn default() -> &'a StatusResponse {
        <StatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatusResponse {
    pub fn new() -> StatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &StatusResponse| { &m.height },
            |m: &mut StatusResponse| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base",
            |m: &StatusResponse| { &m.base },
            |m: &mut StatusResponse| { &mut m.base },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusResponse>(
            "StatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusResponse {
    const NAME: &'static str = "StatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.base = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.base != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.base);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.base != 0 {
            os.write_int64(2, self.base)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusResponse {
        StatusResponse::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.base = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusResponse {
        static instance: StatusResponse = StatusResponse {
            height: 0,
            base: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.blockchain.Message)
pub struct Message {
    // message oneof groups
    pub sum: ::std::option::Option<message::Sum>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.blockchain.Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .tendermint.blockchain.BlockRequest block_request = 1;

    pub fn block_request(&self) -> &BlockRequest {
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockRequest(ref v)) => v,
            _ => <BlockRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_request(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_block_request(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_request(&mut self, v: BlockRequest) {
        self.sum = ::std::option::Option::Some(message::Sum::BlockRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_request(&mut self) -> &mut BlockRequest {
        if let ::std::option::Option::Some(message::Sum::BlockRequest(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::BlockRequest(BlockRequest::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_request(&mut self) -> BlockRequest {
        if self.has_block_request() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::BlockRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockRequest::new()
        }
    }

    // .tendermint.blockchain.NoBlockResponse no_block_response = 2;

    pub fn no_block_response(&self) -> &NoBlockResponse {
        match self.sum {
            ::std::option::Option::Some(message::Sum::NoBlockResponse(ref v)) => v,
            _ => <NoBlockResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_no_block_response(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_no_block_response(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::NoBlockResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_no_block_response(&mut self, v: NoBlockResponse) {
        self.sum = ::std::option::Option::Some(message::Sum::NoBlockResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_no_block_response(&mut self) -> &mut NoBlockResponse {
        if let ::std::option::Option::Some(message::Sum::NoBlockResponse(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::NoBlockResponse(NoBlockResponse::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::NoBlockResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_no_block_response(&mut self) -> NoBlockResponse {
        if self.has_no_block_response() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::NoBlockResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            NoBlockResponse::new()
        }
    }

    // .tendermint.blockchain.BlockResponse block_response = 3;

    pub fn block_response(&self) -> &BlockResponse {
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockResponse(ref v)) => v,
            _ => <BlockResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_response(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_block_response(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_response(&mut self, v: BlockResponse) {
        self.sum = ::std::option::Option::Some(message::Sum::BlockResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_response(&mut self) -> &mut BlockResponse {
        if let ::std::option::Option::Some(message::Sum::BlockResponse(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::BlockResponse(BlockResponse::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_response(&mut self) -> BlockResponse {
        if self.has_block_response() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::BlockResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockResponse::new()
        }
    }

    // .tendermint.blockchain.StatusRequest status_request = 4;

    pub fn status_request(&self) -> &StatusRequest {
        match self.sum {
            ::std::option::Option::Some(message::Sum::StatusRequest(ref v)) => v,
            _ => <StatusRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_status_request(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_status_request(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::StatusRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_request(&mut self, v: StatusRequest) {
        self.sum = ::std::option::Option::Some(message::Sum::StatusRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_request(&mut self) -> &mut StatusRequest {
        if let ::std::option::Option::Some(message::Sum::StatusRequest(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::StatusRequest(StatusRequest::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::StatusRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_request(&mut self) -> StatusRequest {
        if self.has_status_request() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::StatusRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusRequest::new()
        }
    }

    // .tendermint.blockchain.StatusResponse status_response = 5;

    pub fn status_response(&self) -> &StatusResponse {
        match self.sum {
            ::std::option::Option::Some(message::Sum::StatusResponse(ref v)) => v,
            _ => <StatusResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_status_response(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_status_response(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::StatusResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_response(&mut self, v: StatusResponse) {
        self.sum = ::std::option::Option::Some(message::Sum::StatusResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_response(&mut self) -> &mut StatusResponse {
        if let ::std::option::Option::Some(message::Sum::StatusResponse(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::StatusResponse(StatusResponse::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::StatusResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_response(&mut self) -> StatusResponse {
        if self.has_status_response() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::StatusResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockRequest>(
            "block_request",
            Message::has_block_request,
            Message::block_request,
            Message::mut_block_request,
            Message::set_block_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NoBlockResponse>(
            "no_block_response",
            Message::has_no_block_response,
            Message::no_block_response,
            Message::mut_no_block_response,
            Message::set_no_block_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockResponse>(
            "block_response",
            Message::has_block_response,
            Message::block_response,
            Message::mut_block_response,
            Message::set_block_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatusRequest>(
            "status_request",
            Message::has_status_request,
            Message::status_request,
            Message::mut_status_request,
            Message::set_status_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatusResponse>(
            "status_response",
            Message::has_status_response,
            Message::status_response,
            Message::mut_status_response,
            Message::set_status_response,
        ));
        oneofs.push(message::Sum::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sum = ::std::option::Option::Some(message::Sum::BlockRequest(is.read_message()?));
                },
                18 => {
                    self.sum = ::std::option::Option::Some(message::Sum::NoBlockResponse(is.read_message()?));
                },
                26 => {
                    self.sum = ::std::option::Option::Some(message::Sum::BlockResponse(is.read_message()?));
                },
                34 => {
                    self.sum = ::std::option::Option::Some(message::Sum::StatusRequest(is.read_message()?));
                },
                42 => {
                    self.sum = ::std::option::Option::Some(message::Sum::StatusResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sum {
            match v {
                &message::Sum::BlockRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::NoBlockResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::BlockResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::StatusRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::StatusResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.sum {
            match v {
                &message::Sum::BlockRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &message::Sum::NoBlockResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &message::Sum::BlockResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &message::Sum::StatusRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &message::Sum::StatusResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            sum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:tendermint.blockchain.Message.sum)
    pub enum Sum {
        // @@protoc_insertion_point(oneof_field:tendermint.blockchain.Message.block_request)
        BlockRequest(super::BlockRequest),
        // @@protoc_insertion_point(oneof_field:tendermint.blockchain.Message.no_block_response)
        NoBlockResponse(super::NoBlockResponse),
        // @@protoc_insertion_point(oneof_field:tendermint.blockchain.Message.block_response)
        BlockResponse(super::BlockResponse),
        // @@protoc_insertion_point(oneof_field:tendermint.blockchain.Message.status_request)
        StatusRequest(super::StatusRequest),
        // @@protoc_insertion_point(oneof_field:tendermint.blockchain.Message.status_response)
        StatusResponse(super::StatusResponse),
    }

    impl ::protobuf::Oneof for Sum {
    }

    impl ::protobuf::OneofFull for Sum {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Message as ::protobuf::MessageFull>::descriptor().oneof_by_name("sum").unwrap()).clone()
        }
    }

    impl Sum {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sum>("sum")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!tendermint/blockchain/types.proto\x12\x15tendermint.blockchain\x1a\
    \x1ctendermint/types/block.proto\"&\n\x0cBlockRequest\x12\x16\n\x06heigh\
    t\x18\x01\x20\x01(\x03R\x06height\")\n\x0fNoBlockResponse\x12\x16\n\x06h\
    eight\x18\x01\x20\x01(\x03R\x06height\">\n\rBlockResponse\x12-\n\x05bloc\
    k\x18\x01\x20\x01(\x0b2\x17.tendermint.types.BlockR\x05block\"\x0f\n\rSt\
    atusRequest\"<\n\x0eStatusResponse\x12\x16\n\x06height\x18\x01\x20\x01(\
    \x03R\x06height\x12\x12\n\x04base\x18\x02\x20\x01(\x03R\x04base\"\xa2\
    \x03\n\x07Message\x12J\n\rblock_request\x18\x01\x20\x01(\x0b2#.tendermin\
    t.blockchain.BlockRequestH\0R\x0cblockRequest\x12T\n\x11no_block_respons\
    e\x18\x02\x20\x01(\x0b2&.tendermint.blockchain.NoBlockResponseH\0R\x0fno\
    BlockResponse\x12M\n\x0eblock_response\x18\x03\x20\x01(\x0b2$.tendermint\
    .blockchain.BlockResponseH\0R\rblockResponse\x12M\n\x0estatus_request\
    \x18\x04\x20\x01(\x0b2$.tendermint.blockchain.StatusRequestH\0R\rstatusR\
    equest\x12P\n\x0fstatus_response\x18\x05\x20\x01(\x0b2%.tendermint.block\
    chain.StatusResponseH\0R\x0estatusResponseB\x05\n\x03sumB>Z<github.com/t\
    endermint/tendermint/proto/tendermint/blockchainJ\xc0\x08\n\x06\x12\x04\
    \0\0(\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\
    \x1e\n\x08\n\x01\x08\x12\x03\x03\0S\n\t\n\x02\x08\x0b\x12\x03\x03\0S\n\t\
    \n\x02\x03\0\x12\x03\x05\0&\nA\n\x02\x04\0\x12\x04\x08\0\n\x01\x1a5\x20B\
    lockRequest\x20requests\x20a\x20block\x20for\x20a\x20specific\x20height\
    \n\n\n\n\x03\x04\0\x01\x12\x03\x08\x08\x14\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03\t\x02\x13\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\t\x02\x07\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\t\x08\x0e\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\t\
    \x11\x12\nh\n\x02\x04\x01\x12\x04\r\0\x0f\x01\x1a\\\x20NoBlockResponse\
    \x20informs\x20the\x20node\x20that\x20the\x20peer\x20does\x20not\x20have\
    \x20block\x20at\x20the\x20requested\x20height\n\n\n\n\x03\x04\x01\x01\
    \x12\x03\r\x08\x17\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0e\x02\x13\n\x0c\n\
    \x05\x04\x01\x02\0\x05\x12\x03\x0e\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03\x0e\x08\x0e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0e\x11\x12\n\
    :\n\x02\x04\x02\x12\x04\x12\0\x14\x01\x1a.\x20BlockResponse\x20returns\
    \x20block\x20to\x20the\x20requested\n\n\n\n\x03\x04\x02\x01\x12\x03\x12\
    \x08\x15\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x13\x02#\n\x0c\n\x05\x04\x02\
    \x02\0\x06\x12\x03\x13\x02\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x13\
    \x19\x1e\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x13!\"\n:\n\x02\x04\x03\
    \x12\x04\x17\0\x18\x01\x1a.\x20StatusRequest\x20requests\x20the\x20statu\
    s\x20of\x20a\x20peer.\n\n\n\n\x03\x04\x03\x01\x12\x03\x17\x08\x15\nG\n\
    \x02\x04\x04\x12\x04\x1b\0\x1e\x01\x1a;\x20StatusResponse\x20is\x20a\x20\
    peer\x20response\x20to\x20inform\x20their\x20status.\n\n\n\n\x03\x04\x04\
    \x01\x12\x03\x1b\x08\x16\n\x0b\n\x04\x04\x04\x02\0\x12\x03\x1c\x02\x13\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03\x1c\x02\x07\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03\x1c\x08\x0e\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\x1c\x11\
    \x12\n\x0b\n\x04\x04\x04\x02\x01\x12\x03\x1d\x02\x13\n\x0c\n\x05\x04\x04\
    \x02\x01\x05\x12\x03\x1d\x02\x07\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03\
    \x1d\x08\x0c\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03\x1d\x11\x12\n\n\n\
    \x02\x04\x05\x12\x04\x20\0(\x01\n\n\n\x03\x04\x05\x01\x12\x03\x20\x08\
    \x0f\n\x0c\n\x04\x04\x05\x08\0\x12\x04!\x02'\x03\n\x0c\n\x05\x04\x05\x08\
    \0\x01\x12\x03!\x08\x0b\n\x0b\n\x04\x04\x05\x02\0\x12\x03\"\x04*\n\x0c\n\
    \x05\x04\x05\x02\0\x06\x12\x03\"\x04\x10\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03\"\x14!\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03\"()\n\x0b\n\x04\
    \x04\x05\x02\x01\x12\x03#\x04*\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03#\
    \x04\x13\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03#\x14%\n\x0c\n\x05\x04\
    \x05\x02\x01\x03\x12\x03#()\n\x0b\n\x04\x04\x05\x02\x02\x12\x03$\x04*\n\
    \x0c\n\x05\x04\x05\x02\x02\x06\x12\x03$\x04\x11\n\x0c\n\x05\x04\x05\x02\
    \x02\x01\x12\x03$\x14\"\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03$()\n\x0b\
    \n\x04\x04\x05\x02\x03\x12\x03%\x04*\n\x0c\n\x05\x04\x05\x02\x03\x06\x12\
    \x03%\x04\x11\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03%\x14\"\n\x0c\n\x05\
    \x04\x05\x02\x03\x03\x12\x03%()\n\x0b\n\x04\x04\x05\x02\x04\x12\x03&\x04\
    *\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\x03&\x04\x12\n\x0c\n\x05\x04\x05\
    \x02\x04\x01\x12\x03&\x14#\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03&()b\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::block::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(BlockRequest::generated_message_descriptor_data());
            messages.push(NoBlockResponse::generated_message_descriptor_data());
            messages.push(BlockResponse::generated_message_descriptor_data());
            messages.push(StatusRequest::generated_message_descriptor_data());
            messages.push(StatusResponse::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
