// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tendermint/privval/types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.RemoteSignerError)
pub struct RemoteSignerError {
    // message fields
    // @@protoc_insertion_point(field:tendermint.privval.RemoteSignerError.code)
    pub code: i32,
    // @@protoc_insertion_point(field:tendermint.privval.RemoteSignerError.description)
    pub description: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.RemoteSignerError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoteSignerError {
    fn default() -> &'a RemoteSignerError {
        <RemoteSignerError as ::protobuf::Message>::default_instance()
    }
}

impl RemoteSignerError {
    pub fn new() -> RemoteSignerError {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &RemoteSignerError| { &m.code },
            |m: &mut RemoteSignerError| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &RemoteSignerError| { &m.description },
            |m: &mut RemoteSignerError| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoteSignerError>(
            "RemoteSignerError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoteSignerError {
    const NAME: &'static str = "RemoteSignerError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoteSignerError {
        RemoteSignerError::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.description.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoteSignerError {
        static instance: RemoteSignerError = RemoteSignerError {
            code: 0,
            description: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoteSignerError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoteSignerError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoteSignerError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteSignerError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PubKeyRequest requests the consensus public key from the remote signer.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.PubKeyRequest)
pub struct PubKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:tendermint.privval.PubKeyRequest.chain_id)
    pub chain_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.PubKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubKeyRequest {
    fn default() -> &'a PubKeyRequest {
        <PubKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl PubKeyRequest {
    pub fn new() -> PubKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &PubKeyRequest| { &m.chain_id },
            |m: &mut PubKeyRequest| { &mut m.chain_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubKeyRequest>(
            "PubKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubKeyRequest {
    const NAME: &'static str = "PubKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chain_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chain_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.chain_id.is_empty() {
            os.write_string(1, &self.chain_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubKeyRequest {
        PubKeyRequest::new()
    }

    fn clear(&mut self) {
        self.chain_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubKeyRequest {
        static instance: PubKeyRequest = PubKeyRequest {
            chain_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PubKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PubKeyResponse is a response message containing the public key.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.PubKeyResponse)
pub struct PubKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:tendermint.privval.PubKeyResponse.pub_key)
    pub pub_key: ::protobuf::MessageField<super::keys::PublicKey>,
    // @@protoc_insertion_point(field:tendermint.privval.PubKeyResponse.error)
    pub error: ::protobuf::MessageField<RemoteSignerError>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.PubKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubKeyResponse {
    fn default() -> &'a PubKeyResponse {
        <PubKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl PubKeyResponse {
    pub fn new() -> PubKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::keys::PublicKey>(
            "pub_key",
            |m: &PubKeyResponse| { &m.pub_key },
            |m: &mut PubKeyResponse| { &mut m.pub_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoteSignerError>(
            "error",
            |m: &PubKeyResponse| { &m.error },
            |m: &mut PubKeyResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubKeyResponse>(
            "PubKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubKeyResponse {
    const NAME: &'static str = "PubKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pub_key)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pub_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pub_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubKeyResponse {
        PubKeyResponse::new()
    }

    fn clear(&mut self) {
        self.pub_key.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubKeyResponse {
        static instance: PubKeyResponse = PubKeyResponse {
            pub_key: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PubKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SignVoteRequest is a request to sign a vote
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.SignVoteRequest)
pub struct SignVoteRequest {
    // message fields
    // @@protoc_insertion_point(field:tendermint.privval.SignVoteRequest.vote)
    pub vote: ::protobuf::MessageField<super::types::Vote>,
    // @@protoc_insertion_point(field:tendermint.privval.SignVoteRequest.chain_id)
    pub chain_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.SignVoteRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignVoteRequest {
    fn default() -> &'a SignVoteRequest {
        <SignVoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignVoteRequest {
    pub fn new() -> SignVoteRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Vote>(
            "vote",
            |m: &SignVoteRequest| { &m.vote },
            |m: &mut SignVoteRequest| { &mut m.vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &SignVoteRequest| { &m.chain_id },
            |m: &mut SignVoteRequest| { &mut m.chain_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignVoteRequest>(
            "SignVoteRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignVoteRequest {
    const NAME: &'static str = "SignVoteRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vote)?;
                },
                18 => {
                    self.chain_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chain_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(2, &self.chain_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignVoteRequest {
        SignVoteRequest::new()
    }

    fn clear(&mut self) {
        self.vote.clear();
        self.chain_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignVoteRequest {
        static instance: SignVoteRequest = SignVoteRequest {
            vote: ::protobuf::MessageField::none(),
            chain_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignVoteRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignVoteRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignVoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignVoteRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SignedVoteResponse is a response containing a signed vote or an error
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.SignedVoteResponse)
pub struct SignedVoteResponse {
    // message fields
    // @@protoc_insertion_point(field:tendermint.privval.SignedVoteResponse.vote)
    pub vote: ::protobuf::MessageField<super::types::Vote>,
    // @@protoc_insertion_point(field:tendermint.privval.SignedVoteResponse.error)
    pub error: ::protobuf::MessageField<RemoteSignerError>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.SignedVoteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignedVoteResponse {
    fn default() -> &'a SignedVoteResponse {
        <SignedVoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignedVoteResponse {
    pub fn new() -> SignedVoteResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Vote>(
            "vote",
            |m: &SignedVoteResponse| { &m.vote },
            |m: &mut SignedVoteResponse| { &mut m.vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoteSignerError>(
            "error",
            |m: &SignedVoteResponse| { &m.error },
            |m: &mut SignedVoteResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedVoteResponse>(
            "SignedVoteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignedVoteResponse {
    const NAME: &'static str = "SignedVoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vote)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignedVoteResponse {
        SignedVoteResponse::new()
    }

    fn clear(&mut self) {
        self.vote.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignedVoteResponse {
        static instance: SignedVoteResponse = SignedVoteResponse {
            vote: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignedVoteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignedVoteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignedVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedVoteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SignProposalRequest is a request to sign a proposal
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.SignProposalRequest)
pub struct SignProposalRequest {
    // message fields
    // @@protoc_insertion_point(field:tendermint.privval.SignProposalRequest.proposal)
    pub proposal: ::protobuf::MessageField<super::types::Proposal>,
    // @@protoc_insertion_point(field:tendermint.privval.SignProposalRequest.chain_id)
    pub chain_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.SignProposalRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignProposalRequest {
    fn default() -> &'a SignProposalRequest {
        <SignProposalRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignProposalRequest {
    pub fn new() -> SignProposalRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Proposal>(
            "proposal",
            |m: &SignProposalRequest| { &m.proposal },
            |m: &mut SignProposalRequest| { &mut m.proposal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &SignProposalRequest| { &m.chain_id },
            |m: &mut SignProposalRequest| { &mut m.chain_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignProposalRequest>(
            "SignProposalRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignProposalRequest {
    const NAME: &'static str = "SignProposalRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proposal)?;
                },
                18 => {
                    self.chain_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chain_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.proposal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.chain_id.is_empty() {
            os.write_string(2, &self.chain_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignProposalRequest {
        SignProposalRequest::new()
    }

    fn clear(&mut self) {
        self.proposal.clear();
        self.chain_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignProposalRequest {
        static instance: SignProposalRequest = SignProposalRequest {
            proposal: ::protobuf::MessageField::none(),
            chain_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignProposalRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignProposalRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignProposalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignProposalRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SignedProposalResponse is response containing a signed proposal or an error
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.SignedProposalResponse)
pub struct SignedProposalResponse {
    // message fields
    // @@protoc_insertion_point(field:tendermint.privval.SignedProposalResponse.proposal)
    pub proposal: ::protobuf::MessageField<super::types::Proposal>,
    // @@protoc_insertion_point(field:tendermint.privval.SignedProposalResponse.error)
    pub error: ::protobuf::MessageField<RemoteSignerError>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.SignedProposalResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignedProposalResponse {
    fn default() -> &'a SignedProposalResponse {
        <SignedProposalResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignedProposalResponse {
    pub fn new() -> SignedProposalResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Proposal>(
            "proposal",
            |m: &SignedProposalResponse| { &m.proposal },
            |m: &mut SignedProposalResponse| { &mut m.proposal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoteSignerError>(
            "error",
            |m: &SignedProposalResponse| { &m.error },
            |m: &mut SignedProposalResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedProposalResponse>(
            "SignedProposalResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignedProposalResponse {
    const NAME: &'static str = "SignedProposalResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proposal)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.proposal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignedProposalResponse {
        SignedProposalResponse::new()
    }

    fn clear(&mut self) {
        self.proposal.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignedProposalResponse {
        static instance: SignedProposalResponse = SignedProposalResponse {
            proposal: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignedProposalResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignedProposalResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignedProposalResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedProposalResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PingRequest is a request to confirm that the connection is alive.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.PingRequest)
pub struct PingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PingResponse is a response to confirm that the connection is alive.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.PingResponse)
pub struct PingResponse {
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.PingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingResponse>(
            "PingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingResponse {
    const NAME: &'static str = "PingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingResponse {
        static instance: PingResponse = PingResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.privval.Message)
pub struct Message {
    // message oneof groups
    pub sum: ::std::option::Option<message::Sum>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.privval.Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .tendermint.privval.PubKeyRequest pub_key_request = 1;

    pub fn pub_key_request(&self) -> &PubKeyRequest {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PubKeyRequest(ref v)) => v,
            _ => <PubKeyRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pub_key_request(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_pub_key_request(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PubKeyRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pub_key_request(&mut self, v: PubKeyRequest) {
        self.sum = ::std::option::Option::Some(message::Sum::PubKeyRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pub_key_request(&mut self) -> &mut PubKeyRequest {
        if let ::std::option::Option::Some(message::Sum::PubKeyRequest(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::PubKeyRequest(PubKeyRequest::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::PubKeyRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pub_key_request(&mut self) -> PubKeyRequest {
        if self.has_pub_key_request() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::PubKeyRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            PubKeyRequest::new()
        }
    }

    // .tendermint.privval.PubKeyResponse pub_key_response = 2;

    pub fn pub_key_response(&self) -> &PubKeyResponse {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PubKeyResponse(ref v)) => v,
            _ => <PubKeyResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pub_key_response(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_pub_key_response(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PubKeyResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pub_key_response(&mut self, v: PubKeyResponse) {
        self.sum = ::std::option::Option::Some(message::Sum::PubKeyResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pub_key_response(&mut self) -> &mut PubKeyResponse {
        if let ::std::option::Option::Some(message::Sum::PubKeyResponse(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::PubKeyResponse(PubKeyResponse::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::PubKeyResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pub_key_response(&mut self) -> PubKeyResponse {
        if self.has_pub_key_response() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::PubKeyResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            PubKeyResponse::new()
        }
    }

    // .tendermint.privval.SignVoteRequest sign_vote_request = 3;

    pub fn sign_vote_request(&self) -> &SignVoteRequest {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignVoteRequest(ref v)) => v,
            _ => <SignVoteRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sign_vote_request(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sign_vote_request(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignVoteRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sign_vote_request(&mut self, v: SignVoteRequest) {
        self.sum = ::std::option::Option::Some(message::Sum::SignVoteRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sign_vote_request(&mut self) -> &mut SignVoteRequest {
        if let ::std::option::Option::Some(message::Sum::SignVoteRequest(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::SignVoteRequest(SignVoteRequest::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignVoteRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sign_vote_request(&mut self) -> SignVoteRequest {
        if self.has_sign_vote_request() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::SignVoteRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SignVoteRequest::new()
        }
    }

    // .tendermint.privval.SignedVoteResponse signed_vote_response = 4;

    pub fn signed_vote_response(&self) -> &SignedVoteResponse {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignedVoteResponse(ref v)) => v,
            _ => <SignedVoteResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_signed_vote_response(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_signed_vote_response(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignedVoteResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_vote_response(&mut self, v: SignedVoteResponse) {
        self.sum = ::std::option::Option::Some(message::Sum::SignedVoteResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_vote_response(&mut self) -> &mut SignedVoteResponse {
        if let ::std::option::Option::Some(message::Sum::SignedVoteResponse(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::SignedVoteResponse(SignedVoteResponse::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignedVoteResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_vote_response(&mut self) -> SignedVoteResponse {
        if self.has_signed_vote_response() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::SignedVoteResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedVoteResponse::new()
        }
    }

    // .tendermint.privval.SignProposalRequest sign_proposal_request = 5;

    pub fn sign_proposal_request(&self) -> &SignProposalRequest {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignProposalRequest(ref v)) => v,
            _ => <SignProposalRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sign_proposal_request(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_sign_proposal_request(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignProposalRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sign_proposal_request(&mut self, v: SignProposalRequest) {
        self.sum = ::std::option::Option::Some(message::Sum::SignProposalRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sign_proposal_request(&mut self) -> &mut SignProposalRequest {
        if let ::std::option::Option::Some(message::Sum::SignProposalRequest(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::SignProposalRequest(SignProposalRequest::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignProposalRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sign_proposal_request(&mut self) -> SignProposalRequest {
        if self.has_sign_proposal_request() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::SignProposalRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SignProposalRequest::new()
        }
    }

    // .tendermint.privval.SignedProposalResponse signed_proposal_response = 6;

    pub fn signed_proposal_response(&self) -> &SignedProposalResponse {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignedProposalResponse(ref v)) => v,
            _ => <SignedProposalResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_signed_proposal_response(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_signed_proposal_response(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignedProposalResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_proposal_response(&mut self, v: SignedProposalResponse) {
        self.sum = ::std::option::Option::Some(message::Sum::SignedProposalResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_proposal_response(&mut self) -> &mut SignedProposalResponse {
        if let ::std::option::Option::Some(message::Sum::SignedProposalResponse(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::SignedProposalResponse(SignedProposalResponse::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::SignedProposalResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_proposal_response(&mut self) -> SignedProposalResponse {
        if self.has_signed_proposal_response() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::SignedProposalResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedProposalResponse::new()
        }
    }

    // .tendermint.privval.PingRequest ping_request = 7;

    pub fn ping_request(&self) -> &PingRequest {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PingRequest(ref v)) => v,
            _ => <PingRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping_request(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_ping_request(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PingRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping_request(&mut self, v: PingRequest) {
        self.sum = ::std::option::Option::Some(message::Sum::PingRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping_request(&mut self) -> &mut PingRequest {
        if let ::std::option::Option::Some(message::Sum::PingRequest(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::PingRequest(PingRequest::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::PingRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping_request(&mut self) -> PingRequest {
        if self.has_ping_request() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::PingRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            PingRequest::new()
        }
    }

    // .tendermint.privval.PingResponse ping_response = 8;

    pub fn ping_response(&self) -> &PingResponse {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PingResponse(ref v)) => v,
            _ => <PingResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping_response(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_ping_response(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::PingResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping_response(&mut self, v: PingResponse) {
        self.sum = ::std::option::Option::Some(message::Sum::PingResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping_response(&mut self) -> &mut PingResponse {
        if let ::std::option::Option::Some(message::Sum::PingResponse(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::PingResponse(PingResponse::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::PingResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping_response(&mut self) -> PingResponse {
        if self.has_ping_response() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::PingResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            PingResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PubKeyRequest>(
            "pub_key_request",
            Message::has_pub_key_request,
            Message::pub_key_request,
            Message::mut_pub_key_request,
            Message::set_pub_key_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PubKeyResponse>(
            "pub_key_response",
            Message::has_pub_key_response,
            Message::pub_key_response,
            Message::mut_pub_key_response,
            Message::set_pub_key_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignVoteRequest>(
            "sign_vote_request",
            Message::has_sign_vote_request,
            Message::sign_vote_request,
            Message::mut_sign_vote_request,
            Message::set_sign_vote_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignedVoteResponse>(
            "signed_vote_response",
            Message::has_signed_vote_response,
            Message::signed_vote_response,
            Message::mut_signed_vote_response,
            Message::set_signed_vote_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignProposalRequest>(
            "sign_proposal_request",
            Message::has_sign_proposal_request,
            Message::sign_proposal_request,
            Message::mut_sign_proposal_request,
            Message::set_sign_proposal_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignedProposalResponse>(
            "signed_proposal_response",
            Message::has_signed_proposal_response,
            Message::signed_proposal_response,
            Message::mut_signed_proposal_response,
            Message::set_signed_proposal_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PingRequest>(
            "ping_request",
            Message::has_ping_request,
            Message::ping_request,
            Message::mut_ping_request,
            Message::set_ping_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PingResponse>(
            "ping_response",
            Message::has_ping_response,
            Message::ping_response,
            Message::mut_ping_response,
            Message::set_ping_response,
        ));
        oneofs.push(message::Sum::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sum = ::std::option::Option::Some(message::Sum::PubKeyRequest(is.read_message()?));
                },
                18 => {
                    self.sum = ::std::option::Option::Some(message::Sum::PubKeyResponse(is.read_message()?));
                },
                26 => {
                    self.sum = ::std::option::Option::Some(message::Sum::SignVoteRequest(is.read_message()?));
                },
                34 => {
                    self.sum = ::std::option::Option::Some(message::Sum::SignedVoteResponse(is.read_message()?));
                },
                42 => {
                    self.sum = ::std::option::Option::Some(message::Sum::SignProposalRequest(is.read_message()?));
                },
                50 => {
                    self.sum = ::std::option::Option::Some(message::Sum::SignedProposalResponse(is.read_message()?));
                },
                58 => {
                    self.sum = ::std::option::Option::Some(message::Sum::PingRequest(is.read_message()?));
                },
                66 => {
                    self.sum = ::std::option::Option::Some(message::Sum::PingResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sum {
            match v {
                &message::Sum::PubKeyRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::PubKeyResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::SignVoteRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::SignedVoteResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::SignProposalRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::SignedProposalResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::PingRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::PingResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.sum {
            match v {
                &message::Sum::PubKeyRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &message::Sum::PubKeyResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &message::Sum::SignVoteRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &message::Sum::SignedVoteResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &message::Sum::SignProposalRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &message::Sum::SignedProposalResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &message::Sum::PingRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &message::Sum::PingResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            sum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:tendermint.privval.Message.sum)
    pub enum Sum {
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.pub_key_request)
        PubKeyRequest(super::PubKeyRequest),
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.pub_key_response)
        PubKeyResponse(super::PubKeyResponse),
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.sign_vote_request)
        SignVoteRequest(super::SignVoteRequest),
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.signed_vote_response)
        SignedVoteResponse(super::SignedVoteResponse),
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.sign_proposal_request)
        SignProposalRequest(super::SignProposalRequest),
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.signed_proposal_response)
        SignedProposalResponse(super::SignedProposalResponse),
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.ping_request)
        PingRequest(super::PingRequest),
        // @@protoc_insertion_point(oneof_field:tendermint.privval.Message.ping_response)
        PingResponse(super::PingResponse),
    }

    impl ::protobuf::Oneof for Sum {
    }

    impl ::protobuf::OneofFull for Sum {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Message as ::protobuf::MessageFull>::descriptor().oneof_by_name("sum").unwrap()).clone()
        }
    }

    impl Sum {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sum>("sum")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:tendermint.privval.Errors)
pub enum Errors {
    // @@protoc_insertion_point(enum_value:tendermint.privval.Errors.ERRORS_UNKNOWN)
    ERRORS_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:tendermint.privval.Errors.ERRORS_UNEXPECTED_RESPONSE)
    ERRORS_UNEXPECTED_RESPONSE = 1,
    // @@protoc_insertion_point(enum_value:tendermint.privval.Errors.ERRORS_NO_CONNECTION)
    ERRORS_NO_CONNECTION = 2,
    // @@protoc_insertion_point(enum_value:tendermint.privval.Errors.ERRORS_CONNECTION_TIMEOUT)
    ERRORS_CONNECTION_TIMEOUT = 3,
    // @@protoc_insertion_point(enum_value:tendermint.privval.Errors.ERRORS_READ_TIMEOUT)
    ERRORS_READ_TIMEOUT = 4,
    // @@protoc_insertion_point(enum_value:tendermint.privval.Errors.ERRORS_WRITE_TIMEOUT)
    ERRORS_WRITE_TIMEOUT = 5,
}

impl ::protobuf::Enum for Errors {
    const NAME: &'static str = "Errors";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Errors> {
        match value {
            0 => ::std::option::Option::Some(Errors::ERRORS_UNKNOWN),
            1 => ::std::option::Option::Some(Errors::ERRORS_UNEXPECTED_RESPONSE),
            2 => ::std::option::Option::Some(Errors::ERRORS_NO_CONNECTION),
            3 => ::std::option::Option::Some(Errors::ERRORS_CONNECTION_TIMEOUT),
            4 => ::std::option::Option::Some(Errors::ERRORS_READ_TIMEOUT),
            5 => ::std::option::Option::Some(Errors::ERRORS_WRITE_TIMEOUT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Errors] = &[
        Errors::ERRORS_UNKNOWN,
        Errors::ERRORS_UNEXPECTED_RESPONSE,
        Errors::ERRORS_NO_CONNECTION,
        Errors::ERRORS_CONNECTION_TIMEOUT,
        Errors::ERRORS_READ_TIMEOUT,
        Errors::ERRORS_WRITE_TIMEOUT,
    ];
}

impl ::protobuf::EnumFull for Errors {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Errors").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Errors {
    fn default() -> Self {
        Errors::ERRORS_UNKNOWN
    }
}

impl Errors {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Errors>("Errors")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1etendermint/privval/types.proto\x12\x12tendermint.privval\x1a\x1cte\
    ndermint/crypto/keys.proto\x1a\x1ctendermint/types/types.proto\x1a\x14go\
    goproto/gogo.proto\"I\n\x11RemoteSignerError\x12\x12\n\x04code\x18\x01\
    \x20\x01(\x05R\x04code\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bd\
    escription\"*\n\rPubKeyRequest\x12\x19\n\x08chain_id\x18\x01\x20\x01(\tR\
    \x07chainId\"\x8a\x01\n\x0ePubKeyResponse\x12;\n\x07pub_key\x18\x01\x20\
    \x01(\x0b2\x1c.tendermint.crypto.PublicKeyR\x06pubKeyB\x04\xc8\xde\x1f\0\
    \x12;\n\x05error\x18\x02\x20\x01(\x0b2%.tendermint.privval.RemoteSignerE\
    rrorR\x05error\"X\n\x0fSignVoteRequest\x12*\n\x04vote\x18\x01\x20\x01(\
    \x0b2\x16.tendermint.types.VoteR\x04vote\x12\x19\n\x08chain_id\x18\x02\
    \x20\x01(\tR\x07chainId\"\x83\x01\n\x12SignedVoteResponse\x120\n\x04vote\
    \x18\x01\x20\x01(\x0b2\x16.tendermint.types.VoteR\x04voteB\x04\xc8\xde\
    \x1f\0\x12;\n\x05error\x18\x02\x20\x01(\x0b2%.tendermint.privval.RemoteS\
    ignerErrorR\x05error\"h\n\x13SignProposalRequest\x126\n\x08proposal\x18\
    \x01\x20\x01(\x0b2\x1a.tendermint.types.ProposalR\x08proposal\x12\x19\n\
    \x08chain_id\x18\x02\x20\x01(\tR\x07chainId\"\x93\x01\n\x16SignedProposa\
    lResponse\x12<\n\x08proposal\x18\x01\x20\x01(\x0b2\x1a.tendermint.types.\
    ProposalR\x08proposalB\x04\xc8\xde\x1f\0\x12;\n\x05error\x18\x02\x20\x01\
    (\x0b2%.tendermint.privval.RemoteSignerErrorR\x05error\"\r\n\x0bPingRequ\
    est\"\x0e\n\x0cPingResponse\"\xb2\x05\n\x07Message\x12K\n\x0fpub_key_req\
    uest\x18\x01\x20\x01(\x0b2!.tendermint.privval.PubKeyRequestH\0R\rpubKey\
    Request\x12N\n\x10pub_key_response\x18\x02\x20\x01(\x0b2\".tendermint.pr\
    ivval.PubKeyResponseH\0R\x0epubKeyResponse\x12Q\n\x11sign_vote_request\
    \x18\x03\x20\x01(\x0b2#.tendermint.privval.SignVoteRequestH\0R\x0fsignVo\
    teRequest\x12Z\n\x14signed_vote_response\x18\x04\x20\x01(\x0b2&.tendermi\
    nt.privval.SignedVoteResponseH\0R\x12signedVoteResponse\x12]\n\x15sign_p\
    roposal_request\x18\x05\x20\x01(\x0b2'.tendermint.privval.SignProposalRe\
    questH\0R\x13signProposalRequest\x12f\n\x18signed_proposal_response\x18\
    \x06\x20\x01(\x0b2*.tendermint.privval.SignedProposalResponseH\0R\x16sig\
    nedProposalResponse\x12D\n\x0cping_request\x18\x07\x20\x01(\x0b2\x1f.ten\
    dermint.privval.PingRequestH\0R\x0bpingRequest\x12G\n\rping_response\x18\
    \x08\x20\x01(\x0b2\x20.tendermint.privval.PingResponseH\0R\x0cpingRespon\
    seB\x05\n\x03sum*\xa8\x01\n\x06Errors\x12\x12\n\x0eERRORS_UNKNOWN\x10\0\
    \x12\x1e\n\x1aERRORS_UNEXPECTED_RESPONSE\x10\x01\x12\x18\n\x14ERRORS_NO_\
    CONNECTION\x10\x02\x12\x1d\n\x19ERRORS_CONNECTION_TIMEOUT\x10\x03\x12\
    \x17\n\x13ERRORS_READ_TIMEOUT\x10\x04\x12\x18\n\x14ERRORS_WRITE_TIMEOUT\
    \x10\x05B;Z9github.com/tendermint/tendermint/proto/tendermint/privvalJ\
    \xe2\x12\n\x06\x12\x04\0\0K\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\
    \x01\x02\x12\x03\x01\0\x1b\n\t\n\x02\x03\0\x12\x03\x03\0&\n\t\n\x02\x03\
    \x01\x12\x03\x04\0&\n\t\n\x02\x03\x02\x12\x03\x05\0\x1e\n\x08\n\x01\x08\
    \x12\x03\x07\0P\n\t\n\x02\x08\x0b\x12\x03\x07\0P\n\n\n\x02\x05\0\x12\x04\
    \t\0\x10\x01\n\n\n\x03\x05\0\x01\x12\x03\t\x05\x0b\n\x0b\n\x04\x05\0\x02\
    \0\x12\x03\n\x02!\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\n\x02\x10\n\x0c\n\
    \x05\x05\0\x02\0\x02\x12\x03\n\x1f\x20\n\x0b\n\x04\x05\0\x02\x01\x12\x03\
    \x0b\x02!\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x0b\x02\x1c\n\x0c\n\x05\
    \x05\0\x02\x01\x02\x12\x03\x0b\x1f\x20\n\x0b\n\x04\x05\0\x02\x02\x12\x03\
    \x0c\x02!\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0c\x02\x16\n\x0c\n\x05\
    \x05\0\x02\x02\x02\x12\x03\x0c\x1f\x20\n\x0b\n\x04\x05\0\x02\x03\x12\x03\
    \r\x02!\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\r\x02\x1b\n\x0c\n\x05\x05\
    \0\x02\x03\x02\x12\x03\r\x1f\x20\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x0e\
    \x02!\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x0e\x02\x15\n\x0c\n\x05\x05\
    \0\x02\x04\x02\x12\x03\x0e\x1f\x20\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0f\
    \x02!\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0f\x02\x16\n\x0c\n\x05\x05\
    \0\x02\x05\x02\x12\x03\x0f\x1f\x20\n\n\n\x02\x04\0\x12\x04\x12\0\x15\x01\
    \n\n\n\x03\x04\0\x01\x12\x03\x12\x08\x19\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    \x13\x02\x19\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x13\x02\x07\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\x13\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x13\
    \x17\x18\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x14\x02\x19\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x14\t\x14\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x14\x17\x18\nU\n\x02\
    \x04\x01\x12\x04\x18\0\x1a\x01\x1aI\x20PubKeyRequest\x20requests\x20the\
    \x20consensus\x20public\x20key\x20from\x20the\x20remote\x20signer.\n\n\n\
    \n\x03\x04\x01\x01\x12\x03\x18\x08\x15\n\x0b\n\x04\x04\x01\x02\0\x12\x03\
    \x19\x02\x16\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x19\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03\x19\t\x11\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x19\x14\x15\nM\n\x02\x04\x02\x12\x04\x1d\0\x20\x01\x1aA\x20PubK\
    eyResponse\x20is\x20a\x20response\x20message\x20containing\x20the\x20pub\
    lic\x20key.\n\n\n\n\x03\x04\x02\x01\x12\x03\x1d\x08\x16\n\x0b\n\x04\x04\
    \x02\x02\0\x12\x03\x1e\x02I\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03\x1e\
    \x02\x1d\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1e\x1e%\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03\x1e()\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03\x1e*H\
    \n\x0f\n\x08\x04\x02\x02\0\x08\xe9\xfb\x03\x12\x03\x1e+G\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x03\x1f\x02*\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03\
    \x1f\x02\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x1f\x1e#\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03\x1f()\n9\n\x02\x04\x03\x12\x04#\0&\x01\
    \x1a-\x20SignVoteRequest\x20is\x20a\x20request\x20to\x20sign\x20a\x20vot\
    e\n\n\n\n\x03\x04\x03\x01\x12\x03#\x08\x17\n\x0b\n\x04\x04\x03\x02\0\x12\
    \x03$\x02%\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03$\x02\x17\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03$\x18\x1c\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x03$#$\n\x0b\n\x04\x04\x03\x02\x01\x12\x03%\x02%\n\x0c\n\x05\x04\x03\
    \x02\x01\x05\x12\x03%\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03%\
    \x18\x20\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03%#$\nS\n\x02\x04\x04\x12\
    \x04)\0,\x01\x1aG\x20SignedVoteResponse\x20is\x20a\x20response\x20contai\
    ning\x20a\x20signed\x20vote\x20or\x20an\x20error\n\n\n\n\x03\x04\x04\x01\
    \x12\x03)\x08\x1a\n\x0b\n\x04\x04\x04\x02\0\x12\x03*\x02A\n\x0c\n\x05\
    \x04\x04\x02\0\x06\x12\x03*\x02\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\
    \x03*\x18\x1c\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03*\x20!\n\x0c\n\x05\
    \x04\x04\x02\0\x08\x12\x03*\"@\n\x0f\n\x08\x04\x04\x02\0\x08\xe9\xfb\x03\
    \x12\x03*#?\n\x0b\n\x04\x04\x04\x02\x01\x12\x03+\x02\"\n\x0c\n\x05\x04\
    \x04\x02\x01\x06\x12\x03+\x02\x13\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x03+\x18\x1d\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03+\x20!\nA\n\x02\x04\
    \x05\x12\x04/\02\x01\x1a5\x20SignProposalRequest\x20is\x20a\x20request\
    \x20to\x20sign\x20a\x20proposal\n\n\n\n\x03\x04\x05\x01\x12\x03/\x08\x1b\
    \n\x0b\n\x04\x04\x05\x02\0\x12\x030\x02)\n\x0c\n\x05\x04\x05\x02\0\x06\
    \x12\x030\x02\x1b\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x030\x1c$\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x030'(\n\x0b\n\x04\x04\x05\x02\x01\x12\x031\
    \x02)\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x031\x02\x08\n\x0c\n\x05\x04\
    \x05\x02\x01\x01\x12\x031\x1c$\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x031'\
    (\nY\n\x02\x04\x06\x12\x045\08\x01\x1aM\x20SignedProposalResponse\x20is\
    \x20response\x20containing\x20a\x20signed\x20proposal\x20or\x20an\x20err\
    or\n\n\n\n\x03\x04\x06\x01\x12\x035\x08\x1e\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x036\x02H\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x036\x02\x1b\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x036\x1c$\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x036'(\n\x0c\n\x05\x04\x06\x02\0\x08\x12\x036)G\n\x0f\n\x08\x04\x06\x02\
    \0\x08\xe9\xfb\x03\x12\x036*F\n\x0b\n\x04\x04\x06\x02\x01\x12\x037\x02)\
    \n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x037\x02\x13\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x037\x1c!\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x037'(\nN\
    \n\x02\x04\x07\x12\x03;\0\x16\x1aC\x20PingRequest\x20is\x20a\x20request\
    \x20to\x20confirm\x20that\x20the\x20connection\x20is\x20alive.\n\n\n\n\
    \x03\x04\x07\x01\x12\x03;\x08\x13\nP\n\x02\x04\x08\x12\x03>\0\x17\x1aE\
    \x20PingResponse\x20is\x20a\x20response\x20to\x20confirm\x20that\x20the\
    \x20connection\x20is\x20alive.\n\n\n\n\x03\x04\x08\x01\x12\x03>\x08\x14\
    \n\n\n\x02\x04\t\x12\x04@\0K\x01\n\n\n\x03\x04\t\x01\x12\x03@\x08\x0f\n\
    \x0c\n\x04\x04\t\x08\0\x12\x04A\x02J\x03\n\x0c\n\x05\x04\t\x08\0\x01\x12\
    \x03A\x08\x0b\n\x0b\n\x04\x04\t\x02\0\x12\x03B\x048\n\x0c\n\x05\x04\t\
    \x02\0\x06\x12\x03B\x04\x11\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03B\x1b*\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03B67\n\x0b\n\x04\x04\t\x02\x01\x12\x03C\
    \x048\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03C\x04\x12\n\x0c\n\x05\x04\t\
    \x02\x01\x01\x12\x03C\x1b+\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03C67\n\
    \x0b\n\x04\x04\t\x02\x02\x12\x03D\x048\n\x0c\n\x05\x04\t\x02\x02\x06\x12\
    \x03D\x04\x13\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03D\x1b,\n\x0c\n\x05\
    \x04\t\x02\x02\x03\x12\x03D67\n\x0b\n\x04\x04\t\x02\x03\x12\x03E\x048\n\
    \x0c\n\x05\x04\t\x02\x03\x06\x12\x03E\x04\x16\n\x0c\n\x05\x04\t\x02\x03\
    \x01\x12\x03E\x1b/\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03E67\n\x0b\n\x04\
    \x04\t\x02\x04\x12\x03F\x048\n\x0c\n\x05\x04\t\x02\x04\x06\x12\x03F\x04\
    \x17\n\x0c\n\x05\x04\t\x02\x04\x01\x12\x03F\x1b0\n\x0c\n\x05\x04\t\x02\
    \x04\x03\x12\x03F67\n\x0b\n\x04\x04\t\x02\x05\x12\x03G\x048\n\x0c\n\x05\
    \x04\t\x02\x05\x06\x12\x03G\x04\x1a\n\x0c\n\x05\x04\t\x02\x05\x01\x12\
    \x03G\x1b3\n\x0c\n\x05\x04\t\x02\x05\x03\x12\x03G67\n\x0b\n\x04\x04\t\
    \x02\x06\x12\x03H\x048\n\x0c\n\x05\x04\t\x02\x06\x06\x12\x03H\x04\x0f\n\
    \x0c\n\x05\x04\t\x02\x06\x01\x12\x03H\x1b'\n\x0c\n\x05\x04\t\x02\x06\x03\
    \x12\x03H67\n\x0b\n\x04\x04\t\x02\x07\x12\x03I\x048\n\x0c\n\x05\x04\t\
    \x02\x07\x06\x12\x03I\x04\x10\n\x0c\n\x05\x04\t\x02\x07\x01\x12\x03I\x1b\
    (\n\x0c\n\x05\x04\t\x02\x07\x03\x12\x03I67b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::keys::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(RemoteSignerError::generated_message_descriptor_data());
            messages.push(PubKeyRequest::generated_message_descriptor_data());
            messages.push(PubKeyResponse::generated_message_descriptor_data());
            messages.push(SignVoteRequest::generated_message_descriptor_data());
            messages.push(SignedVoteResponse::generated_message_descriptor_data());
            messages.push(SignProposalRequest::generated_message_descriptor_data());
            messages.push(SignedProposalResponse::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(PingResponse::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(Errors::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
