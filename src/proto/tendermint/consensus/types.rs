// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tendermint/consensus/types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  NewRoundStep is sent for every step taken in the ConsensusState.
///  For every height/round/step transition
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.NewRoundStep)
pub struct NewRoundStep {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.NewRoundStep.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.NewRoundStep.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.consensus.NewRoundStep.step)
    pub step: u32,
    // @@protoc_insertion_point(field:tendermint.consensus.NewRoundStep.seconds_since_start_time)
    pub seconds_since_start_time: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.NewRoundStep.last_commit_round)
    pub last_commit_round: i32,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.NewRoundStep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NewRoundStep {
    fn default() -> &'a NewRoundStep {
        <NewRoundStep as ::protobuf::Message>::default_instance()
    }
}

impl NewRoundStep {
    pub fn new() -> NewRoundStep {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &NewRoundStep| { &m.height },
            |m: &mut NewRoundStep| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &NewRoundStep| { &m.round },
            |m: &mut NewRoundStep| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step",
            |m: &NewRoundStep| { &m.step },
            |m: &mut NewRoundStep| { &mut m.step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seconds_since_start_time",
            |m: &NewRoundStep| { &m.seconds_since_start_time },
            |m: &mut NewRoundStep| { &mut m.seconds_since_start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_commit_round",
            |m: &NewRoundStep| { &m.last_commit_round },
            |m: &mut NewRoundStep| { &mut m.last_commit_round },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NewRoundStep>(
            "NewRoundStep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NewRoundStep {
    const NAME: &'static str = "NewRoundStep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.round = is.read_int32()?;
                },
                24 => {
                    self.step = is.read_uint32()?;
                },
                32 => {
                    self.seconds_since_start_time = is.read_int64()?;
                },
                40 => {
                    self.last_commit_round = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.round);
        }
        if self.step != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.step);
        }
        if self.seconds_since_start_time != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.seconds_since_start_time);
        }
        if self.last_commit_round != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.last_commit_round);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(2, self.round)?;
        }
        if self.step != 0 {
            os.write_uint32(3, self.step)?;
        }
        if self.seconds_since_start_time != 0 {
            os.write_int64(4, self.seconds_since_start_time)?;
        }
        if self.last_commit_round != 0 {
            os.write_int32(5, self.last_commit_round)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NewRoundStep {
        NewRoundStep::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.round = 0;
        self.step = 0;
        self.seconds_since_start_time = 0;
        self.last_commit_round = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NewRoundStep {
        static instance: NewRoundStep = NewRoundStep {
            height: 0,
            round: 0,
            step: 0,
            seconds_since_start_time: 0,
            last_commit_round: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NewRoundStep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NewRoundStep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NewRoundStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewRoundStep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  NewValidBlock is sent when a validator observes a valid block B in some round r,
/// i.e., there is a Proposal for block B and 2/3+ prevotes for the block B in the round r.
///  In case the block is also committed, then IsCommit flag is set to true.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.NewValidBlock)
pub struct NewValidBlock {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.NewValidBlock.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.NewValidBlock.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.consensus.NewValidBlock.block_part_set_header)
    pub block_part_set_header: ::protobuf::MessageField<super::types::PartSetHeader>,
    // @@protoc_insertion_point(field:tendermint.consensus.NewValidBlock.block_parts)
    pub block_parts: ::protobuf::MessageField<super::types::BitArray>,
    // @@protoc_insertion_point(field:tendermint.consensus.NewValidBlock.is_commit)
    pub is_commit: bool,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.NewValidBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NewValidBlock {
    fn default() -> &'a NewValidBlock {
        <NewValidBlock as ::protobuf::Message>::default_instance()
    }
}

impl NewValidBlock {
    pub fn new() -> NewValidBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &NewValidBlock| { &m.height },
            |m: &mut NewValidBlock| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &NewValidBlock| { &m.round },
            |m: &mut NewValidBlock| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::PartSetHeader>(
            "block_part_set_header",
            |m: &NewValidBlock| { &m.block_part_set_header },
            |m: &mut NewValidBlock| { &mut m.block_part_set_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::BitArray>(
            "block_parts",
            |m: &NewValidBlock| { &m.block_parts },
            |m: &mut NewValidBlock| { &mut m.block_parts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_commit",
            |m: &NewValidBlock| { &m.is_commit },
            |m: &mut NewValidBlock| { &mut m.is_commit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NewValidBlock>(
            "NewValidBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NewValidBlock {
    const NAME: &'static str = "NewValidBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.round = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_part_set_header)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_parts)?;
                },
                40 => {
                    self.is_commit = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.round);
        }
        if let Some(v) = self.block_part_set_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.block_parts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.is_commit != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(2, self.round)?;
        }
        if let Some(v) = self.block_part_set_header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.block_parts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.is_commit != false {
            os.write_bool(5, self.is_commit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NewValidBlock {
        NewValidBlock::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.round = 0;
        self.block_part_set_header.clear();
        self.block_parts.clear();
        self.is_commit = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NewValidBlock {
        static instance: NewValidBlock = NewValidBlock {
            height: 0,
            round: 0,
            block_part_set_header: ::protobuf::MessageField::none(),
            block_parts: ::protobuf::MessageField::none(),
            is_commit: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NewValidBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NewValidBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NewValidBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewValidBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Proposal is sent when a new block is proposed.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.Proposal)
pub struct Proposal {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.Proposal.proposal)
    pub proposal: ::protobuf::MessageField<super::types::Proposal>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.Proposal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Proposal>(
            "proposal",
            |m: &Proposal| { &m.proposal },
            |m: &mut Proposal| { &mut m.proposal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Proposal>(
            "Proposal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Proposal {
    const NAME: &'static str = "Proposal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proposal)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.proposal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn clear(&mut self) {
        self.proposal.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Proposal {
        static instance: Proposal = Proposal {
            proposal: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Proposal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Proposal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ProposalPOL is sent when a previous proposal is re-proposed.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.ProposalPOL)
pub struct ProposalPOL {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.ProposalPOL.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.ProposalPOL.proposal_pol_round)
    pub proposal_pol_round: i32,
    // @@protoc_insertion_point(field:tendermint.consensus.ProposalPOL.proposal_pol)
    pub proposal_pol: ::protobuf::MessageField<super::types::BitArray>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.ProposalPOL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProposalPOL {
    fn default() -> &'a ProposalPOL {
        <ProposalPOL as ::protobuf::Message>::default_instance()
    }
}

impl ProposalPOL {
    pub fn new() -> ProposalPOL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &ProposalPOL| { &m.height },
            |m: &mut ProposalPOL| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposal_pol_round",
            |m: &ProposalPOL| { &m.proposal_pol_round },
            |m: &mut ProposalPOL| { &mut m.proposal_pol_round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::BitArray>(
            "proposal_pol",
            |m: &ProposalPOL| { &m.proposal_pol },
            |m: &mut ProposalPOL| { &mut m.proposal_pol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProposalPOL>(
            "ProposalPOL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProposalPOL {
    const NAME: &'static str = "ProposalPOL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.proposal_pol_round = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proposal_pol)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.proposal_pol_round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.proposal_pol_round);
        }
        if let Some(v) = self.proposal_pol.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.proposal_pol_round != 0 {
            os.write_int32(2, self.proposal_pol_round)?;
        }
        if let Some(v) = self.proposal_pol.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProposalPOL {
        ProposalPOL::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.proposal_pol_round = 0;
        self.proposal_pol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProposalPOL {
        static instance: ProposalPOL = ProposalPOL {
            height: 0,
            proposal_pol_round: 0,
            proposal_pol: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProposalPOL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProposalPOL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProposalPOL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalPOL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BlockPart is sent when gossipping a piece of the proposed block.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.BlockPart)
pub struct BlockPart {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.BlockPart.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.BlockPart.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.consensus.BlockPart.part)
    pub part: ::protobuf::MessageField<super::types::Part>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.BlockPart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockPart {
    fn default() -> &'a BlockPart {
        <BlockPart as ::protobuf::Message>::default_instance()
    }
}

impl BlockPart {
    pub fn new() -> BlockPart {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &BlockPart| { &m.height },
            |m: &mut BlockPart| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &BlockPart| { &m.round },
            |m: &mut BlockPart| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Part>(
            "part",
            |m: &BlockPart| { &m.part },
            |m: &mut BlockPart| { &mut m.part },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockPart>(
            "BlockPart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockPart {
    const NAME: &'static str = "BlockPart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.round = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.part)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.round);
        }
        if let Some(v) = self.part.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(2, self.round)?;
        }
        if let Some(v) = self.part.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockPart {
        BlockPart::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.round = 0;
        self.part.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockPart {
        static instance: BlockPart = BlockPart {
            height: 0,
            round: 0,
            part: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockPart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockPart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockPart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Vote is sent when voting for a proposal (or lack thereof).
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.Vote)
pub struct Vote {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.Vote.vote)
    pub vote: ::protobuf::MessageField<super::types::Vote>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.Vote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::Vote>(
            "vote",
            |m: &Vote| { &m.vote },
            |m: &mut Vote| { &mut m.vote },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vote>(
            "Vote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vote {
    const NAME: &'static str = "Vote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vote)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn clear(&mut self) {
        self.vote.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vote {
        static instance: Vote = Vote {
            vote: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  HasVote is sent to indicate that a particular vote has been received.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.HasVote)
pub struct HasVote {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.HasVote.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.HasVote.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.consensus.HasVote.type)
    pub type_: ::protobuf::EnumOrUnknown<super::types::SignedMsgType>,
    // @@protoc_insertion_point(field:tendermint.consensus.HasVote.index)
    pub index: i32,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.HasVote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HasVote {
    fn default() -> &'a HasVote {
        <HasVote as ::protobuf::Message>::default_instance()
    }
}

impl HasVote {
    pub fn new() -> HasVote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &HasVote| { &m.height },
            |m: &mut HasVote| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &HasVote| { &m.round },
            |m: &mut HasVote| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &HasVote| { &m.type_ },
            |m: &mut HasVote| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &HasVote| { &m.index },
            |m: &mut HasVote| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HasVote>(
            "HasVote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HasVote {
    const NAME: &'static str = "HasVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.round = is.read_int32()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.index = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.round);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(2, self.round)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.index != 0 {
            os.write_int32(4, self.index)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HasVote {
        HasVote::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.round = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN);
        self.index = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HasVote {
        static instance: HasVote = HasVote {
            height: 0,
            round: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            index: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HasVote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HasVote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HasVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HasVote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  VoteSetMaj23 is sent to indicate that a given BlockID has seen +2/3 votes.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.VoteSetMaj23)
pub struct VoteSetMaj23 {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetMaj23.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetMaj23.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetMaj23.type)
    pub type_: ::protobuf::EnumOrUnknown<super::types::SignedMsgType>,
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetMaj23.block_id)
    pub block_id: ::protobuf::MessageField<super::types::BlockID>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.VoteSetMaj23.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoteSetMaj23 {
    fn default() -> &'a VoteSetMaj23 {
        <VoteSetMaj23 as ::protobuf::Message>::default_instance()
    }
}

impl VoteSetMaj23 {
    pub fn new() -> VoteSetMaj23 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &VoteSetMaj23| { &m.height },
            |m: &mut VoteSetMaj23| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &VoteSetMaj23| { &m.round },
            |m: &mut VoteSetMaj23| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &VoteSetMaj23| { &m.type_ },
            |m: &mut VoteSetMaj23| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::BlockID>(
            "block_id",
            |m: &VoteSetMaj23| { &m.block_id },
            |m: &mut VoteSetMaj23| { &mut m.block_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoteSetMaj23>(
            "VoteSetMaj23",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoteSetMaj23 {
    const NAME: &'static str = "VoteSetMaj23";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.round = is.read_int32()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.round);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(2, self.round)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoteSetMaj23 {
        VoteSetMaj23::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.round = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN);
        self.block_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoteSetMaj23 {
        static instance: VoteSetMaj23 = VoteSetMaj23 {
            height: 0,
            round: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            block_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoteSetMaj23 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoteSetMaj23").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoteSetMaj23 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteSetMaj23 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  VoteSetBits is sent to communicate the bit-array of votes seen for the BlockID.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.VoteSetBits)
pub struct VoteSetBits {
    // message fields
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetBits.height)
    pub height: i64,
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetBits.round)
    pub round: i32,
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetBits.type)
    pub type_: ::protobuf::EnumOrUnknown<super::types::SignedMsgType>,
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetBits.block_id)
    pub block_id: ::protobuf::MessageField<super::types::BlockID>,
    // @@protoc_insertion_point(field:tendermint.consensus.VoteSetBits.votes)
    pub votes: ::protobuf::MessageField<super::types::BitArray>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.VoteSetBits.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoteSetBits {
    fn default() -> &'a VoteSetBits {
        <VoteSetBits as ::protobuf::Message>::default_instance()
    }
}

impl VoteSetBits {
    pub fn new() -> VoteSetBits {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &VoteSetBits| { &m.height },
            |m: &mut VoteSetBits| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &VoteSetBits| { &m.round },
            |m: &mut VoteSetBits| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &VoteSetBits| { &m.type_ },
            |m: &mut VoteSetBits| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::BlockID>(
            "block_id",
            |m: &VoteSetBits| { &m.block_id },
            |m: &mut VoteSetBits| { &mut m.block_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::types::BitArray>(
            "votes",
            |m: &VoteSetBits| { &m.votes },
            |m: &mut VoteSetBits| { &mut m.votes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoteSetBits>(
            "VoteSetBits",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoteSetBits {
    const NAME: &'static str = "VoteSetBits";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_int64()?;
                },
                16 => {
                    self.round = is.read_int32()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_id)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.votes)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.height);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.round);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        if let Some(v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.votes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if self.round != 0 {
            os.write_int32(2, self.round)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.block_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.votes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoteSetBits {
        VoteSetBits::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.round = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(super::types::SignedMsgType::SIGNED_MSG_TYPE_UNKNOWN);
        self.block_id.clear();
        self.votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoteSetBits {
        static instance: VoteSetBits = VoteSetBits {
            height: 0,
            round: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            block_id: ::protobuf::MessageField::none(),
            votes: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoteSetBits {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoteSetBits").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoteSetBits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteSetBits {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tendermint.consensus.Message)
pub struct Message {
    // message oneof groups
    pub sum: ::std::option::Option<message::Sum>,
    // special fields
    // @@protoc_insertion_point(special_field:tendermint.consensus.Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .tendermint.consensus.NewRoundStep new_round_step = 1;

    pub fn new_round_step(&self) -> &NewRoundStep {
        match self.sum {
            ::std::option::Option::Some(message::Sum::NewRoundStep(ref v)) => v,
            _ => <NewRoundStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_new_round_step(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_new_round_step(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::NewRoundStep(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_round_step(&mut self, v: NewRoundStep) {
        self.sum = ::std::option::Option::Some(message::Sum::NewRoundStep(v))
    }

    // Mutable pointer to the field.
    pub fn mut_new_round_step(&mut self) -> &mut NewRoundStep {
        if let ::std::option::Option::Some(message::Sum::NewRoundStep(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::NewRoundStep(NewRoundStep::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::NewRoundStep(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_round_step(&mut self) -> NewRoundStep {
        if self.has_new_round_step() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::NewRoundStep(v)) => v,
                _ => panic!(),
            }
        } else {
            NewRoundStep::new()
        }
    }

    // .tendermint.consensus.NewValidBlock new_valid_block = 2;

    pub fn new_valid_block(&self) -> &NewValidBlock {
        match self.sum {
            ::std::option::Option::Some(message::Sum::NewValidBlock(ref v)) => v,
            _ => <NewValidBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_new_valid_block(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_new_valid_block(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::NewValidBlock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_valid_block(&mut self, v: NewValidBlock) {
        self.sum = ::std::option::Option::Some(message::Sum::NewValidBlock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_new_valid_block(&mut self) -> &mut NewValidBlock {
        if let ::std::option::Option::Some(message::Sum::NewValidBlock(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::NewValidBlock(NewValidBlock::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::NewValidBlock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_valid_block(&mut self) -> NewValidBlock {
        if self.has_new_valid_block() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::NewValidBlock(v)) => v,
                _ => panic!(),
            }
        } else {
            NewValidBlock::new()
        }
    }

    // .tendermint.consensus.Proposal proposal = 3;

    pub fn proposal(&self) -> &Proposal {
        match self.sum {
            ::std::option::Option::Some(message::Sum::Proposal(ref v)) => v,
            _ => <Proposal as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_proposal(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_proposal(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::Proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.sum = ::std::option::Option::Some(message::Sum::Proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if let ::std::option::Option::Some(message::Sum::Proposal(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::Proposal(Proposal::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::Proposal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        if self.has_proposal() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::Proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            Proposal::new()
        }
    }

    // .tendermint.consensus.ProposalPOL proposal_pol = 4;

    pub fn proposal_pol(&self) -> &ProposalPOL {
        match self.sum {
            ::std::option::Option::Some(message::Sum::ProposalPol(ref v)) => v,
            _ => <ProposalPOL as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_proposal_pol(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_proposal_pol(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::ProposalPol(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proposal_pol(&mut self, v: ProposalPOL) {
        self.sum = ::std::option::Option::Some(message::Sum::ProposalPol(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proposal_pol(&mut self) -> &mut ProposalPOL {
        if let ::std::option::Option::Some(message::Sum::ProposalPol(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::ProposalPol(ProposalPOL::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::ProposalPol(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proposal_pol(&mut self) -> ProposalPOL {
        if self.has_proposal_pol() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::ProposalPol(v)) => v,
                _ => panic!(),
            }
        } else {
            ProposalPOL::new()
        }
    }

    // .tendermint.consensus.BlockPart block_part = 5;

    pub fn block_part(&self) -> &BlockPart {
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockPart(ref v)) => v,
            _ => <BlockPart as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_part(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_block_part(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockPart(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_part(&mut self, v: BlockPart) {
        self.sum = ::std::option::Option::Some(message::Sum::BlockPart(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_part(&mut self) -> &mut BlockPart {
        if let ::std::option::Option::Some(message::Sum::BlockPart(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::BlockPart(BlockPart::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::BlockPart(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_part(&mut self) -> BlockPart {
        if self.has_block_part() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::BlockPart(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockPart::new()
        }
    }

    // .tendermint.consensus.Vote vote = 6;

    pub fn vote(&self) -> &Vote {
        match self.sum {
            ::std::option::Option::Some(message::Sum::Vote(ref v)) => v,
            _ => <Vote as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vote(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::Vote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: Vote) {
        self.sum = ::std::option::Option::Some(message::Sum::Vote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote(&mut self) -> &mut Vote {
        if let ::std::option::Option::Some(message::Sum::Vote(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::Vote(Vote::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::Vote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote(&mut self) -> Vote {
        if self.has_vote() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::Vote(v)) => v,
                _ => panic!(),
            }
        } else {
            Vote::new()
        }
    }

    // .tendermint.consensus.HasVote has_vote = 7;

    pub fn has_vote(&self) -> &HasVote {
        match self.sum {
            ::std::option::Option::Some(message::Sum::HasVote(ref v)) => v,
            _ => <HasVote as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_has_vote(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_has_vote(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::HasVote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_has_vote(&mut self, v: HasVote) {
        self.sum = ::std::option::Option::Some(message::Sum::HasVote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_has_vote(&mut self) -> &mut HasVote {
        if let ::std::option::Option::Some(message::Sum::HasVote(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::HasVote(HasVote::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::HasVote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_has_vote(&mut self) -> HasVote {
        if self.has_has_vote() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::HasVote(v)) => v,
                _ => panic!(),
            }
        } else {
            HasVote::new()
        }
    }

    // .tendermint.consensus.VoteSetMaj23 vote_set_maj23 = 8;

    pub fn vote_set_maj23(&self) -> &VoteSetMaj23 {
        match self.sum {
            ::std::option::Option::Some(message::Sum::VoteSetMaj23(ref v)) => v,
            _ => <VoteSetMaj23 as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vote_set_maj23(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_vote_set_maj23(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::VoteSetMaj23(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote_set_maj23(&mut self, v: VoteSetMaj23) {
        self.sum = ::std::option::Option::Some(message::Sum::VoteSetMaj23(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote_set_maj23(&mut self) -> &mut VoteSetMaj23 {
        if let ::std::option::Option::Some(message::Sum::VoteSetMaj23(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::VoteSetMaj23(VoteSetMaj23::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::VoteSetMaj23(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote_set_maj23(&mut self) -> VoteSetMaj23 {
        if self.has_vote_set_maj23() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::VoteSetMaj23(v)) => v,
                _ => panic!(),
            }
        } else {
            VoteSetMaj23::new()
        }
    }

    // .tendermint.consensus.VoteSetBits vote_set_bits = 9;

    pub fn vote_set_bits(&self) -> &VoteSetBits {
        match self.sum {
            ::std::option::Option::Some(message::Sum::VoteSetBits(ref v)) => v,
            _ => <VoteSetBits as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vote_set_bits(&mut self) {
        self.sum = ::std::option::Option::None;
    }

    pub fn has_vote_set_bits(&self) -> bool {
        match self.sum {
            ::std::option::Option::Some(message::Sum::VoteSetBits(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote_set_bits(&mut self, v: VoteSetBits) {
        self.sum = ::std::option::Option::Some(message::Sum::VoteSetBits(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote_set_bits(&mut self) -> &mut VoteSetBits {
        if let ::std::option::Option::Some(message::Sum::VoteSetBits(_)) = self.sum {
        } else {
            self.sum = ::std::option::Option::Some(message::Sum::VoteSetBits(VoteSetBits::new()));
        }
        match self.sum {
            ::std::option::Option::Some(message::Sum::VoteSetBits(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote_set_bits(&mut self) -> VoteSetBits {
        if self.has_vote_set_bits() {
            match self.sum.take() {
                ::std::option::Option::Some(message::Sum::VoteSetBits(v)) => v,
                _ => panic!(),
            }
        } else {
            VoteSetBits::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NewRoundStep>(
            "new_round_step",
            Message::has_new_round_step,
            Message::new_round_step,
            Message::mut_new_round_step,
            Message::set_new_round_step,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NewValidBlock>(
            "new_valid_block",
            Message::has_new_valid_block,
            Message::new_valid_block,
            Message::mut_new_valid_block,
            Message::set_new_valid_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Proposal>(
            "proposal",
            Message::has_proposal,
            Message::proposal,
            Message::mut_proposal,
            Message::set_proposal,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProposalPOL>(
            "proposal_pol",
            Message::has_proposal_pol,
            Message::proposal_pol,
            Message::mut_proposal_pol,
            Message::set_proposal_pol,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockPart>(
            "block_part",
            Message::has_block_part,
            Message::block_part,
            Message::mut_block_part,
            Message::set_block_part,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Vote>(
            "vote",
            Message::has_vote,
            Message::vote,
            Message::mut_vote,
            Message::set_vote,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HasVote>(
            "has_vote",
            Message::has_has_vote,
            Message::has_vote,
            Message::mut_has_vote,
            Message::set_has_vote,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VoteSetMaj23>(
            "vote_set_maj23",
            Message::has_vote_set_maj23,
            Message::vote_set_maj23,
            Message::mut_vote_set_maj23,
            Message::set_vote_set_maj23,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VoteSetBits>(
            "vote_set_bits",
            Message::has_vote_set_bits,
            Message::vote_set_bits,
            Message::mut_vote_set_bits,
            Message::set_vote_set_bits,
        ));
        oneofs.push(message::Sum::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sum = ::std::option::Option::Some(message::Sum::NewRoundStep(is.read_message()?));
                },
                18 => {
                    self.sum = ::std::option::Option::Some(message::Sum::NewValidBlock(is.read_message()?));
                },
                26 => {
                    self.sum = ::std::option::Option::Some(message::Sum::Proposal(is.read_message()?));
                },
                34 => {
                    self.sum = ::std::option::Option::Some(message::Sum::ProposalPol(is.read_message()?));
                },
                42 => {
                    self.sum = ::std::option::Option::Some(message::Sum::BlockPart(is.read_message()?));
                },
                50 => {
                    self.sum = ::std::option::Option::Some(message::Sum::Vote(is.read_message()?));
                },
                58 => {
                    self.sum = ::std::option::Option::Some(message::Sum::HasVote(is.read_message()?));
                },
                66 => {
                    self.sum = ::std::option::Option::Some(message::Sum::VoteSetMaj23(is.read_message()?));
                },
                74 => {
                    self.sum = ::std::option::Option::Some(message::Sum::VoteSetBits(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sum {
            match v {
                &message::Sum::NewRoundStep(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::NewValidBlock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::Proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::ProposalPol(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::BlockPart(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::Vote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::HasVote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::VoteSetMaj23(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Sum::VoteSetBits(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.sum {
            match v {
                &message::Sum::NewRoundStep(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &message::Sum::NewValidBlock(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &message::Sum::Proposal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &message::Sum::ProposalPol(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &message::Sum::BlockPart(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &message::Sum::Vote(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &message::Sum::HasVote(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &message::Sum::VoteSetMaj23(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &message::Sum::VoteSetBits(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            sum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:tendermint.consensus.Message.sum)
    pub enum Sum {
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.new_round_step)
        NewRoundStep(super::NewRoundStep),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.new_valid_block)
        NewValidBlock(super::NewValidBlock),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.proposal)
        Proposal(super::Proposal),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.proposal_pol)
        ProposalPol(super::ProposalPOL),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.block_part)
        BlockPart(super::BlockPart),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.vote)
        Vote(super::Vote),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.has_vote)
        HasVote(super::HasVote),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.vote_set_maj23)
        VoteSetMaj23(super::VoteSetMaj23),
        // @@protoc_insertion_point(oneof_field:tendermint.consensus.Message.vote_set_bits)
        VoteSetBits(super::VoteSetBits),
    }

    impl ::protobuf::Oneof for Sum {
    }

    impl ::protobuf::OneofFull for Sum {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Message as ::protobuf::MessageFull>::descriptor().oneof_by_name("sum").unwrap()).clone()
        }
    }

    impl Sum {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sum>("sum")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20tendermint/consensus/types.proto\x12\x14tendermint.consensus\x1a\
    \x14gogoproto/gogo.proto\x1a\x1ctendermint/types/types.proto\x1a\x20tend\
    ermint/libs/bits/types.proto\"\xb5\x01\n\x0cNewRoundStep\x12\x16\n\x06he\
    ight\x18\x01\x20\x01(\x03R\x06height\x12\x14\n\x05round\x18\x02\x20\x01(\
    \x05R\x05round\x12\x12\n\x04step\x18\x03\x20\x01(\rR\x04step\x127\n\x18s\
    econds_since_start_time\x18\x04\x20\x01(\x03R\x15secondsSinceStartTime\
    \x12*\n\x11last_commit_round\x18\x05\x20\x01(\x05R\x0flastCommitRound\"\
    \xf5\x01\n\rNewValidBlock\x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06h\
    eight\x12\x14\n\x05round\x18\x02\x20\x01(\x05R\x05round\x12X\n\x15block_\
    part_set_header\x18\x03\x20\x01(\x0b2\x1f.tendermint.types.PartSetHeader\
    R\x12blockPartSetHeaderB\x04\xc8\xde\x1f\0\x12?\n\x0bblock_parts\x18\x04\
    \x20\x01(\x0b2\x1e.tendermint.libs.bits.BitArrayR\nblockParts\x12\x1b\n\
    \tis_commit\x18\x05\x20\x01(\x08R\x08isCommit\"H\n\x08Proposal\x12<\n\
    \x08proposal\x18\x01\x20\x01(\x0b2\x1a.tendermint.types.ProposalR\x08pro\
    posalB\x04\xc8\xde\x1f\0\"\x9c\x01\n\x0bProposalPOL\x12\x16\n\x06height\
    \x18\x01\x20\x01(\x03R\x06height\x12,\n\x12proposal_pol_round\x18\x02\
    \x20\x01(\x05R\x10proposalPolRound\x12G\n\x0cproposal_pol\x18\x03\x20\
    \x01(\x0b2\x1e.tendermint.libs.bits.BitArrayR\x0bproposalPolB\x04\xc8\
    \xde\x1f\0\"k\n\tBlockPart\x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06\
    height\x12\x14\n\x05round\x18\x02\x20\x01(\x05R\x05round\x120\n\x04part\
    \x18\x03\x20\x01(\x0b2\x16.tendermint.types.PartR\x04partB\x04\xc8\xde\
    \x1f\0\"2\n\x04Vote\x12*\n\x04vote\x18\x01\x20\x01(\x0b2\x16.tendermint.\
    types.VoteR\x04vote\"\x82\x01\n\x07HasVote\x12\x16\n\x06height\x18\x01\
    \x20\x01(\x03R\x06height\x12\x14\n\x05round\x18\x02\x20\x01(\x05R\x05rou\
    nd\x123\n\x04type\x18\x03\x20\x01(\x0e2\x1f.tendermint.types.SignedMsgTy\
    peR\x04type\x12\x14\n\x05index\x18\x04\x20\x01(\x05R\x05index\"\xb8\x01\
    \n\x0cVoteSetMaj23\x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06height\
    \x12\x14\n\x05round\x18\x02\x20\x01(\x05R\x05round\x123\n\x04type\x18\
    \x03\x20\x01(\x0e2\x1f.tendermint.types.SignedMsgTypeR\x04type\x12E\n\
    \x08block_id\x18\x04\x20\x01(\x0b2\x19.tendermint.types.BlockIDR\x07bloc\
    kIdB\x0f\xc8\xde\x1f\0\xe2\xde\x1f\x07BlockID\"\xf3\x01\n\x0bVoteSetBits\
    \x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06height\x12\x14\n\x05round\
    \x18\x02\x20\x01(\x05R\x05round\x123\n\x04type\x18\x03\x20\x01(\x0e2\x1f\
    .tendermint.types.SignedMsgTypeR\x04type\x12E\n\x08block_id\x18\x04\x20\
    \x01(\x0b2\x19.tendermint.types.BlockIDR\x07blockIdB\x0f\xc8\xde\x1f\0\
    \xe2\xde\x1f\x07BlockID\x12:\n\x05votes\x18\x05\x20\x01(\x0b2\x1e.tender\
    mint.libs.bits.BitArrayR\x05votesB\x04\xc8\xde\x1f\0\"\xf6\x04\n\x07Mess\
    age\x12J\n\x0enew_round_step\x18\x01\x20\x01(\x0b2\".tendermint.consensu\
    s.NewRoundStepH\0R\x0cnewRoundStep\x12M\n\x0fnew_valid_block\x18\x02\x20\
    \x01(\x0b2#.tendermint.consensus.NewValidBlockH\0R\rnewValidBlock\x12<\n\
    \x08proposal\x18\x03\x20\x01(\x0b2\x1e.tendermint.consensus.ProposalH\0R\
    \x08proposal\x12F\n\x0cproposal_pol\x18\x04\x20\x01(\x0b2!.tendermint.co\
    nsensus.ProposalPOLH\0R\x0bproposalPol\x12@\n\nblock_part\x18\x05\x20\
    \x01(\x0b2\x1f.tendermint.consensus.BlockPartH\0R\tblockPart\x120\n\x04v\
    ote\x18\x06\x20\x01(\x0b2\x1a.tendermint.consensus.VoteH\0R\x04vote\x12:\
    \n\x08has_vote\x18\x07\x20\x01(\x0b2\x1d.tendermint.consensus.HasVoteH\0\
    R\x07hasVote\x12J\n\x0evote_set_maj23\x18\x08\x20\x01(\x0b2\".tendermint\
    .consensus.VoteSetMaj23H\0R\x0cvoteSetMaj23\x12G\n\rvote_set_bits\x18\t\
    \x20\x01(\x0b2!.tendermint.consensus.VoteSetBitsH\0R\x0bvoteSetBitsB\x05\
    \n\x03sumB=Z;github.com/tendermint/tendermint/proto/tendermint/consensus\
    J\xb2\x1c\n\x06\x12\x04\0\0[\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\
    \x01\x02\x12\x03\x01\0\x1d\n\x08\n\x01\x08\x12\x03\x03\0R\n\t\n\x02\x08\
    \x0b\x12\x03\x03\0R\n\t\n\x02\x03\0\x12\x03\x05\0\x1e\n\t\n\x02\x03\x01\
    \x12\x03\x06\0&\n\t\n\x02\x03\x02\x12\x03\x07\0*\nv\n\x02\x04\0\x12\x04\
    \x0b\0\x11\x01\x1aj\x20NewRoundStep\x20is\x20sent\x20for\x20every\x20ste\
    p\x20taken\x20in\x20the\x20ConsensusState.\n\x20For\x20every\x20height/r\
    ound/step\x20transition\n\n\n\n\x03\x04\0\x01\x12\x03\x0b\x08\x14\n\x0b\
    \n\x04\x04\0\x02\0\x12\x03\x0c\x02&\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    \x0c\x02\x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0c\t\x0f\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03\x0c$%\n\x0b\n\x04\x04\0\x02\x01\x12\x03\r\x02&\
    \n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\r\x02\x07\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\r\t\x0e\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\r$%\n\x0b\
    \n\x04\x04\0\x02\x02\x12\x03\x0e\x02&\n\x0c\n\x05\x04\0\x02\x02\x05\x12\
    \x03\x0e\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x0e\t\r\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03\x0e$%\n\x0b\n\x04\x04\0\x02\x03\x12\x03\
    \x0f\x02&\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x0f\x02\x07\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03\x0f\t!\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\
    \x0f$%\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x10\x02&\n\x0c\n\x05\x04\0\x02\
    \x04\x05\x12\x03\x10\x02\x07\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x10\t\
    \x1a\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x10$%\n\x80\x02\n\x02\x04\x01\
    \x12\x04\x16\0\x1c\x01\x1a\xf3\x01\x20NewValidBlock\x20is\x20sent\x20whe\
    n\x20a\x20validator\x20observes\x20a\x20valid\x20block\x20B\x20in\x20som\
    e\x20round\x20r,\ni.e.,\x20there\x20is\x20a\x20Proposal\x20for\x20block\
    \x20B\x20and\x202/3+\x20prevotes\x20for\x20the\x20block\x20B\x20in\x20th\
    e\x20round\x20r.\n\x20In\x20case\x20the\x20block\x20is\x20also\x20commit\
    ted,\x20then\x20IsCommit\x20flag\x20is\x20set\x20to\x20true.\n\n\n\n\x03\
    \x04\x01\x01\x12\x03\x16\x08\x15\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x17\
    \x02;\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x17\x02\x07\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03\x17!'\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x179:\
    \n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x18\x02;\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03\x18\x02\x07\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x18\
    !&\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x189:\n\x0b\n\x04\x04\x01\x02\
    \x02\x12\x03\x19\x02Z\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03\x19\x02\
    \x20\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x19!6\n\x0c\n\x05\x04\x01\
    \x02\x02\x03\x12\x03\x199:\n\x0c\n\x05\x04\x01\x02\x02\x08\x12\x03\x19;Y\
    \n\x0f\n\x08\x04\x01\x02\x02\x08\xe9\xfb\x03\x12\x03\x19<X\n\x0b\n\x04\
    \x04\x01\x02\x03\x12\x03\x1a\x02;\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\
    \x03\x1a\x02\x1f\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x1a!,\n\x0c\n\
    \x05\x04\x01\x02\x03\x03\x12\x03\x1a9:\n\x0b\n\x04\x04\x01\x02\x04\x12\
    \x03\x1b\x02;\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x1b\x02\x06\n\x0c\
    \n\x05\x04\x01\x02\x04\x01\x12\x03\x1b!*\n\x0c\n\x05\x04\x01\x02\x04\x03\
    \x12\x03\x1b9:\n<\n\x02\x04\x02\x12\x04\x1f\0!\x01\x1a0\x20Proposal\x20i\
    s\x20sent\x20when\x20a\x20new\x20block\x20is\x20proposed.\n\n\n\n\x03\
    \x04\x02\x01\x12\x03\x1f\x08\x10\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x20\
    \x02H\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03\x20\x02\x1b\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x03\x20\x1c$\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\
    \x20'(\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03\x20)G\n\x0f\n\x08\x04\x02\
    \x02\0\x08\xe9\xfb\x03\x12\x03\x20*F\nJ\n\x02\x04\x03\x12\x04$\0(\x01\
    \x1a>\x20ProposalPOL\x20is\x20sent\x20when\x20a\x20previous\x20proposal\
    \x20is\x20re-proposed.\n\n\n\n\x03\x04\x03\x01\x12\x03$\x08\x13\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x03%\x027\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03%\
    \x02\x07\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03%\x20&\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03%56\n\x0b\n\x04\x04\x03\x02\x01\x12\x03&\x027\n\x0c\n\
    \x05\x04\x03\x02\x01\x05\x12\x03&\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03&\x202\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03&56\n\x0b\n\
    \x04\x04\x03\x02\x02\x12\x03'\x02V\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\
    \x03'\x02\x1f\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03'\x20,\n\x0c\n\x05\
    \x04\x03\x02\x02\x03\x12\x03'56\n\x0c\n\x05\x04\x03\x02\x02\x08\x12\x03'\
    7U\n\x0f\n\x08\x04\x03\x02\x02\x08\xe9\xfb\x03\x12\x03'8T\nN\n\x02\x04\
    \x04\x12\x04+\0/\x01\x1aB\x20BlockPart\x20is\x20sent\x20when\x20gossippi\
    ng\x20a\x20piece\x20of\x20the\x20proposed\x20block.\n\n\n\n\x03\x04\x04\
    \x01\x12\x03+\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03,\x02#\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x03,\x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03,\x18\x1e\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03,!\"\n\x0b\n\x04\
    \x04\x04\x02\x01\x12\x03-\x02#\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03-\
    \x02\x07\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03-\x18\x1d\n\x0c\n\x05\
    \x04\x04\x02\x01\x03\x12\x03-!\"\n\x0b\n\x04\x04\x04\x02\x02\x12\x03.\
    \x02B\n\x0c\n\x05\x04\x04\x02\x02\x06\x12\x03.\x02\x17\n\x0c\n\x05\x04\
    \x04\x02\x02\x01\x12\x03.\x18\x1c\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\
    \x03.!\"\n\x0c\n\x05\x04\x04\x02\x02\x08\x12\x03.#A\n\x0f\n\x08\x04\x04\
    \x02\x02\x08\xe9\xfb\x03\x12\x03.$@\nH\n\x02\x04\x05\x12\x042\04\x01\x1a\
    <\x20Vote\x20is\x20sent\x20when\x20voting\x20for\x20a\x20proposal\x20(or\
    \x20lack\x20thereof).\n\n\n\n\x03\x04\x05\x01\x12\x032\x08\x0c\n\x0b\n\
    \x04\x04\x05\x02\0\x12\x033\x02!\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x033\
    \x02\x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x033\x18\x1c\n\x0c\n\x05\x04\
    \x05\x02\0\x03\x12\x033\x1f\x20\nS\n\x02\x04\x06\x12\x047\0<\x01\x1aG\
    \x20HasVote\x20is\x20sent\x20to\x20indicate\x20that\x20a\x20particular\
    \x20vote\x20has\x20been\x20received.\n\n\n\n\x03\x04\x06\x01\x12\x037\
    \x08\x0f\n\x0b\n\x04\x04\x06\x02\0\x12\x038\x02,\n\x0c\n\x05\x04\x06\x02\
    \0\x05\x12\x038\x02\x07\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x038!'\n\x0c\n\
    \x05\x04\x06\x02\0\x03\x12\x038*+\n\x0b\n\x04\x04\x06\x02\x01\x12\x039\
    \x02,\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x039\x02\x07\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x039!&\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x039*+\n\
    \x0b\n\x04\x04\x06\x02\x02\x12\x03:\x02,\n\x0c\n\x05\x04\x06\x02\x02\x06\
    \x12\x03:\x02\x20\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03:!%\n\x0c\n\x05\
    \x04\x06\x02\x02\x03\x12\x03:*+\n\x0b\n\x04\x04\x06\x02\x03\x12\x03;\x02\
    ,\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03;\x02\x07\n\x0c\n\x05\x04\x06\
    \x02\x03\x01\x12\x03;!&\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03;*+\nX\n\
    \x02\x04\x07\x12\x04?\0D\x01\x1aL\x20VoteSetMaj23\x20is\x20sent\x20to\
    \x20indicate\x20that\x20a\x20given\x20BlockID\x20has\x20seen\x20+2/3\x20\
    votes.\n\n\n\n\x03\x04\x07\x01\x12\x03?\x08\x14\n\x0b\n\x04\x04\x07\x02\
    \0\x12\x03@\x02.\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03@\x02\x07\n\x0c\n\
    \x05\x04\x07\x02\0\x01\x12\x03@!'\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03@\
    ,-\n\x0b\n\x04\x04\x07\x02\x01\x12\x03A\x02.\n\x0c\n\x05\x04\x07\x02\x01\
    \x05\x12\x03A\x02\x07\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03A!&\n\x0c\n\
    \x05\x04\x07\x02\x01\x03\x12\x03A,-\n\x0b\n\x04\x04\x07\x02\x02\x12\x03B\
    \x02.\n\x0c\n\x05\x04\x07\x02\x02\x06\x12\x03B\x02\x20\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03B!%\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03B,-\n\
    \x0b\n\x04\x04\x07\x02\x03\x12\x03C\x02q\n\x0c\n\x05\x04\x07\x02\x03\x06\
    \x12\x03C\x02\x1a\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03C!)\n\x0c\n\x05\
    \x04\x07\x02\x03\x03\x12\x03C,-\n\x0c\n\x05\x04\x07\x02\x03\x08\x12\x03C\
    .p\n\x0f\n\x08\x04\x07\x02\x03\x08\xec\xfb\x03\x12\x03C/Q\n\x0f\n\x08\
    \x04\x07\x02\x03\x08\xe9\xfb\x03\x12\x03CSo\n]\n\x02\x04\x08\x12\x04G\0M\
    \x01\x1aQ\x20VoteSetBits\x20is\x20sent\x20to\x20communicate\x20the\x20bi\
    t-array\x20of\x20votes\x20seen\x20for\x20the\x20BlockID.\n\n\n\n\x03\x04\
    \x08\x01\x12\x03G\x08\x13\n\x0b\n\x04\x04\x08\x02\0\x12\x03H\x02.\n\x0c\
    \n\x05\x04\x08\x02\0\x05\x12\x03H\x02\x07\n\x0c\n\x05\x04\x08\x02\0\x01\
    \x12\x03H!'\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03H,-\n\x0b\n\x04\x04\x08\
    \x02\x01\x12\x03I\x02.\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03I\x02\x07\
    \n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03I!&\n\x0c\n\x05\x04\x08\x02\x01\
    \x03\x12\x03I,-\n\x0b\n\x04\x04\x08\x02\x02\x12\x03J\x02.\n\x0c\n\x05\
    \x04\x08\x02\x02\x06\x12\x03J\x02\x20\n\x0c\n\x05\x04\x08\x02\x02\x01\
    \x12\x03J!%\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03J,-\n\x0b\n\x04\x04\
    \x08\x02\x03\x12\x03K\x02q\n\x0c\n\x05\x04\x08\x02\x03\x06\x12\x03K\x02\
    \x1a\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03K!)\n\x0c\n\x05\x04\x08\x02\
    \x03\x03\x12\x03K,-\n\x0c\n\x05\x04\x08\x02\x03\x08\x12\x03K.p\n\x0f\n\
    \x08\x04\x08\x02\x03\x08\xec\xfb\x03\x12\x03K/Q\n\x0f\n\x08\x04\x08\x02\
    \x03\x08\xe9\xfb\x03\x12\x03KSo\n\x0b\n\x04\x04\x08\x02\x04\x12\x03L\x02\
    M\n\x0c\n\x05\x04\x08\x02\x04\x06\x12\x03L\x02\x1f\n\x0c\n\x05\x04\x08\
    \x02\x04\x01\x12\x03L!&\n\x0c\n\x05\x04\x08\x02\x04\x03\x12\x03L,-\n\x0c\
    \n\x05\x04\x08\x02\x04\x08\x12\x03L.L\n\x0f\n\x08\x04\x08\x02\x04\x08\
    \xe9\xfb\x03\x12\x03L/K\n\n\n\x02\x04\t\x12\x04O\0[\x01\n\n\n\x03\x04\t\
    \x01\x12\x03O\x08\x0f\n\x0c\n\x04\x04\t\x08\0\x12\x04P\x02Z\x03\n\x0c\n\
    \x05\x04\t\x08\0\x01\x12\x03P\x08\x0b\n\x0b\n\x04\x04\t\x02\0\x12\x03Q\
    \x04&\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03Q\x04\x10\n\x0c\n\x05\x04\t\x02\
    \0\x01\x12\x03Q\x12\x20\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03Q$%\n\x0b\n\
    \x04\x04\t\x02\x01\x12\x03R\x04&\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03R\
    \x04\x11\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03R\x12!\n\x0c\n\x05\x04\t\
    \x02\x01\x03\x12\x03R$%\n\x0b\n\x04\x04\t\x02\x02\x12\x03S\x04&\n\x0c\n\
    \x05\x04\t\x02\x02\x06\x12\x03S\x04\x0c\n\x0c\n\x05\x04\t\x02\x02\x01\
    \x12\x03S\x12\x1a\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03S$%\n\x0b\n\x04\
    \x04\t\x02\x03\x12\x03T\x04&\n\x0c\n\x05\x04\t\x02\x03\x06\x12\x03T\x04\
    \x0f\n\x0c\n\x05\x04\t\x02\x03\x01\x12\x03T\x12\x1e\n\x0c\n\x05\x04\t\
    \x02\x03\x03\x12\x03T$%\n\x0b\n\x04\x04\t\x02\x04\x12\x03U\x04&\n\x0c\n\
    \x05\x04\t\x02\x04\x06\x12\x03U\x04\r\n\x0c\n\x05\x04\t\x02\x04\x01\x12\
    \x03U\x12\x1c\n\x0c\n\x05\x04\t\x02\x04\x03\x12\x03U$%\n\x0b\n\x04\x04\t\
    \x02\x05\x12\x03V\x04&\n\x0c\n\x05\x04\t\x02\x05\x06\x12\x03V\x04\x08\n\
    \x0c\n\x05\x04\t\x02\x05\x01\x12\x03V\x12\x16\n\x0c\n\x05\x04\t\x02\x05\
    \x03\x12\x03V$%\n\x0b\n\x04\x04\t\x02\x06\x12\x03W\x04&\n\x0c\n\x05\x04\
    \t\x02\x06\x06\x12\x03W\x04\x0b\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03W\
    \x12\x1a\n\x0c\n\x05\x04\t\x02\x06\x03\x12\x03W$%\n\x0b\n\x04\x04\t\x02\
    \x07\x12\x03X\x04&\n\x0c\n\x05\x04\t\x02\x07\x06\x12\x03X\x04\x10\n\x0c\
    \n\x05\x04\t\x02\x07\x01\x12\x03X\x12\x20\n\x0c\n\x05\x04\t\x02\x07\x03\
    \x12\x03X$%\n\x0b\n\x04\x04\t\x02\x08\x12\x03Y\x04&\n\x0c\n\x05\x04\t\
    \x02\x08\x06\x12\x03Y\x04\x0f\n\x0c\n\x05\x04\t\x02\x08\x01\x12\x03Y\x12\
    \x1f\n\x0c\n\x05\x04\t\x02\x08\x03\x12\x03Y$%b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(NewRoundStep::generated_message_descriptor_data());
            messages.push(NewValidBlock::generated_message_descriptor_data());
            messages.push(Proposal::generated_message_descriptor_data());
            messages.push(ProposalPOL::generated_message_descriptor_data());
            messages.push(BlockPart::generated_message_descriptor_data());
            messages.push(Vote::generated_message_descriptor_data());
            messages.push(HasVote::generated_message_descriptor_data());
            messages.push(VoteSetMaj23::generated_message_descriptor_data());
            messages.push(VoteSetBits::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
